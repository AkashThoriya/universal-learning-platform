{
  "id": "dsa_by_namastedev",
  "name": "DSA by namastedev",
  "description": "Comprehensive Data Structures and Algorithms course by namastedev covering fundamentals to advanced topics with detailed explanations and practical implementations JavaScript-focused approach for DSA mastery.",
  "category": "Computer Science",
  "stages": [
    {
      "id": "foundation",
      "name": "Foundation Assessment",
      "totalMarks": 100,
      "duration": 180,
      "sections": [
        {
          "id": "programming_basics",
          "name": "Programming Fundamentals",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "problem_solving",
          "name": "Problem Solving & Logic",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "data_structures",
          "name": "Data Structures Fundamentals",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "algorithms",
          "name": "Algorithm Analysis",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "intermediate",
      "name": "Intermediate Skills Assessment",
      "totalMarks": 150,
      "duration": 270,
      "sections": [
        {
          "id": "advanced_ds",
          "name": "Advanced Data Structures",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "tree_graph",
          "name": "Trees and Graphs",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "dynamic_programming",
          "name": "Dynamic Programming & Greedy",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    }
  ],
  "defaultSyllabus": [
    {
      "id": "introduction",
      "name": "Introduction",
      "tier": 1,
      "estimatedHours": 1.5,
      "topics": [
        {
          "id": "course_introduction",
          "name": "Introduction",
          "estimatedHours": 1,
          "description": "Learn how to navigate the course and what you'll cover",
          "learningTip": [
            "**Consistency > Intensity:** Solving 1 problem daily for 30 days outweighs 30 problems in one weekend.",
            "**Pattern Recognition:** Don't memorize code. Memorize the *signals* (e.g., 'Sorted Array' -> Binary Search).",
            "**JS Specific:** Mastering `map`, `reduce`, `filter` and `Callbacks` is crucial for JS interviews."
          ],
          "mustNotMiss": [
            "**Input Constraints:** Always check N. N=10^5 means O(n) or O(n log n). N=1000 means O(n²) is okay.",
            "**Edge Cases:** [] (empty), [1] (single), negative numbers, duplicates.",
            "**Dry Run:** Trace your code with variables on paper before running it. This is the #1 signal of a senior engineer."
          ],
          "resources": [
            "https://www.bigocheatsheet.com/"
          ]
        },
        {
          "id": "language_choice",
          "name": "Which language?",
          "estimatedHours": 0.5,
          "description": "Learn how to choose your preferred programming language for the course",
          "learningTip": [
            "**JavaScript for DSA:** It's a great choice! V8 is fast, and syntax is concise.",
            "**Pitfalls to Avoid:** `var` (scoping issues), loose equality `==`, and accidental global variables.",
            "**Built-ins:** Know your `Math.max()`, `Array.sort()`, `Set`, and `Map` APIs inside out."
          ],
          "mustNotMiss": [
            "**Numbers:** JS numbers are IEEE 754 Floats. Safe integer limit is 2^53. Use `BigInt` for huge numbers.",
            "**Sorting:** `arr.sort()` sorts *alphabetically* by default! Always use `arr.sort((a,b) => a-b)` for numbers.",
            "**Recursion:** Max stack depth is ~10,000 in most JS engines. Watch out for Stack Overflow."
          ],
          "interviewQuestions": [
            {
              "question": "Why use JavaScript for DSA?",
              "answer": "**Pros:** \n*   Ubiquitous (Web). \n*   Concise syntax (Arrow functions, Destructuring). \n*   Rich Standard Library (Sets, Maps, Array methods).\n**Cons:** \n*   No built-in Heap/PriorityQueue (unlike Python/Java/C++)."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
          ]
        }
      ]
    },
    {
      "id": "warm_up",
      "name": "Warm Up",
      "tier": 1,
      "estimatedHours": 9.5,
      "topics": [
        {
          "id": "warm_up_introduction",
          "name": "Warm Up - Introduction",
          "estimatedHours": 0.5,
          "description": "Warm-up session for diving into DSA concepts",
          "learningTip": [
            "**Fundamentals First:** 80% of bugs in interviews come from basic logic errors (off-by-one, type coercion, unhandled nulls).",
            "**JS Mastery:** You need to be fast. `arr.map`, `arr.reduce`, `destructuring`, and `spread operator` should be muscle memory."
          ],
          "mustNotMiss": [
            "**Type Coercion:** `1 + '2' = '12'` but `1 - '2' = -1`. Use TypeScript mental model: always know your types.",
            "**Equality:** Always use `===`. `==` allows `0 == false` (true) which causes subtle bugs.",
            "**Destructuring:** `const [first, ...rest] = arr` is O(n), NOT O(1)! Be careful inside loops."
          ],
          "interviewQuestions": [
            {
              "question": "What is the difference between `==` and `===` in JavaScript?",
              "answer": "**`==` (Loose Equality):** Performs type coercion before comparison (e.g., `'5' == 5` is true). \n**`===` (Strict Equality):** Checks both value and type (e.g., `'5' === 5` is false). \n*Best Practice:* Always use `===` to avoid unexpected behavior."
            },
            {
              "question": "Explain 'Hoisting' in JavaScript. How does `let/const` differ from `var`?",
              "answer": "**Hoisting:** Variable and function declarations are moved to the top of their scope. \n*   `var`: Hoisted and initialized with `undefined`. \n*   `let/const`: Hoisted but in 'Temporal Dead Zone' (TDZ) until declaration line. Accessing them before declaration throws ReferenceError."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness",
            "https://javascript.info/types"
          ]
        },
        {
          "id": "programming_101",
          "name": "Programming 101",
          "estimatedHours": 1,
          "description": "Learn the basics of programming with simple concepts explained clearly",
          "learningTip": [
            "**Number Precision:** JS integers are safe only up to 2^53 - 1. Above that, you lose precision unless you use `BigInt`.",
            "**Floating Point:** `0.1 + 0.2 !== 0.3`. Use `Math.abs(a - b) < Number.EPSILON` for float comparisons."
          ],
          "mustNotMiss": [
            "**MAX_SAFE_INTEGER:** `9007199254740991` (2^53 - 1). Memorize `Number.MAX_SAFE_INTEGER`.",
            "**BigInt:** Use `10n` for BigInt literals. Do not mix BigInt and Number in math operations (throws TypeError).",
            "**Integer Division:** `5 / 2` is `2.5` in JS. Use `Math.floor(5/2)` or `Math.trunc(5/2)` for integer division."
          ],
          "interviewQuestions": [
            {
              "question": "Why does `0.1 + 0.2 === 0.3` return `false` in JavaScript?",
              "answer": "Because JavaScript uses **IEEE 754** double-precision floating-point numbers. \n*   0.1 and 0.2 cannot be represented exactly in binary. \n*   The sum is actually `0.30000000000000004`."
            },
            {
              "question": "What is `BigInt` and when should you use it?",
              "answer": "**BigInt** is a primitive for integers larger than `2^53 - 1`. \n*   **Use when:** Solving problems with constraints like `N <= 10^100` (e.g., Large Factorials, RSA encryption). \n*   **Syntax:** `const big = 12345678901234567890n;`"
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER",
            "https://0.30000000000000004.com/"
          ]
        },
        {
          "id": "function_if_else",
          "name": "Function, if-else",
          "estimatedHours": 0.5,
          "description": "Master functions and conditional logic with if-else statements",
          "learningTip": [
            "**Functions:** First-class citizens. Can be stored in variables, passed as args, and returned from other functions.",
            "**Arrow Functions:** Concise syntax `(args) => expr`. They do NOT have their own `this` (lexical scoping).",
            "**Ternary Operator:** Cleaner than if-else for simple value assignment: `const max = a > b ? a : b;`."
          ],
          "mustNotMiss": [
            "**Arrow Syntax:** `const add = (a, b) => a + b` (implicit return). Block body `{ return a + b }` requires explicit return.",
            "**Short-Circuiting:** `node && node.val` (Guard clause). `val || default` (Default value).",
            "**Nullish Coalescing:** `value ?? default`. Use this instead of `||` when `0` or `''` are valid values."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between `function` declaration and Arrow function?",
              "answer": "**1. `this` binding:** Standard functions have dynamic `this`. Arrow functions have lexical `this` (inherit from parent). \n**2. Arguments:** Arrow functions don't have the `arguments` object. \n**3. Hoisting:** Declarations are hoisted; Arrow functions (assigned to constants) are not."
            },
            {
              "question": "What is the difference between `||` and `??`?",
              "answer": "**`||` (OR):** Returns RHS if LHS is **Falsy** (false, 0, '', null, undefined). \n**`??` (Nullish Coalescing):** Returns RHS *only* if LHS is **Nullish** (null, undefined). \n*   Use `??` when `0` is a valid value you want to keep."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing",
            "https://javascript.info/arrow-functions-basics"
          ]
        },
        {
          "id": "loops_01",
          "name": "Loops 01",
          "estimatedHours": 1,
          "description": "Learn looping constructs to repeat code effectively",
          "learningTip": [
            "**for:** Best for index access (`i`) and controlling step size (`i += 2`). The go-to for standard array problems.",
            "**for...of:** Best for directly accessing values in Arrays, Strings, Sets, Maps. Cleaner syntax.",
            "**Functional:** `forEach`, `map`, `filter`. Good for transformation, but handling `break`/`return` is tricky."
          ],
          "mustNotMiss": [
            "**Classic for:** `for (let i = 0; i < n; i++)` -> Fastest, most flexible.",
            "**for...of:** `for (const char of str)` -> Great for strings/arrays. Cannot access index directly.",
            "**for...in:** `for (const key in obj)` -> Iterates **Keys**, not values. Do NOT use for arrays (iterates prototype properties too!)."
          ],
          "interviewQuestions": [
            {
              "question": "Why shouldn't you use `for...in` for Arrays in JavaScript?",
              "answer": "**1. Order:** Iteration order is implementation-dependent (not guaranteed). \n**2. Type:** Keys are strings (`'0'`, `'1'`), not numbers. \n**3. Prototype:** It iterates over inherited enumerable properties, not just array elements."
            },
            {
              "question": "How do you break out of a `forEach` loop?",
              "answer": "You **cannot** break a `forEach` loop using `break` or `return`. \n*   **Solution:** Use `for...of`, `for` loop, or throw an exception (ugly). usage of `some()` or `every()` is a functional alternative."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of",
            "https://thecodebarbarian.com/for-vs-for-each-vs-for-in-loops-in-javascript.html"
          ]
        },
        {
          "id": "loops_02",
          "name": "Loops 02",
          "estimatedHours": 1.5,
          "description": "Deep dive into advanced loop techniques and nested loops",
          "learningTip": [
            "**Complexity:** Nested loops usually mean O(n²). Acceptable for N <= 5000, bad for N > 10^4.",
            "**Optimization:** Always ask: 'Can I use a HashMap or Two Pointers to remove the inner loop?'",
            "**Matrix:** Process grid problems with `for(row){ for(col) }`. Visualization is key."
          ],
          "mustNotMiss": [
            "**Breaking Nested:** Use a **Labeled Statement** to break out of both loops: `outer: for(...) { break outer; }`.",
            "**Function Return:** Extract loops to a function and `return` to exit immediately (cleaner).",
            "**Cache Length:** `for(let i=0; i < arr.length)` is fine, modern engines optimize it. No need to `let len = arr.length` anymore."
          ],
          "interviewQuestions": [
            {
              "question": "How do you break out of nested loops in JavaScript?",
              "answer": "**1. Labeled Break:** explicit label `loop1: for(...) { break loop1; }` \n**2. Function Return:** Wrap in a function and `return`. \n**3. Flags:** Set a boolean `isFound = true` and check it in the outer loop."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label"
          ]
        },
        {
          "id": "second_largest",
          "name": "Second Largest",
          "estimatedHours": 1,
          "description": "Find the second largest number in an array efficiently",
          "practiceQuestions": [
            {
              "name": "Second Largest Digit in a String",
              "slug": "second-largest-digit-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/second-largest-digit-in-a-string/"
            }
          ],
          "learningTip": [
            "**Single Pass:** You can find the 2nd (or Kth) largest in O(n) without sorting. Sorting takes O(n log n).",
            "**Initialization:** Start with `-Infinity`. If inputs can be negative, standard `0` initialization fails.",
            "**State Machine:** As you iterate, `current` pushes `largest` down to `second`, and `largest` takes the new value."
          ],
          "mustNotMiss": [
            "**Algorithm:** `if (num > largest) { second = largest; largest = num; } else if (num > second && num != largest) { second = num; }`",
            "**Edge Case:** All elements identical (e.g., `[5, 5]`) -> `second` remains `-Infinity`. Handle this return value.",
            "**Stream Processing:** This approach works on data streams where you can't store all elements."
          ],
          "interviewQuestions": [
            {
              "question": "How to find the K-th largest element in an unsorted array?",
              "answer": "**1. Sorting:** O(N log N) - simplest. \n**2. Min-Heap:** O(N log K) - keep heap size K. \n**3. QuickSelect:** O(N) average, O(N²) worst case. \n*   For K=2, just use variables (O(N))."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/",
            "https://www.geeksforgeeks.org/find-second-largest-element-array/"
          ]
        },
        {
          "id": "loop_in_loop",
          "name": "Loop in Loop",
          "estimatedHours": 1,
          "description": "Learn how to implement nested loops for complex patterns",
          "learningTip": [
            "Visualize nested loops as traversing a 2D grid",
            "Outer loop controls rows, inner loop controls columns",
            "This mental model transfers directly to matrix problems",
            "Index relationship between loops defines the pattern"
          ],
          "mustNotMiss": [
            "Inner 0 to n: full matrix (n × n iterations)",
            "Inner i to n: upper triangle (avoid duplicates in pair enumeration)",
            "Inner 0 to i: lower triangle",
            "Draw small examples (3×3) and trace through manually before coding"
          ],
          "interviewQuestions": [
            {
              "question": "Complexity of dependent nested loops?",
              "answer": "**Sum of series:** \n*   `for(i=0..N) for(j=0..i)` basically sums `1 + 2 + ... + N`. \n*   Sum is `N*(N+1)/2`, which is O(N²)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/analysis-of-algorithms-set-4-analysis-of-loops/"
          ]
        },
        {
          "id": "star_pattern",
          "name": "Star Pattern",
          "estimatedHours": 1.5,
          "description": "Draw star patterns using nested loops for practice",
          "learningTip": [
            "**Grid Visualization:** Nested loops map perfectly to 2D coordinates `(row, col)`.",
            "**Mathematical Relation:** The relationship between `row` and `col` defines the shape. \n*   `col <= row`: Lower Triangle. \n*   `col >= row`: Upper Triangle.",
            "**Foundation:** This tracks directly to Matrix Traversal and Dynamic Programming (filling DP tables)."
          ],
          "mustNotMiss": [
            "**Square:** `i: 0->n, j: 0->n` (O(n²))",
            "**Triangle:** `i: 0->n, j: 0->i` (O(n²/2) -> O(n²))",
            "**Debugging:** Always print `row, col` values if logic fails. Off-by-one errors are common here."
          ],
          "interviewQuestions": [
            {
              "question": "What is the time complexity of a loop `for(i=1; i<=n; i*=2)`?",
              "answer": "**O(log N)**. \n*   The loop variable doubles each step ($1, 2, 4, 8...$). \n*   It takes $\\log_2 N$ steps to reach N."
            }
          ],
          "resources": [
            "https://www.programiz.com/javascript/examples/pyramid-pattern"
          ]
        },
        {
          "id": "count_digit",
          "name": "Count Digit",
          "estimatedHours": 0.5,
          "description": "Count the number of digits in an integer",
          "learningTip": [
            "**Digit Extraction:** `n % 10` gets the last digit. `Math.floor(n / 10)` removes it. Repeat until `n > 0`.",
            "**Logarithmic Approach:** Number of digits = `Math.floor(Math.log10(n)) + 1` (O(1) math operation).",
            "**String Approach:** `n.toString().length` (O(log n) internally, but allocates memory)."
          ],
          "mustNotMiss": [
            "**Negative Numbers:** `Math.floor(-123 / 10)` is `-13`, NOT `-12`! Work with `Math.abs(n)` first.",
            "**Time Complexity:** O(log₁₀ n) - because number of digits grows logarithmically with value.",
            "**The While Loop:** `while (n > 0) { count++; n = Math.floor(n/10); }`"
          ],
          "interviewQuestions": [
            {
              "question": "How to check if a number is a power of 2 without loops/recursion?",
              "answer": "**Bitwise Trick:** `(n > 0) && ((n & (n - 1)) === 0)`. \n*   Powers of 2 have exactly one bit set (e.g., `1000`). \n*   `n-1` flips that bit and all lower bits (e.g., `0111`). \n*   AND operation becomes 0."
            }
          ],
          "resources": [
            "https://stackoverflow.com/questions/1489830/efficient-way-to-determine-number-of-digits-in-an-integer",
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10"
          ]
        },
        {
          "id": "palindrome",
          "name": "Palindrome",
          "estimatedHours": 0.5,
          "description": "Check if a string or number is a palindrome",
          "practiceQuestions": [
            {
              "name": "Palindrome Number",
              "slug": "palindrome-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-number/"
            }
          ],
          "learningTip": [
            "**Definition:** Reads same forward and backward. Examples: `121`, `racecar`.",
            "**Approaches:** \n1. **String:** Reverse and compare (O(n) space). \n2. **Two Pointers:** Compare start and end (O(1) space). \n3. **Math:** Reverse the number mathematically (O(1) space for ints).",
            "**Optimization:** You only need to compare up to the *middle*."
          ],
          "mustNotMiss": [
            "**Negative Numbers:** ` -121` becomes `121-` -> NOT a palindrome.",
            "**Two Pointers:** `while(left < right) { if(s[left] !== s[right]) return false; left++; right--; }`.",
            "**Alphanumeric:** Interviewers often say \"ignoring non-alphanumeric\". Use regex `/[^a-z0-9]/gi` or simple character range checks."
          ],
          "interviewQuestions": [
            {
              "question": "Check palindrome without converting integer to string?",
              "answer": "**Revert Half:** \n*   Run loop `while(x > revertedNumber)`. \n*   Build `revertedNumber = revertedNumber * 10 + x % 10`. \n*   Check `x === revertedNumber` or `x === revertedNumber/10` (for odd length)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-palindrome/",
            "https://en.wikipedia.org/wiki/Palindrome"
          ]
        },
        {
          "id": "reverse_integer",
          "name": "Reverse Integer",
          "estimatedHours": 0.5,
          "description": "Reverse the digits of an integer programmatically",
          "practiceQuestions": [
            {
              "name": "Reverse Integer",
              "slug": "reverse-integer",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-integer/"
            }
          ],
          "learningTip": [
            "**Formula:** `rev = (rev * 10) + digit`. This shifts existing digits left and adds the new one.",
            "**Constraints:** 32-bit signed integer range `[-2^31, 2^31 - 1]` is the standard interview constraint.",
            "**JS Note:** JS numbers are 64-bit floats. You usually don't *crash* on overflow, but you lose precision or get incorrect answers. You must manually check against `MAX_SAFE_INTEGER` or the 32-bit limit."
          ],
          "mustNotMiss": [
            "**Overflow Check:** Before `rev * 10 + digit`, check if `rev > (MAX_INT - digit)/10`.",
            "**Sign:** Remember to preserve the sign (or work with `Math.abs()` and re-apply).",
            "**Input 0:** Returns 0."
          ],
          "interviewQuestions": [
            {
              "question": "What happens if reversing an integer exceeds the 32-bit range?",
              "answer": "Return 0. \n*   Standard problem constraint (LeetCode #7). \n*   Always clarify with interviewer: 'Should I return 0, throw error, or use BigInt?'"
            }
          ],
          "resources": [
            "https://leetcode.com/problems/reverse-integer/",
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign"
          ]
        }
      ]
    },
    {
      "id": "time_space_complexity",
      "name": "Time/Space Complexity",
      "tier": 1,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "time_space_complexity_analysis",
          "name": "Time & Space Complexity",
          "estimatedHours": 2,
          "description": "Understand how to analyze code performance using time complexity",
          "learningTip": [
            "**Trade-offs:** Often we buy Time by spending Space (HashMaps). Strategies usually revolve around this trade-off.",
            "**Recursion Space:** It is NEVER O(1). It is O(depth) due to the call stack.",
            "**Amortized Analysis:** Dynamic Arrays (pushing to array) is O(1) amortized, but O(n) worst case (resizing)."
          ],
          "mustNotMiss": [
            "**O(1):** Hashmap lookup, Array index access.",
            "**O(log n):** Binary Search, Heap operations.",
            "**O(n):** Iterating, Linear Search.",
            "**O(n log n):** Merge Sort, Quick Sort, Heap Sort.",
            "**O(2^n):** Recursive Fibonacci, Subsets (Backtracking)."
          ],
          "interviewQuestions": [
            {
              "question": "What is Amortized Time Complexity? Give an example.",
              "answer": "**Amortized Time** is the average time per operation over a sequence of operations. \n*   **Example:** Resizing `ArrayList`/`Vector`. \n*   Most pushes are O(1). Occasionally, we double the size (O(n)). \n*   Spread over n operations, the cost is still O(1)."
            },
            {
              "question": "Why is QuickSort O(n log n) best case but O(n²) worst case?",
              "answer": "**Pivot Selection:** \n*   **Best Case:** Pivot divides array into two equal halves (log n depth). \n*   **Worst Case:** Pivot is always the smallest/largest element (n depth). \n*   Randomized Pivot fixes this in practice."
            }
          ],
          "resources": [
            "https://www.bigocheatsheet.com/",
            "https://en.wikipedia.org/wiki/Amortized_analysis"
          ]
        }
      ]
    },
    {
      "id": "arrays_easy_medium",
      "name": "Arrays - Easy/Medium",
      "tier": 2,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "remove_duplicates",
          "name": "Remove Duplicates",
          "estimatedHours": 2,
          "description": "Remove duplicate elements from a sorted array",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted Array",
              "slug": "remove-duplicates-from-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
            },
            {
              "name": "Contains Duplicate",
              "slug": "contains-duplicate",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/contains-duplicate/"
            },
            {
              "name": "Remove Duplicates from Sorted Array II",
              "slug": "remove-duplicates-from-sorted-array-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/"
            },
            {
              "name": "Next Permutation",
              "slug": "next-permutation",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/next-permutation/"
            }
          ],
          "learningTip": [
            "**Two Pointers:** Slow pointer `i` tracks the *unique* zone. Fast pointer `j` scans ahead.",
            "**In-Place constraint:** You cannot use a Hash Set (would be O(n) space).",
            "**Invariant:** Everything before `i` is sorted and unique.",
            "Elements before slow pointer are the result."
          ],
          "mustNotMiss": [
            "**Algorithm:** `i=0`; `for(j=1; j<n; j++)`. If `nums[i] !== nums[j]`, then `i++`, `nums[i] = nums[j]`.",
            "**Return:** `i + 1` (length), not `i` (index).",
            "**Optimization:** Skip the copy if `i` and `j` are adjacent (minor)."
          ],
          "interviewQuestions": [
            {
              "question": "How would you solve this if we allowed at most 2 duplicates?",
              "answer": "**Modification:** Use the same Two Pointer logic, but compare `nums[j]` with `nums[i-1]` (the element before the current write position). \n*   `if (nums[j] != nums[i-1])` -> safe to copy."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution/",
            "https://visualgo.net/en/sorting"
          ]
        },
        {
          "id": "remove_element",
          "name": "Remove Element",
          "estimatedHours": 0.5,
          "description": "Remove specific elements from an array",
          "practiceQuestions": [
            {
              "name": "Remove Element",
              "slug": "remove-element",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-element/"
            }
          ],
          "learningTip": [
            "**Order Irrelevant:** This is the key. Since order doesn't matter, you can replace the removed element with the *last* element.",
            "**Optimization:** The 'Swap with Last' strategy reduces writes compared to 'Shift All Left'.",
            "**Two Valid Approaches:** Scan-and-Shift (preserves order) vs Swap-with-End (O(n) but fewer writes)."
          ],
          "mustNotMiss": [
            "**Swap Strategy:** If `nums[i] == val`, `nums[i] = nums[n-1]`, `n--`. Don't increment `i` (check the new swapped value again!).",
            "**Shift Strategy:** Standard Two Pointers. `if nums[j] != val, nums[i++] = nums[j]`.",
            "**Return:** The new length."
          ],
          "interviewQuestions": [
            {
              "question": "When would you choose Swap-with-End over Shift-Left?",
              "answer": "**Minimize Writes:** If removals are rare, Swap-with-End does O(removals) writes. Shift-Left does O(N) writes. \n*   Important for flash memory (write endurance) or massive objects."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-element/"
          ]
        },
        {
          "id": "reverse_string",
          "name": "Reverse String",
          "estimatedHours": 1,
          "description": "Reverse the characters of a string",
          "learningTip": [
            "**Two Pointers:** One at start `left = 0`, one at `right = n-1`. Swap and move inward.",
            "**Immutability:** logic works on arrays. For strings in Java/JS/Python, allow O(n) space to convert to char array.",
            "**Recursion:** Possible (`reverse(s.substring(1)) + s[0]`) but bad space complexity O(n)."
          ],
          "mustNotMiss": [
            "**Swap Logic:** `temp = arr[l]; arr[l] = arr[r]; arr[r] = temp;` OR Destructuring: `[arr[l], arr[r]] = [arr[r], arr[l]]`.",
            "**Termination:** `while (left < right)`. Middle element (in odd length) doesn't need swapping.",
            "**Space:** O(1) auxiliary space (in-place)."
          ],
          "interviewQuestions": [
            {
              "question": "How to reverse a string with O(1) space in Java/C#?",
              "answer": "**You can't.** Strings are immutable. You MUST allocate a new char array. \n*   In C++ (`std::string`), it is mutable, so O(1) space is possible."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/reverse-string/"
          ],
          "practiceQuestions": [
            {
              "name": "Rotate Array",
              "slug": "rotate-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-array/"
            }
          ]
        },
        {
          "id": "best_time_buy_sell_stocks",
          "name": "Best Time to Buy and Sell Stocks",
          "estimatedHours": 1,
          "description": "Maximize profit from stock prices using smart strategy",
          "practiceQuestions": [
            {
              "name": "Best Time to Buy and Sell Stock",
              "slug": "best-time-to-buy-and-sell-stock",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
            },
            {
              "name": "Product of Array Except Self",
              "slug": "product-of-array-except-self",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/product-of-array-except-self/"
            }
          ],
          "learningTip": [
            "**Greedy/One Pass:** You don't need to check every pair (O(n²)). You only need the *minimum specific price* you've seen *before* today.",
            "**Analogy:** \"I'll buy at the lowest price I've seen. If today's price is higher, I profit. If today's price is lower, I wish I bought now (so update min).\"",
            "**Kadane's Connection:** `maxCur = max(0, maxCur + changes)` is similar logic."
          ],
          "mustNotMiss": [
            "**Algorithm:** `minPrice = Infinity`, `maxProfit = 0`. Loop `price` in `prices`.",
            "**Update:** `minPrice = min(minPrice, price)`.",
            "**Calculate:** `maxProfit = max(maxProfit, price - minPrice)`.",
            "**Return:** `maxProfit`."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle the case where you can buy and sell multiple times?",
              "answer": "**Valley-Peak Approach:** \n*   Simply add *every* positive increase (`price[i] - price[i-1] > 0`). \n*   This captures all upward trends. (LeetCode 122)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
            "https://en.wikipedia.org/wiki/Maximum_subarray_problem"
          ]
        },
        {
          "id": "merge_sorted_arrays",
          "name": "Merge Sorted Arrays",
          "estimatedHours": 1,
          "description": "Merge two sorted arrays into one sorted array",
          "practiceQuestions": [
            {
              "name": "Merge Sorted Array",
              "slug": "merge-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-sorted-array/"
            }
          ],
          "learningTip": [
            "**Merging is Fundamental:** It's the heart of Merge Sort (divide and conquer).",
            "**Backwards Merge:** Filling from the end avoids overwriting elements in `nums1` that we still need to read.",
            "**Three Pointers:** `p1` (end of valid nums1), `p2` (end of nums2), `p` (end of total capacity)."
          ],
          "mustNotMiss": [
            "**Algorithm:** `p1=m-1, p2=n-1, p=m+n-1`. While `p2 >= 0`.",
            "**Logic:** If `p1 >= 0 && nums1[p1] > nums2[p2]`, put `nums1[p1]` at `p`. Else put `nums2[p2]` at `p`.",
            "**Termination:** We only care if `p2` finishes. If `p1` finishes first, `nums2` leftovers must be copied. If `p2` finishes first, `nums1` is already in place."
          ],
          "interviewQuestions": [
            {
              "question": "How to merge K sorted arrays?",
              "answer": "**Min-Heap Approach:** \n*   Push the first element of each array into a min-heap. \n*   Pop min, add to result, push next element from that array. \n*   **Complexity:** O(N log K)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/merge-sorted-array/"
          ]
        },
        {
          "id": "move_zeros",
          "name": "Move Zeros",
          "estimatedHours": 1,
          "description": "Move all zeros to the end of the array without changing order",
          "practiceQuestions": [
            {
              "name": "Move Zeroes",
              "slug": "move-zeroes",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/move-zeroes/"
            },
            {
              "name": "Pascal's Triangle",
              "slug": "pascals-triangle",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/pascals-triangle/"
            }
          ],
          "learningTip": [
            "**Partitioning:** Similar to QuickSort. Elements != 0 belong on the left.",
            "**Two Pointers:** `lastNonZeroFoundAt` tracks the boundary between non-zeros and the rest.",
            "**Minimize Writes:** Swapping is better than filling because it touches each element fewer times."
          ],
          "mustNotMiss": [
            "**Algorithm:** `idx = 0`. Loop `i` from 0 to n.",
            "**Swap:** If `nums[i] != 0`: swap `nums[idx]` and `nums[i]`, then `idx++`.",
            "**Edge Case:** If array is `[1]`, swap does nothing (correct). If `[0, 1]`, swap works correctly."
          ],
          "interviewQuestions": [
            {
              "question": "Can you minimize the total number of operations (writes)?",
              "answer": "**Snowball Approach:** \n*   Count zeros encountered so far. \n*   When you see a non-zero, swap it back by `zeroCount` positions. \n*   This avoids unnecessary swaps if the start of array is already non-zeros."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/move-zeroes/"
          ]
        },
        {
          "id": "max_consecutive_ones",
          "name": "Max Consecutive Ones",
          "estimatedHours": 0.5,
          "description": "Find the maximum streak of 1s in a binary array",
          "practiceQuestions": [
            {
              "name": "Max Consecutive Ones",
              "slug": "max-consecutive-ones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/max-consecutive-ones/"
            }
          ],
          "learningTip": [
            "**Reset logic:** Use a counter that resets to 0 whenever the condition breaks.",
            "**Maximize:** Always update max *before* resetting or at every step.",
            "**Sliding Window Precursor:** This is a degenerate sliding window where the window collapses on strict conditions."
          ],
          "mustNotMiss": [
            "**Code:** `cnt = 0, maxCnt = 0`. For `x` in `nums`.",
            "If `x == 1`, `cnt++`. Else `maxCnt = max(maxCnt, cnt)`, `cnt = 0`.",
            "**Final Check:** Return `max(maxCnt, cnt)` (don't forget the streak at the very end!)."
          ],
          "interviewQuestions": [
            {
              "question": "What if you can flip at most K zeros to 1s?",
              "answer": "**Sliding Window:** `(LeetCode 1004)` \n*   Expand right pointer. If 0, `zeros++`. \n*   While `zeros > K`, shrink left pointer. \n*   Result is `max(right - left + 1)`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/max-consecutive-ones/"
          ]
        },
        {
          "id": "single_number",
          "name": "Single Number",
          "estimatedHours": 0.5,
          "description": "Find the unique element in an array where all others are repeated",
          "practiceQuestions": [
            {
              "name": "Single Number",
              "slug": "single-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/single-number/"
            },
            {
              "name": "Majority Element",
              "slug": "majority-element",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/majority-element/"
            },
            {
              "name": "Majority Element II",
              "slug": "majority-element-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/majority-element-ii/"
            }
          ],
          "learningTip": [
            "**XOR Magic:** `a ^ a = 0` and `a ^ 0 = a`.",
            "**Associative:** Order doesn't matter. `a ^ b ^ a` is same as `a ^ a ^ b` -> `0 ^ b` -> `b`.",
            "**Bit Manipulation:** Is key for 'appearing once' problems."
          ],
          "mustNotMiss": [
            "**One-Liner:** `nums.reduce((acc, val) => acc ^ val, 0)`.",
            "**Limitations:** Only works if all others appear *even* times (typically 2).",
            "**Space:** O(1) - massive win over HashMap O(n)."
          ],
          "interviewQuestions": [
            {
              "question": "What if every element appears 3 times except one?",
              "answer": "**Bit Counting:** \n*   Count bits at each position `0..31`. \n*   `sum % 3` gives the bit of the single number. \n*   Alternatively: `ones, twos` boolean logic (LeetCode 137)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/single-number/"
          ]
        }
      ]
    },
    {
      "id": "recursion_easy_medium",
      "name": "Recursion - Easy/Medium",
      "tier": 2,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "recursion_101",
          "name": "Recursion 101",
          "estimatedHours": 2.5,
          "description": "Understand the basics of recursion with clear explanations and examples",
          "practiceQuestions": [
            {
              "name": "Fibonacci Number",
              "slug": "fibonacci-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fibonacci-number/"
            }
          ],
          "learningTip": [
            "**Definition:** A function that solves a problem by solving smaller instances of the *same* problem.",
            "**Key Components:** Base Case (Stop condition) and Recursive Step (Reduction).",
            "**Memory:** Uses the Call Stack. Each call adds a new frame (O(depth) space).",
            "**Trust:** Don't trace every step. Trust the recursive call `fn(n-1)` works, and use it to solve `fn(n)`."
          ],
          "mustNotMiss": [
            "**Base Case:** `if (n === 0) return ...`. Missing this = Stack Overflow.",
            "**Progress:** Arguments must change to approach base case.",
            "**Stack Limit:** JS stack limit is ~10k calls. Deep recursion throws `RangeError`.",
            "**Tail Call Optimization (TCO):** Modern JS engines (V8) might not optimize it, but concept is key."
          ],
          "interviewQuestions": [
            {
              "question": "What is Stack Overflow in recursion?",
              "answer": "**Stack Overflow** occurs when the recursion depth exceeds the call stack limit. \n*   **Causes:** Missing base case, step too small, or input too large (e.g., `recursion(10^6)`). \n*   **Fix:** Use Iteration or Trampoline pattern."
            },
            {
              "question": "Difference between Direct and Indirect Recursion?",
              "answer": "**Direct:** A calls A. \n**Indirect:** A calls B, B calls A. \n*   Indirect is harder to debug and detect cycles."
            }
          ],
          "resources": [
            "https://javascript.info/recursion",
            "https://www.freecodecamp.org/news/understanding-recursion-in-programming/"
          ]
        },
        {
          "id": "sum_first_n_numbers",
          "name": "Sum of first n numbers",
          "estimatedHours": 1,
          "description": "Calculate the sum of the first n natural numbers using recursion",
          "learningTip": [
            "**Formula vs Recursion:** Formula `n*(n+1)/2` is O(1). Recursion is O(n). Understand the trade-off.",
            "**State:** The 'state' is just the number `n` changing in each call.",
            "**Stack Trace:** Visualize the push (`sum(5)`) and pop (`5 + sum(4)`) phases."
          ],
          "mustNotMiss": [
            "**Base Case:** `if (n === 0) return 0;` (Crucial!).",
            "**Recursive Step:** `return n + sum(n-1);`.",
            "**Tail Recursion:** JS engines typically don't optimize it, but good concept to know.",
            "**Complexity:** Time O(n), Space O(n) (Call Stack)."
          ],
          "interviewQuestions": [
            {
              "question": "Can you optimize the space complexity of this recursive sum?",
              "answer": "**Tail Recursion:** `sum(n, acc = 0)`. \n*   If the engine supports TCO, it reuses the stack frame -> O(1) space. \n*   **Best:** Use the mathematical formula `n(n+1)/2` -> O(1) Time & Space."
            }
          ],
          "resources": [
            "https://2ality.com/2015/06/tail-call-optimization.html"
          ]
        },
        {
          "id": "sum_array_numbers",
          "name": "Sum of all numbers in Array",
          "estimatedHours": 1,
          "description": "Find the sum of all elements in an array using simple logic",
          "learningTip": [
            "**Divide & Conquer Strategy:** Sum of array = `first_element + sum(rest_of_array)`.",
            "**Pointer / Index:** Pass an index `i` to traverse virtually without slicing (slicing is O(n)).",
            "**Visualizing:** Array `[1, 2, 3]` -> `1 + sum([2,3])` -> `1 + 2 + sum([3])`."
          ],
          "mustNotMiss": [
            "**Don't Slice:** `arr.slice(1)` creates a copy (O(n)). Passing `index` is O(1).",
            "**Base Case:** `if (index === arr.length) return 0;`.",
            "**Recursive Step:** `return arr[index] + sumArray(arr, index + 1);`.",
            "**Optimization:** Iterative loop is O(1) space. Recursion is O(n) space."
          ],
          "interviewQuestions": [
            {
              "question": "Why is `arr.slice(1)` bad in recursion?",
              "answer": "**Quadratic Time:** `slice(1)` copies `n-1` elements. \n*   Doing this `n` times results in `(n-1) + (n-2) + ...` -> **O(n²)** Complexity. \n*   Always pass index for O(n)."
            }
          ],
          "resources": [
            "https://stackoverflow.com/questions/32699994/time-complexity-of-javascript-slice-method"
          ]
        },
        {
          "id": "factorial_n",
          "name": "Factorial of n",
          "estimatedHours": 0.5,
          "description": "Learn how to calculate factorials using recursion",
          "learningTip": [
            "**Definition:** `n! = n * (n-1)!`.",
            "**Growth:** Factorials grow insanely fast. `13!` overflows 32-bit int. `22!` overflows 64-bit int.",
            "**BigInt:** In JS, use `BigInt` for factorials > 21."
          ],
          "mustNotMiss": [
            "**Base Case:** `if (n === 0 || n === 1) return 1;`.",
            "**Application:** Used in Permutations/Combinations (nCr, nPr).",
            "**Interview Q:** Count trailing zeros in n! (Tip: Count factors of 5).",
            "**Complexity:** Time O(n), Space O(n)."
          ],
          "interviewQuestions": [
            {
              "question": "How many trailing zeros are in 100! ?",
              "answer": "**Count factors of 5:** \n*   Pairs of (2,5) make 10. 2s are abundant, so count 5s. \n*   Process: `floor(100/5) + floor(100/25) = 20 + 4 = 24`. \n*   Do NOT compute 100!."
            }
          ],
          "resources": [
            "https://brilliant.org/wiki/trailing-number-of-zeros/"
          ]
        },
        {
          "id": "power_of_two",
          "name": "Power of Two",
          "estimatedHours": 0.5,
          "description": "Solve Power of Two problem with recursion and logic",
          "practiceQuestions": [
            {
              "name": "Power of Two",
              "slug": "power-of-two",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/power-of-two/"
            }
          ],
          "learningTip": [
            "**Recursion:** `isPowerOfTwo(n/2)`. Base case `n==1`. O(log n).",
            "**Math:** `log2(n)` is an integer. Beware of float precision issues.",
            "**Bitwise:** `(n & (n-1)) == 0`. The gold standard."
          ],
          "mustNotMiss": [
            "**Base Cases:** `if (n <= 0) return false`, `if (n == 1) return true`.",
            "**Recursive:** `if (n % 2 !== 0) return false; return isPowerOfTwo(n/2);`",
            "**Bit Trick:** `return n > 0 && (n & (n-1)) === 0;` (O(1))."
          ],
          "interviewQuestions": [
            {
              "question": "Why does `n & (n-1)` check for power of 2?",
              "answer": "**Binary Representation:** \n*   Power of 2: `100...0` (One 1, rest 0s). \n*   n-1: `011...1` (Flips that 1 to 0, sets all lower bits to 1). \n*   **AND**: `1000 & 0111 = 0000`. Any other number shares bits with n-1."
            }
          ],
          "resources": [
            "https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2"
          ]
        },
        {
          "id": "recursion_masterclass",
          "name": "Recursion Masterclass",
          "estimatedHours": 2,
          "description": "Master recursion with deep insights, patterns, and examples",
          "learningTip": [
            "**Trust the Process:** Don't try to hold the entire tree in your head.",
            "**Template:** 1. Base Case. 2. Work (optional). 3. Recursive Call. 4. Work (optional).",
            "**Space:** Always mention Stack Space. It's hidden but real."
          ],
          "mustNotMiss": [
            "**Tree Traversal:** Pre (Root-L-R), In (L-Root-R), Post (L-R-Root).",
            "**Backtracking:** Recursion + Undo Step. (e.g., Maze solving).",
            "**Memoization:** Caching results of recursive steps (DP Top-Down)."
          ],
          "interviewQuestions": [
            {
              "question": "When should you NOT use recursion?",
              "answer": "**1. Strict Memory Limits:** Embedded systems with small stacks. \n**2. Critical Performance:** Function call overhead + lack of locality. \n**3. Risk of deep inputs:** `10^5` input depth will crash (Stack Overflow)."
            }
          ],
          "resources": [
            "https://frontendmasters.com/courses/computer-science-v2/recursion/"
          ]
        }
      ]
    },
    {
      "id": "searching_sorting_easy_medium",
      "name": "Searching & Sorting - Easy/Medium",
      "tier": 2,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "linear_search",
          "name": "Linear Search",
          "estimatedHours": 0.5,
          "description": "Find an element in an array using linear search",
          "learningTip": [
            "**Sorting vs Searching:** sorting is O(n log n). Searching is O(log n) if sorted, O(n) if not.",
            "**Brute Force:** In interviews, O(n²) is often the starting point. Optimize using Sorting (O(n log n)) or Hashing (O(n)).",
            "**Sentinel Search:** Optimization where you put the target at the end of the array to avoid boundary checks inside the loop."
          ],
          "mustNotMiss": [
            "**Stability:** Does the sort preserve order of equal elements? (Merge Sort: Yes, Quick Sort: No).",
            "**Divide and Conquer:** The principle behind Merge and Quick sort.",
            "**Custom Comparators:** Know how to sort objects/arrays based on specific fields."
          ],
          "interviewQuestions": [
            {
              "question": "When is Linear Search preferred over Binary Search?",
              "answer": "**1. Unsorted Data:** If you only search once, O(N) is better than O(N log N) sorting + O(log N) search. \n**2. Small Data:** For N < 10, linear search might be faster due to CPU caching/branch prediction. \n**3. Linked Lists:** Random access is O(N), so BS is effectively O(N) anyway."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/linear-search/"
          ]
        },
        {
          "id": "binary_search",
          "name": "Binary Search",
          "estimatedHours": 1,
          "description": "Find an element in a sorted array using binary search",
          "practiceQuestions": [
            {
              "name": "Binary Search",
              "slug": "binary-search",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-search/"
            },
            {
              "name": "Search Insert Position",
              "slug": "search-insert-position",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/search-insert-position/"
            }
          ],
          "learningTip": [
            "**The Pattern:** Apply BS whenever the search space is *monotonic* (sorted array, or a function that switches from F to T).",
            "**Templates:** There are 2-3 templates (left<=right, left<right). Stick to ONE to avoid off-by-one errors.",
            "**Complexity:** O(log n) is extremely fast. log2(10^5) ≈ 17 ops."
          ],
          "mustNotMiss": [
            "**Overflow Bug:** `mid = (left + right) / 2` overflows for large ints. Use `mid = left + (right - left) / 2`.",
            "**Loop Condition:** `while(left <= right)` is standard. Use `<` only if you finish with `return left`.",
            "**Update Logic:** `left = mid + 1`, `right = mid - 1`. If you don't +1/-1, you get infinite loops."
          ],
          "interviewQuestions": [
            {
              "question": "Implement `lower_bound` efficiently with Binary Search.",
              "answer": "**Lower Bound:** First index where `arr[i] >= target`. \n*   If `arr[mid] >= target`, search left (`right = mid - 1`, store `ans = mid`). \n*   Else search right (`left = mid + 1`). \n*   C++ `std::lower_bound` does exactly this."
            }
          ],
          "resources": [
            "https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems"
          ]
        },
        {
          "id": "bubble_sort",
          "name": "Bubble Sort",
          "estimatedHours": 2,
          "description": "Sort an array using the bubble sort algorithm",
          "learningTip": [
            "**Mechanics:** Repeatedly swap adjacent elements if in wrong order. Largest element 'bubbles' to end after each pass.",
            "**Optimization:** If no swaps happen in a pass, the array is already sorted. Break early.",
            "**Status:** Rarely used in production, but key for 'Inversions Count' concept."
          ],
          "mustNotMiss": [
            "**Time:** O(n²) worst/average, O(n) best with 'swapped' flag optimization.",
            "**Stability:** Stable (we don't swap if equal).",
            "**Space:** O(1) in-place.",
            "**Code:** `for i=0 to n; for j=0 to n-i-1; if(arr[j]>arr[j+1]) swap`."
          ],
          "interviewQuestions": [
            {
              "question": "Is Bubble Sort adaptive? Why?",
              "answer": "**Yes**, if optimized. \n*   By adding a boolean `swapped` flag, it terminates in O(N) if input is already sorted. \n*   Standard implementation is not adaptive (O(N²) always)."
            }
          ],
          "resources": [
            "https://visualgo.net/en/sorting"
          ]
        },
        {
          "id": "selection_sort",
          "name": "Selection Sort",
          "estimatedHours": 0.5,
          "description": "Sort an array using the selection sort algorithm",
          "learningTip": [
            "**Mechanics:** Find minimum in unsorted portion, swap to front. Repeat.",
            "**Writes:** It performs exactly `O(N)` swaps (writes). Bubble sort can do `O(N²)`. This matters if writing to memory is expensive (Flash/EEPROM).",
            "**Pattern:** Divide array into `[Sorted | Unsorted]`."
          ],
          "mustNotMiss": [
            "**Time:** O(n²) always - no best case improvement even if sorted.",
            "**Stability:** **NOT Stable**. Swapping long-distance can throw a duplicate element past its twin.",
            "**Space:** O(1) in-place."
          ],
          "interviewQuestions": [
            {
              "question": "Why is Selection Sort unstable? Give an example.",
              "answer": "**Example:** `[5a, 5b, 1]`. \n*   First pass min is `1`. Swap `5a` with `1`. \n*   Result: `[1, 5b, 5a]`. \n*   Order of 5s is reversed! Hence unstable."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/selection-sort/"
          ]
        },
        {
          "id": "insertion_sort",
          "name": "Insertion Sort",
          "estimatedHours": 1,
          "description": "Sort an array using the insertion sort algorithm",
          "learningTip": [
            "**Analogy:** Sorting playing cards in your hand. Pick one, insert it into correct spot among previous cards.",
            "**Best Use:** Extremely fast for small arrays (N < 50) or nearly sorted data. Used in library sorts (Timsort/Introsort) as the base case.",
            "**Adaptive:** Yes, runs in O(N) for sorted data."
          ],
          "mustNotMiss": [
            "**Time:** O(n²) worst, O(n) best (nearly sorted).",
            "**Stability:** Stable.",
            "**Online:** Can sort a stream of data as it arrives one by one.",
            "**Code:** `curr = arr[i]; j = i-1; while(j>=0 && arr[j]>curr) arr[j+1]=arr[j]; arr[j+1]=curr`."
          ],
          "interviewQuestions": [
            {
              "question": "Why is Insertion Sort used in Timsort?",
              "answer": "**Hybrid Sort:** \n*   Merge/Quick sort have overhead (recursion/stack). \n*   For small chunks (Run size 32-64), Insertion Sort is faster due to data locality and simplicity. \n*   Timsort switches to Insertion Sort for small subarrays."
            }
          ],
          "resources": [
            "https://hackernoon.com/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b13875f460"
          ]
        },
        {
          "id": "merge_sort",
          "name": "Merge Sort",
          "estimatedHours": 3,
          "description": "Learn how Merge Sort works using recursion and divide & conquer",
          "learningTip": [
            "**Concept:** Divide & Conquer. Split list in half recursively until size 1. Merge sorted halves.",
            "**Stability:** It IS stable (doesn't reorder equal elements), making it great for objects.",
            "**Drawback:** Not in-place. Requires O(n) extra space."
          ],
          "mustNotMiss": [
            "**Recursive Trust:** Assume `mergeSort(left)` and `mergeSort(right)` just work.",
            "**The Merge Step:** The heart of the algorithm. Two pointers, one pass. O(n).",
            "**Complexity:** O(n log n) worst-case. Better than Quicksort for Linked Lists (no random access needed)."
          ],
          "interviewQuestions": [
            {
              "question": "Can Merge Sort be made In-Place (O(1) space)?",
              "answer": "**Yes, but complex.** \n*   Standard Merge Sort is O(N) space. \n*   'Block Merge Sort' variations exist but are slower and incredibly complex to implement. \n*   In interviews, say **No** (unless specifically asked for advanced variations)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/merge-sort/"
          ]
        }
      ]
    },
    {
      "id": "pattern_merge_intervals",
      "name": "Pattern: Merge Intervals",
      "tier": 2,
      "estimatedHours": 8.5,
      "topics": [
        {
          "id": "merge_intervals",
          "name": "Merge Intervals",
          "estimatedHours": 2,
          "description": "Merge all overlapping intervals",
          "practiceQuestions": [
            {
              "name": "Meeting Rooms",
              "slug": "meeting-rooms",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/meeting-rooms/"
            },
            {
              "name": "Merge Intervals",
              "slug": "merge-intervals",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/merge-intervals/"
            },
            {
              "name": "Meeting Rooms II",
              "slug": "meeting-rooms-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/meeting-rooms-ii/"
            }
          ],
          "learningTip": [
            "**Sort:** Necessary to sort by start time (O(N log N)).",
            "**Track:** Keep `last` merged interval. If `curr.start <= last.end`, merge them (`last.end = max(last.end, curr.end)`).",
            "**Push:** Else, push `curr` as a new interval."
          ],
          "mustNotMiss": [
            "**Loop:** Iterate through sorted intervals.",
            "**Update:** Ensure you update the interval inside your result array."
          ]
        },
        {
          "id": "insert_interval",
          "name": "Insert Interval",
          "estimatedHours": 2,
          "description": "Insert a new interval into a sorted list of non-overlapping intervals",
          "practiceQuestions": [
            {
              "name": "Insert Interval",
              "slug": "insert-interval",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/insert-interval/"
            }
          ],
          "learningTip": [
            "**Pattern:** Three stages: 1. Add effectively 'left' intervals. 2. Merge overlapping intervals. 3. Add 'right' intervals.",
            "**Loop:** `while (i < n && intervals[i].end < newInterval.start) result.push(intervals[i++])`."
          ],
          "mustNotMiss": [
            "**Merge:** `newInterval.start = min(...)`, `newInterval.end = max(...)`."
          ]
        },
        {
          "id": "interval_list_intersections",
          "name": "Interval List Intersections",
          "estimatedHours": 2,
          "description": "Find the intersection of two lists of closed intervals",
          "practiceQuestions": [
            {
              "name": "Interval List Intersections",
              "slug": "interval-list-intersections",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/interval-list-intersections/"
            }
          ],
          "learningTip": [
            "**Two Pointers:** `i` for list A, `j` for list B.",
            "**Overlap:** `start = max(A[i].start, B[j].start)`, `end = min(A[i].end, B[j].end)`.",
            "**Valid:** If `start <= end`, add `[start, end]` to result.",
            "**Advance:** Increment pointer of the interval that ends first."
          ],
          "mustNotMiss": [
            "**Why advance end?** The interval ending first cannot possibly overlap with any *subsequent* interval from the other list."
          ]
        },
        {
          "id": "employee_free_time",
          "name": "Employee Free Time",
          "estimatedHours": 2.5,
          "description": "Find common free time for all employees",
          "practiceQuestions": [
            {
              "name": "Employee Free Time",
              "slug": "employee-free-time",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/employee-free-time/"
            },
            {
              "name": "Minimum Interval to Include Each Query",
              "slug": "minimum-interval-to-include-each-query",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimum-interval-to-include-each-query/"
            }
          ],
          "learningTip": [
            "**Flatten:** Merge all employees' intervals into one big list.",
            "**Sort & Merge:** Sort by start time. Merge overlapping intervals.",
            "**Gaps:** The 'free time' is simply the gap between merged intervals."
          ],
          "mustNotMiss": [
            "**Heap Alternative:** Can use Min-Heap to sort/process if N is very large."
          ]
        }
      ]
    },
    {
      "id": "pattern_cyclic_sort",
      "name": "Pattern: Cyclic Sort",
      "tier": 2,
      "estimatedHours": 5,
      "topics": [
        {
          "id": "cyclic_sort",
          "name": "Cyclic Sort",
          "estimatedHours": 1,
          "description": "Sort an array of numbers from 1 to N in O(N) time",
          "practiceQuestions": [],
          "learningTip": [
            "**Condition:** Numbers usually in range `1` to `N` (or `0` to `N`).",
            "**Action:** If `nums[i] != i + 1`, swap `nums[i]` with `nums[nums[i] - 1]`.",
            "**Complexity:** O(N) because each number is swapped at most once to its correct position."
          ],
          "mustNotMiss": [
            "**Loop:** `while` loop, only increment `i` if `nums[i]` is in correct spot."
          ]
        },
        {
          "id": "find_missing_number",
          "name": "Find the Missing Number",
          "estimatedHours": 0.5,
          "description": "Find the missing number in range 0 to N",
          "practiceQuestions": [
            {
              "name": "Missing Number",
              "slug": "missing-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/missing-number/"
            }
          ],
          "learningTip": [
            "**Cyclic Sort Approach:** Place `i` at index `i` (since range is 0 to N).",
            "**Ignore:** If `nums[i] >= N`, ignore it (since valid indices are 0 to N-1).",
            "**Scan:** First index `i` where `nums[i] != i` is the answer."
          ],
          "mustNotMiss": [
            "**XOR Alternative:** `res ^= i ^ nums[i]` is faster (O(N) vs O(N) but constant factors)."
          ]
        },
        {
          "id": "find_all_duplicates",
          "name": "Find All Duplicates in an Array",
          "estimatedHours": 1.5,
          "description": "Find all duplicates in an array of integers 1 to N",
          "practiceQuestions": [
            {
              "name": "Find All Duplicates in an Array",
              "slug": "find-all-duplicates-in-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-all-duplicates-in-an-array/"
            },
            {
              "name": "Find the Duplicate Number",
              "slug": "find-the-duplicate-number",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-the-duplicate-number/"
            }
          ],
          "learningTip": [
            "**Cyclic Sort:** Try to put `nums[i]` at `nums[i]-1`.",
            "**Check:** If `nums[i]` is not at correct spot but `nums[nums[i]-1]` IS, then `nums[i]` is a duplicate."
          ],
          "mustNotMiss": [
            "**Negative Marking:** Alternative O(N) approach invalidates the input array by marking visited indices negative."
          ]
        },
        {
          "id": "first_missing_positive",
          "name": "First Missing Positive",
          "estimatedHours": 2,
          "description": "Find the smallest missing positive integer",
          "practiceQuestions": [
            {
              "name": "First Missing Positive",
              "slug": "first-missing-positive",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/first-missing-positive/"
            }
          ],
          "learningTip": [
            "**Range:** Answer must be between `1` and `N+1`.",
            "**Cyclic Sort:** Ignore non-positives and numbers > N. Put positive `x` at `x-1`.",
            "**Scan:** First index `i` where `nums[i] != i+1` implies `i+1` is missing."
          ],
          "mustNotMiss": [
            "**Ignore:** Negative numbers and numbers larger than array size do not affect the first missing positive (unless the array is full of them)."
          ]
        }
      ]
    },
    {
      "id": "linked_list_easy_medium",
      "name": "Linked List - Easy/Medium",
      "tier": 2,
      "estimatedHours": 11.5,
      "topics": [
        {
          "id": "introduction_linked_list",
          "name": "Introduction to Linked List",
          "estimatedHours": 1,
          "description": "Get started with the basics of Linked Lists",
          "learningTip": [
            "**Memory Layout:** Unlike Arrays, LL nodes are *scattered* in memory. Connected only by pointers.",
            "**Trade-off:** Fast Insert/Delete O(1) (if at head), but Slow Access O(n) (no index access).",
            "**Mental Model:** A chain of people holding hands. To find person #10, you must ask #1, then #2..."
          ],
          "mustNotMiss": [
            "**Node Structure:** `val` (data) and `next` (pointer/reference).",
            "**Null/None:** The end of the list. Always check `if (curr === null)`.",
            "**Head:** The only entry point. Lose the head, lose the list."
          ],
          "interviewQuestions": [
            {
              "question": "Array vs Linked List: When to use which?",
              "answer": "**Array:** fast random access (O(1)), cache friendly. Slow insertion/deletion (O(n)). \n**Linked List:** fast insertion/deletion (O(1)), dynamic size. Slow access (O(n)), extra memory for pointers."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/linked-list/"
          ]
        },
        {
          "id": "design_linked_list",
          "name": "Design Linked List",
          "estimatedHours": 0.5,
          "description": "Learn how to design and implement your own Linked List",
          "learningTip": [
            "**Class Design:** `class Node { val, next }` and `class LinkedList { head, size }`.",
            "**Edge Cases:** Empty list? List with 1 node? Adding to index > size?",
            "**Sentinel Nodes:** Using a 'dummy' head and tail can simplify logic massively (fewer null checks)."
          ],
          "mustNotMiss": [
            "**Constructor:** Initialize `head = null`, `size = 0`.",
            "**addAtHead:** O(1). `newNode.next = head; head = newNode;`",
            "**addAtTail:** O(n) unless you keep a `tail` pointer (then O(1))."
          ],
          "interviewQuestions": [
            {
              "question": "What is a Sentinel Node (Dummy Node)?",
              "answer": "**Dummy Node:** A node `0` placed before `head`. \n*   Eliminates edge cases for operations at head (insert/delete). \n*   Common pattern: `dummy.next = head; return dummy.next`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/design-linked-list/"
          ]
        },
        {
          "id": "adding_nodes_linked_list",
          "name": "Adding Nodes to Linked List",
          "estimatedHours": 2,
          "description": "Learn to insert nodes into a Linked List at various positions",
          "learningTip": [
            "**Sequence Matters:** Connect the NEW node to the list *before* breaking the existing link.",
            "**Formula:** `newNode.next = current.next; current.next = newNode;`",
            "**Visualization:** Draw it! If you swap the steps, you lose the rest of the list."
          ],
          "mustNotMiss": [
            "**Insert Middle:** Requires traversal to index `i-1`. O(n).",
            "**Insert End:** Requires traversal to `null`. O(n).",
            "**Common Bug:** Updating `current` instead of `current.next`."
          ],
          "interviewQuestions": [
            {
              "question": "How to insert a node in O(1) if you have a pointer to the previous node?",
              "answer": "**Direct Link:** `newNode.next = prev.next; prev.next = newNode;`. \n*   This is why Dubly Linked Lists (DLL) are powerful - if you have the node, you also have `prev` (via `node.prev`)."
            }
          ],
          "resources": [
            "https://visualgo.net/en/list"
          ]
        },
        {
          "id": "deleting_nodes_linked_list",
          "name": "Deleting Nodes in Linked List",
          "estimatedHours": 0.5,
          "description": "Understand node deletion in a Linked List",
          "learningTip": [
            "**Logic:** To delete node B (A->B->C), you need access to A. `A.next = A.next.next`.",
            "**Dummy Head:** Essential for deleting the *head* node without writing a special `if/else`.",
            "**Cleanup:** In C++, you'd free B. In JS, GC handles it if no references remain."
          ],
          "mustNotMiss": [
            "**Traversal:** Stop at the node *before* the target.",
            "**Null Check:** Ensure `prev.next` exists before accessing `prev.next.next`.",
            "**Edge Case:** Deleting last node. `prev.next = null`."
          ],
          "interviewQuestions": [
            {
              "question": "Can you delete a node given ONLY the node itself (no head or prev)?",
              "answer": "**Copy Data Trick:** `node.val = node.next.val; node.next = node.next.next;` \n*   **Limitation:** Fails if the node is the LAST node (cannot copy from null)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/delete-node-in-a-linked-list/"
          ]
        },
        {
          "id": "intersection_two_linked_lists",
          "name": "Intersection of two Linked Lists",
          "estimatedHours": 0.5,
          "description": "Find the intersection node of two Linked Lists",
          "practiceQuestions": [
            {
              "name": "Intersection of Two Linked Lists",
              "slug": "intersection-of-two-linked-lists",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
            }
          ],
          "learningTip": [
            "**Logic:** Two lists merging to a 'Y' shape. Any node after intersection is shared.",
            "**Length Difference:** If List A is len 10 and B is len 8, the intersection must be in the last 8 nodes. Skip first 2 of A.",
            "**Elegant Trick:** `ptrA` traverses A then B. `ptrB` traverses B then A. They travel same distance."
          ],
          "mustNotMiss": [
            "**Visual:** `A + B` has same length as `B + A`.",
            "**Code:** `pA = headA, pB = headB`. `while pA != pB`: `pA = pA ? pA.next : headB`, `pB = pB ? pB.next : headA`. Return `pA`.",
            "**No Intersection:** They both reach `null` simultaneously at the end."
          ],
          "interviewQuestions": [
            {
              "question": "Why does the switching heads trick work?",
              "answer": "**Equation:** \n*   A = `preA + shared` \n*   B = `preB + shared` \n*   `A + B` = `preA + shared + preB + shared` \n*   `B + A` = `preB + shared + preA + shared` \n*   Pointers align exactly at start of `shared`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!"
          ]
        },
        {
          "id": "remove_linked_list_elements",
          "name": "Remove Linked List Elements",
          "estimatedHours": 0.5,
          "description": "Remove nodes with a specific value from a Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Linked List Elements",
              "slug": "remove-linked-list-elements",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-linked-list-elements/"
            }
          ],
          "learningTip": [
            "**Dummy Node:** Solves the issue where HEAD itself needs removal.",
            "**Traversal:** `current` checks `current.next.val`. If match, skip: `curr.next = curr.next.next`. Else `curr = curr.next`.",
            "**GC:** In JS/Java, just unlinking handles cleanup."
          ],
          "mustNotMiss": [
            "**Setup:** `dummy = new Node(0, head)`, `curr = dummy`.",
            "**Loop:** `while(curr.next)`.",
            "**Check:** `if(curr.next.val == val)` -> SKIP.",
            "**Else:** -> NEXT."
          ],
          "interviewQuestions": [
            {
              "question": "Why do we check `curr.next.val` instead of `curr.val`?",
              "answer": "**Access to Prev:** \n*   To delete a node, we need to modify the *previous* node's `next` pointer. \n*   By standing at `curr` and looking at `curr.next`, `curr` acts as the 'previous' node for the target."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-linked-list-elements/"
          ]
        },
        {
          "id": "remove_nth_node_end_two_pass",
          "name": "Remove nth node from end of List - Two Pass",
          "estimatedHours": 0.5,
          "description": "Remove the nth node from the end using a two-pass method",
          "learningTip": [
            "**Concept:** We need to find Length `L`, then remove node at `L-n`.",
            "**Pass 1:** Traverse to find `L`. (O(N)).",
            "**Pass 2:** Traverse to `L-n-1` (node before target). Unlink. (O(N)).",
            "**Total:** 2N operations."
          ],
          "mustNotMiss": [
            "**Formula:** `target_index = Length - n`.",
            "**Edge Case:** Removing head (`target_index == 0`). Handle explicitly or use Dummy.",
            "**Comparison:** One-pass is preferred in interviews."
          ],
          "interviewQuestions": [
            {
              "question": "Is Two-Pass slower than One-Pass?",
              "answer": "**Technically yes, but same Big-O.** \n*   Both are O(N). Two-pass traverses 2N nodes. One-pass traverses N nodes. \n*   One-pass is 'cleaner' code."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
          ]
        },
        {
          "id": "remove_nth_node_end_one_pass",
          "name": "Remove nth Node from end - One Pass",
          "estimatedHours": 1,
          "description": "Remove the nth node from the end in one pass using two pointers",
          "practiceQuestions": [
            {
              "name": "Remove Nth Node From End of List",
              "slug": "remove-nth-node-from-end-of-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
            }
          ],
          "learningTip": [
            "**Gap Strategy:** Maintain two pointers `Slow` and `Fast` with a gap of `n` nodes.",
            "**Mechanics:** Move Fast `n` steps ahead. Then move both until Fast hits end. Slow is now at `L-n` (predecessor).",
            "**Usage:** Find Kth to last element, or Remove Kth to last."
          ],
          "mustNotMiss": [
            "**Step 1:** `fast` moves `n` steps.",
            "**Step 2:** `while (fast.next)` move `slow` and `fast`.",
            "**Step 3:** `slow.next = slow.next.next`.",
            "**Dummy:** Use dummy head to handle removing the 1st node (head) effortlessly."
          ],
          "interviewQuestions": [
            {
              "question": "What if n > length?",
              "answer": "**Invalid input.** \n*   Normally guaranteed valid by problem statement (LeetCode). \n*   In real world, `step 1` loop would throw null pointer/bounds error. Add check."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/"
          ]
        },
        {
          "id": "remove_duplicates_sorted_list",
          "name": "Remove Duplicates from Sorted List",
          "estimatedHours": 0.5,
          "description": "Remove consecutive duplicates from a sorted Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted List",
              "slug": "remove-duplicates-from-sorted-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
            }
          ],
          "learningTip": [
            "**Invariant:** List is sorted. Duplicates are adjacent.",
            "**Logic:** Compare `curr.val` with `curr.next.val`.",
            "**Cleanup:** In C++, you delete the skipped node. In JS, GC handles it."
          ],
          "mustNotMiss": [
            "**Loop:** `while (curr && curr.next)`.",
            "**Match:** `if (curr.val === curr.next.val) curr.next = curr.next.next`.",
            "**No Match:** `curr = curr.next`. (Only advance if values differ!)."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between this and Remove Duplicates II (LC 82)?",
              "answer": "**Distinct vs Unique:** \n*   This problem keeps *one* copy. LC 82 removes *all* nodes that have duplicates. \n*   LC 82 requires a `dummy` head and `prev` pointer because head might be removed."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
          ]
        },
        {
          "id": "odd_even_linked_list",
          "name": "Odd Even Linked List",
          "estimatedHours": 0.5,
          "description": "Rearrange nodes based on their position (odd/even index)",
          "practiceQuestions": [
            {
              "name": "Odd Even Linked List",
              "slug": "odd-even-linked-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/odd-even-linked-list/"
            },
            {
              "name": "Copy List with Random Pointer",
              "slug": "copy-list-with-random-pointer",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/copy-list-with-random-pointer/"
            }
          ],
          "learningTip": [
            "**Indices:** 1-based indices (Node 1, 3, 5 vs Node 2, 4, 6).",
            "**Split & Merge:** Build two lists (odd and even) in-place, then join them.",
            "**Even Head:** You must save reference to the start of even list to attach it later."
          ],
          "mustNotMiss": [
            "**Init:** `odd = head`, `even = head.next`, `evenHead = even`.",
            "**Loop:** `while(even && even.next)`.",
            "**Wiring:** `odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next`.",
            "**Join:** `odd.next = evenHead`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we solve this by swapping values?",
              "answer": "**Technically yes, but NO.** \n*   Swapping values is O(N) but discouraged in interviews. \n*   Structure manipulation is cleaner and safe for large objects."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/odd-even-linked-list/"
          ]
        },
        {
          "id": "add_two_numbers",
          "name": "Add Two Numbers",
          "estimatedHours": 1,
          "description": "Add two numbers represented as Linked Lists",
          "practiceQuestions": [
            {
              "name": "Add Two Numbers",
              "slug": "add-two-numbers",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/add-two-numbers/"
            }
          ],
          "learningTip": [
            "**Math:** Elementary math. Column addition with carry.",
            "**Edge Cases:** Lists of different lengths. One list null. Carry remaining at end.",
            "**Reverse Order:** Lists are already in reverse order (1 -> 2 means 21). This matches how we add (units first)."
          ],
          "mustNotMiss": [
            "**Loop:** `while (l1 || l2 || carry)`.",
            "**Sum:** `(l1?.val || 0) + (l2?.val || 0) + carry`.",
            "**Node:** `new Node(sum % 10)`.",
            "**Carry:** `Math.floor(sum / 10)`."
          ],
          "interviewQuestions": [
            {
              "question": "What if the digits were stored in forward order (1->2 means 12)?",
              "answer": "**Harder Variant (LC 445):** \n*   Access to least significant digit is last (at tail). \n*   **Solution:** Reverse inputs -> Add -> Reverse result. OR use Stacks."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/add-two-numbers/"
          ]
        },
        {
          "id": "merge_two_sorted_lists",
          "name": "Merge Two Sorted Lists",
          "estimatedHours": 1,
          "description": "Merge two sorted Linked Lists into one",
          "practiceQuestions": [
            {
              "name": "Merge Two Sorted Lists",
              "slug": "merge-two-sorted-lists",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-two-sorted-lists/"
            }
          ],
          "learningTip": [
            "**Zipper Logic:** Compare heads, pick smaller, move pointer. Repeat.",
            "**Dummy Head:** Crucial. Simplifies result construction (no special initialization logic).",
            "**Cleanup:** One list will finish first. Append the *entire* rest of the other list in O(1)."
          ],
          "mustNotMiss": [
            "**Recursive:** `fn(l1, l2)` -> returns smaller node pointing to `fn(rest, other)`.",
            "**Iterative:** `while(l1 && l2)`. If `l1 < l2` append l1. Else append l2.",
            "**Finish:** `curr.next = l1 || l2`."
          ],
          "interviewQuestions": [
            {
              "question": "How to merge K sorted lists?",
              "answer": "**Min-Heap (O(N log K)):** \n*   Put all K heads in Heap. \n*   Pop min, add to result, push `min.next` to Heap. \n*   (Merging 1 by 1 is O(N * K) - bad)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/merge-two-sorted-lists/"
          ]
        },
        {
          "id": "swap_nodes_pairs_iterative",
          "name": "Swap Nodes in Pairs - Iterative Approach",
          "estimatedHours": 1,
          "description": "Swap every two adjacent nodes in a Linked List iteratively",
          "practiceQuestions": [
            {
              "name": "Swap Nodes in Pairs",
              "slug": "swap-nodes-in-pairs",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/swap-nodes-in-pairs/"
            }
          ],
          "learningTip": [
            "**Visualization:** `A -> B -> C -> D` becomes `B -> A -> D -> C`.",
            "**Steps:** 1. Connect `prev` to `second`. 2. Connect `second` to `first`. 3. Connect `first` to `second.next`.",
            "**Pointers:** Need 3 pointers (dummy/prev, curr/first, next/second)."
          ],
          "mustNotMiss": [
            "**Loop:** `while(curr && curr.next)`.",
            "**Swap:** `first = curr; second = curr.next;`",
            "**Rewire:** `prev.next = second; first.next = second.next; second.next = first;`",
            "**Update:** `prev = first; curr = first.next;`"
          ],
          "interviewQuestions": [
            {
              "question": "Why use iterative over recursive?",
              "answer": "**Space Complexity:** \n*   Iterative is O(1) space. \n*   Recursive is O(N/2) stack space. \n*   Iterative is preferred for memory-constrained environments."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/swap-nodes-in-pairs/"
          ]
        },
        {
          "id": "swap_nodes_pairs_recursive",
          "name": "Swap Nodes in Pair - Recursive Approach",
          "estimatedHours": 1,
          "description": "Recursively swap every two adjacent nodes in a Linked List",
          "learningTip": [
            "**Concept:** 'Swap first two, then recursively swap the rest'.",
            "**Trust:** `swap(head.next.next)` will magically return the swapped rest of the list.",
            "**Wiring:** `second.next = head; head.next = swappedRest;`"
          ],
          "mustNotMiss": [
            "**Base Case:** `if (!head || !head.next) return head`.",
            "**Recurse:** `rest = swapPairs(second.next)`.",
            "**Rewire:** `second.next = head; head.next = rest`.",
            "**Return:** `second` (new head)."
          ],
          "interviewQuestions": [
            {
              "question": "How to debug infinite recursion in linked lists?",
              "answer": "**Cycle Check:** \n*   Often caused by circular references (e.g., A points to B, B points to A, and recursion keeps going). \n*   Draw the pointer updates carefully."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/swap-nodes-in-pairs/solution/"
          ]
        }
      ]
    },
    {
      "id": "pattern_fast_slow_pointers",
      "name": "Pattern: Fast & Slow Pointers",
      "tier": 2,
      "estimatedHours": 5.5,
      "topics": [
        {
          "id": "linked_list_cycle",
          "name": "Linked List Cycle",
          "estimatedHours": 1,
          "description": "Detect if a Linked List has a cycle using Floyd's Cycle-Finding Algorithm",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle",
              "slug": "linked-list-cycle",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/linked-list-cycle/"
            }
          ],
          "learningTip": [
            "**Floyd's Tortoise & Hare:** Use two pointers. `Slow` moves 1 step. `Fast` moves 2 steps.",
            "**Meeting:** If `slow === fast`, cycle detected.",
            "**Space:** O(1) compared to O(N) with Hash Table."
          ],
          "mustNotMiss": [
            "**Loop:** `while(fast && fast.next)`.",
            "**Check:** `if (slow === fast) return true`.",
            "**Return:** `false` if loop ends."
          ]
        },
        {
          "id": "linked_list_cycle_ii",
          "name": "Start of Linked List Cycle",
          "estimatedHours": 1.5,
          "description": "Find the node where the cycle begins",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle II",
              "slug": "linked-list-cycle-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/linked-list-cycle-ii/"
            }
          ],
          "learningTip": [
            "**Phase 1:** Detect cycle using Fast/Slow.",
            "**Phase 2:** Reset `slow` to head. Keep `fast` at meeting point.",
            "**Phase 3:** Move both 1 step at a time. They meet at start of cycle.",
            "**Proof:** Mathematical proof involves L + x = 2(L + x) mod C."
          ],
          "mustNotMiss": [
            "**Entry Check:** Ensure cycle exists first.",
            "**Sync:** Move `slow` and `fast` simultaneously until `slow === fast`."
          ]
        },
        {
          "id": "happy_number",
          "name": "Happy Number",
          "estimatedHours": 1,
          "description": "Determine if a number is 'happy' by repeatedly replacing it with sum of squares of digits",
          "practiceQuestions": [
            {
              "name": "Happy Number",
              "slug": "happy-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/happy-number/"
            }
          ],
          "learningTip": [
            "**Pattern:** This is an implicit Cycle Detection problem.",
            "**State:** The sequence of numbers forms a linked list structure.",
            "**Cycle:** If you reach a number you've seen before (that isn't 1), you're in a loop."
          ],
          "mustNotMiss": [
            "**Fast/Slow:** Use `slow = sumSquares(n)`, `fast = sumSquares(sumSquares(n))`.",
            "**Stop:** `while (fast != 1 && slow != fast)`."
          ]
        },
        {
          "id": "middle_of_linked_list",
          "name": "Middle of the Linked List",
          "estimatedHours": 0.5,
          "description": "Find the middle node of a linked list",
          "practiceQuestions": [
            {
              "name": "Middle of the Linked List",
              "slug": "middle-of-the-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/middle-of-the-linked-list/"
            },
            {
              "name": "Reorder List",
              "slug": "reorder-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reorder-list/"
            }
          ],
          "learningTip": [
            "**Pattern:** Fast and Slow pointers.",
            "**Logic:** Fast moves 2x speed. When Fast reaches end, Slow is at middle."
          ],
          "mustNotMiss": [
            "**Loop:** `while (fast && fast.next)`.",
            "**Return:** `slow`."
          ]
        },
        {
          "id": "palindrome_linked_list",
          "name": "Palindrome Linked List",
          "estimatedHours": 1.5,
          "description": "Check if a linked list is a palindrome O(1) space",
          "practiceQuestions": [
            {
              "name": "Palindrome Linked List",
              "slug": "palindrome-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-linked-list/"
            }
          ],
          "learningTip": [
            "**Combo:** Find Middle (Fast/Slow) + Reverse List (In-place) + Compare.",
            "**Steps:** 1. Get Middle. 2. Reverse second half. 3. Compare head and new second head."
          ],
          "mustNotMiss": [
            "**Restore:** Ideally, reverse the second half back to original state before returning."
          ]
        }
      ]
    },
    {
      "id": "pattern_in_place_reversal",
      "name": "Pattern: In-place Reversal of a LinkedList",
      "tier": 2,
      "estimatedHours": 5.5,
      "topics": [
        {
          "id": "reverse_linked_list",
          "name": "Reverse Linked List",
          "estimatedHours": 0.5,
          "description": "Reverse a singly linked list",
          "practiceQuestions": [
            {
              "name": "Reverse Linked List",
              "slug": "reverse-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-linked-list/"
            }
          ],
          "learningTip": [
            "**Iterative:** 3 pointers: `prev`, `curr`, `next`.",
            "**Logic:** Save `next`. Point `curr.next` to `prev`. Move `prev` to `curr`. Move `curr` to `next`."
          ],
          "mustNotMiss": [
            "**Return:** `prev` becomes the new head."
          ]
        },
        {
          "id": "reverse_linked_list_ii",
          "name": "Reverse Linked List II",
          "estimatedHours": 1.5,
          "description": "Reverse a linked list from position left to right",
          "practiceQuestions": [
            {
              "name": "Reverse Linked List II",
              "slug": "reverse-linked-list-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-linked-list-ii/"
            }
          ],
          "learningTip": [
            "**Focus:** We only reverse a *sub-list*.",
            "**Pointers:** Need to track node *before* the sub-list (`prevLeft`) and node *after* (`afterRight`).",
            "**Connection:** `prevLeft.next` should point to new head of sub-list. Original head of sub-list should point to `afterRight`."
          ],
          "mustNotMiss": [
            "**Dummy:** Essential because `left` could be 1 (head changes)."
          ]
        },
        {
          "id": "rotate_list",
          "name": "Rotate List",
          "estimatedHours": 1,
          "description": "Rotate the list to the right by k places",
          "practiceQuestions": [
            {
              "name": "Rotate List",
              "slug": "rotate-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-list/"
            }
          ],
          "learningTip": [
            "**Cycle:** Connect tail to head to make a ring.",
            "**Cut:** Calculate new tail position `len - (k % len)`. Break the ring there."
          ],
          "mustNotMiss": [
            "**Modulo:** `k` can be larger than length."
          ]
        },
        {
          "id": "reverse_nodes_k_group",
          "name": "Reverse Nodes in k-Group",
          "estimatedHours": 2.5,
          "description": "Reverse nodes of a linked list k at a time",
          "practiceQuestions": [
            {
              "name": "Reverse Nodes in k-Group",
              "slug": "reverse-nodes-in-k-group",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/reverse-nodes-in-k-group/"
            }
          ],
          "learningTip": [
            "**Recursive/Iterative:** Reverse first `k` nodes. Recursively call for the rest.",
            "**Check:** If less than `k` nodes remain, leave them as is."
          ],
          "mustNotMiss": [
            "**Hard:** Managing connections between groups is the tricky part."
          ]
        }
      ]
    },
    {
      "id": "strings_easy_medium",
      "name": "Strings - Easy/Medium",
      "tier": 2,
      "estimatedHours": 13.5,
      "topics": [
        {
          "id": "length_last_word_two_loops",
          "name": "Length of Last Word - Approach 1 - Two Loops",
          "estimatedHours": 1,
          "description": "Find the length of the last word using a basic loop approach",
          "learningTip": [
            "**Classic Traversal:** Iterate from end. Skip trailing spaces. Count characters until next space or start of string.",
            "**JS One-Liner:** `s.trim().split(' ').pop().length`. (Good for quick implementations, bad for interview explanation).",
            "**Edge Cases:** Empty string, string with only spaces, single word."
          ],
          "mustNotMiss": [
            "**Step 1:** `i = s.length - 1`.",
            "**Step 2:** `while(i >= 0 && s[i] == ' ') i--` (Skip trailing).",
            "**Step 3:** `len = 0`; `while(i >= 0 && s[i] != ' ') { len++; i-- }`.",
            "**Key:** Don't split the entire string if you don't have to (O(N) space vs O(1) space)."
          ],
          "interviewQuestions": [
            {
              "question": "Why avoid `split()` in interviews for this?",
              "answer": "**Space Complexity:** \n*   `split()` creates an array of all words, consuming O(N) memory. \n*   Iterating from the end uses O(1) memory."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/length-of-last-word/"
          ]
        },
        {
          "id": "length_last_word_one_loop",
          "name": "Length of Last Word - Approach 2 - One Loop",
          "estimatedHours": 1,
          "description": "Optimized one-pass solution to find the last word's length",
          "practiceQuestions": [
            {
              "name": "Length of Last Word",
              "slug": "length-of-last-word",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/length-of-last-word/"
            }
          ],
          "learningTip": [
            "**Optimized:** Single pass from the end. Combine skipping spaces and counting word.",
            "**State Machine:** State 1: Skipping Spaces. State 2: Counting Word. State 3: Done.",
            "**Complexity:** O(N) Time, O(1) Space."
          ],
          "mustNotMiss": [
            "**Code:** `while (i >= 0)`. If `char != ' '` count++. Else if `count > 0` break. Else `i--`.",
            "**Logic:** We only break on a space IF we have already started counting a word.",
            "**Return:** count."
          ],
          "interviewQuestions": [
            {
              "question": "What if the string is mutable?",
              "answer": "**In C++:** You can modify strings in place. \n*   In Java/JS strings are immutable, so standard approach is read-only traversal."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/length-of-last-word/"
          ]
        },
        {
          "id": "find_words_containing_character",
          "name": "Find Words Containing Character",
          "estimatedHours": 0.5,
          "description": "Find words from a list that contain a specific character",
          "practiceQuestions": [
            {
              "name": "Find Words Containing Character",
              "slug": "find-words-containing-character",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-words-containing-character/"
            }
          ],
          "learningTip": [
            "**Filter:** High-order functions `filter` + `includes` make this trivial in modern languages.",
            "**Performance:** `str.includes(char)` is O(K). Total O(N*K).",
            "**Pattern:** Simple array methods practice."
          ],
          "mustNotMiss": [
            "**Code:** `words.map((w,i) => w.indexOf(x) != -1 ? i : -1).filter(i => i != -1)`.",
            "**Constraint:** Input size usually small, so naive approach passes.",
            "**Manual:** Nested loop solution is also acceptable."
          ],
          "interviewQuestions": [
            {
              "question": "How to optimize for very long strings?",
              "answer": "**KMP Algorithm:** \n*   If strings are massive, standard search is slow. \n*   But for single *character* search, it's always linear. KMP is for *substring* search."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf"
          ]
        },
        {
          "id": "jewels_stones",
          "name": "Jewels and Stones",
          "estimatedHours": 1,
          "description": "Count how many stones are also jewels",
          "practiceQuestions": [
            {
              "name": "Jewels and Stones",
              "slug": "jewels-and-stones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/jewels-and-stones/"
            }
          ],
          "learningTip": [
            "**Lookup Table:** Put one collection into a Set/HashSet for O(1) checking.",
            "**Complexity:** O(J + S). Naive solution is O(J * S).",
            "**Analogy:** Looking up words in a dictionary vs scanning entire book."
          ],
          "mustNotMiss": [
            "**Set:** `const set = new Set(jewels)`.",
            "**Count:** Iterate `stones`, if `set.has(stone)` count++.",
            "**JS:** `stones.split('').reduce((acc, curr) => set.has(curr) ? acc+1 : acc, 0)`."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between `Set` and `Array.includes`?",
              "answer": "**Time Complexity:** \n*   `Set.has()` is **O(1)** (average). \n*   `Array.includes()` is **O(N)**. \n*   Always use Set for frequent lookups."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/jewels-and-stones/"
          ]
        },
        {
          "id": "find_most_frequent_vowel_consonant",
          "name": "Find Most Frequent Vowel and Consonant",
          "estimatedHours": 2,
          "description": "Identify the most frequent vowel and consonant in a string",
          "learningTip": [
            "**Frequency Map:** Use a HashMap (Object/Map in JS) to count occurrences.",
            "**ASCII:** Vowels are `aeiou`. Consonants are the rest (check `isalpha`).",
            "**Optimization:** Arrays of size 26 or 128 (ASCII) are faster than HashMaps."
          ],
          "mustNotMiss": [
            "**Map:** `counts = {}`. `for (c of s) counts[c] = (counts[c] || 0) + 1`.",
            "**Max:** Iterate keys, track max count for Vowels and Consonants separately.",
            "**Tie-breaking:** If counts are equal, usually return the lexicographically smaller character."
          ],
          "interviewQuestions": [
            {
              "question": "Why use array `int[26]` instead of HashMap?",
              "answer": "**Performance:** \n*   Array access is direct memory offset (fastest). \n*   HashMap involves hashing function and collision handling (slower constant factor)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/find-the-most-frequent-vowel-present-in-a-given-string/"
          ]
        },
        {
          "id": "split_string_balanced",
          "name": "Split a String in Balanced Strings",
          "estimatedHours": 0.5,
          "description": "Split a string into maximum balanced substrings",
          "practiceQuestions": [
            {
              "name": "Split a String in Balanced Strings",
              "slug": "split-a-string-in-balanced-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/split-a-string-in-balanced-strings/"
            }
          ],
          "learningTip": [
            "**Greedy:** Split as soon as `balance == 0`.",
            "**Counter:** +1 for 'L', -1 for 'R'.",
            "**Logic:** Whenever counter hits 0, it means we have equal Ls and Rs from the last split point."
          ],
          "mustNotMiss": [
            "**Loop:** `for (char c : s)`.",
            "**Update:** `cnt += (c == 'L' ? 1 : -1)`.",
            "**Check:** `if (cnt == 0) ans++`.",
            "**Complexity:** O(N) time, O(1) space."
          ],
          "interviewQuestions": [
            {
              "question": "Is this a Greedy approach? Why?",
              "answer": "**Yes.** \n*   We greedily take the first opportunity to split (when balance is 0). \n*   This works because 'balanced' is a local property that resets."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/split-a-string-in-balanced-strings/"
          ]
        },
        {
          "id": "reverse_string_ii",
          "name": "Reverse String II",
          "estimatedHours": 2,
          "description": "Reverse parts of a string based on a pattern",
          "practiceQuestions": [
            {
              "name": "Reverse String II",
              "slug": "reverse-string-ii",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-string-ii/"
            }
          ],
          "learningTip": [
            "**Chunk Processing:** Process string in blocks of `2k`.",
            "**Logic:** For each block starting at `i`, reverse sub-segment `[i, i + k - 1]`.",
            "**Bounds:** Be careful with the last chunk (might be smaller than k)."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0; i < len; i += 2 * k)`.",
            "**Range:** `start = i`, `end = Math.min(i + k - 1, len - 1)`.",
            "**Reverse:** Standard in-place reverse helper function.",
            "**Mutable:** In JS, convert to array first `s.split('')`, process, `join('')`."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle string immutability in Java/JS?",
              "answer": "**Character Array:** \n*   Convert string to `char[]` (Java) or array of characters (JS). \n*   Modify in place, then convert back to string."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/reverse-string-ii/"
          ]
        },
        {
          "id": "valid_palindrome_extra_space",
          "name": "Valid Palindrome - Approach 1 - Extra Space",
          "estimatedHours": 0.5,
          "description": "Check palindrome by cleaning and reversing a string",
          "learningTip": [
            "**Naive Approach:** Build a new string with only alphanumeric chars, then checking if `newStr == newStr.reverse()`.",
            "**Regex:** `s.replace(/[^a-z0-9]/gi, '').toLowerCase()`.",
            "**Complexity:** Time O(N), Space O(N)."
          ],
          "mustNotMiss": [
            "**Interview:** Start here if stuck, but quickly mention 'I can optimize space to O(1)'.",
            "**Regex:** Regex is slow in many engines; manual filtering is often preferred in systems code."
          ],
          "interviewQuestions": [
            {
              "question": "Does `s.reverse()` exist in Java Strings?",
              "answer": "**No.** \n*   String is immutable. You must use `StringBuilder(s).reverse().toString()`. \n*   In JS, `s.split('').reverse().join('')`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-palindrome/"
          ]
        },
        {
          "id": "valid_palindrome_two_pointers",
          "name": "Valid Palindrome - Approach 2 - Two Pointers",
          "estimatedHours": 0.5,
          "description": "Use two-pointer technique to validate palindrome",
          "practiceQuestions": [
            {
              "name": "Valid Palindrome",
              "slug": "valid-palindrome",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-palindrome/"
            }
          ],
          "learningTip": [
            "**Two Pointers:** `left` at start, `right` at end.",
            "**Skip:** Move pointers inward until they hit an alphanumeric char.",
            "**Compare:** Check equality. If mismatch -> False.",
            "**Complexity:** Time O(N), Space O(1)."
          ],
          "mustNotMiss": [
            "**Loop:** `while (left < right)`.",
            "**Inner Loops:** `while(left < right && !isAlpha(s[left])) left++`.",
            "**Check:** `if (lower(s[left]) !== lower(s[right])) return false`.",
            "**Corner:** Empty string is valid."
          ],
          "interviewQuestions": [
            {
              "question": "What is the ASCII range for 'a'-'z'?",
              "answer": "**Numbers:** \n*   'a' = 97, 'z' = 122. \n*   'A' = 65, 'Z' = 90. \n*   '0' = 48, '9' = 57. \n*   Knowing this helps write `isAlpha` helper without built-ins."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-palindrome/solution/"
          ]
        },
        {
          "id": "largest_odd_number_string",
          "name": "Largest Odd Number in a String",
          "estimatedHours": 0.5,
          "description": "Find the largest odd number that can be formed from a string",
          "practiceQuestions": [
            {
              "name": "Largest Odd Number in String",
              "slug": "largest-odd-number-in-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/largest-odd-number-in-string/"
            }
          ],
          "learningTip": [
            "**Math:** An odd number MUST end with an odd digit (1, 3, 5, 7, 9).",
            "**Greedy:** The largest such number extends as far left as possible (i.e., starts at index 0).",
            "**Strategy:** Find the *last* occurrence of an odd digit. Return substring `[0, last_odd_index]`."
          ],
          "mustNotMiss": [
            "**Loop:** Iterate backwards from `len - 1` to `0`.",
            "**Check:** `if (s[i] % 2 !== 0)` return `s.substring(0, i + 1)`.",
            "**Default:** Return empty string `\"\"` if loop finishes."
          ],
          "interviewQuestions": [
            {
              "question": "Why iterate backwards?",
              "answer": "**Efficiency:** \n*   We want the *largest* number. \n*   The string prefix `0...i` is always larger than `0...j` if `i > j`. \n*   So we look for the rightmost odd digit to maximize length."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/largest-odd-number-in-string/"
          ]
        },
        {
          "id": "longest_common_prefix",
          "name": "Longest Common Prefix",
          "estimatedHours": 0.5,
          "description": "Find the longest common starting substring among strings",
          "practiceQuestions": [
            {
              "name": "Longest Common Prefix",
              "slug": "longest-common-prefix",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/longest-common-prefix/"
            }
          ],
          "learningTip": [
            "**Horizontal Scanning:** `LCP(s1, s2, s3) = LCP(LCP(s1, s2), s3)`.",
            "**Vertical Scanning:** Check column 0 for all strings, then column 1...",
            "**Complexity:** O(S) where S is sum of all characters."
          ],
          "mustNotMiss": [
            "**Vertical:** `for(i=0 to len(strs[0]))`. `char c = strs[0][i]`. `for(j=1 to n)` check `strs[j][i]`.",
            "**Mismatch:** Return `strs[0].substring(0, i)` immediately if mismatch found or if `i == strs[j].length`.",
            "**Edge Cases:** Empty array? Empty string inside array?"
          ],
          "interviewQuestions": [
            {
              "question": "How to optimize if strings are stored in a database?",
              "answer": "**Trie (Prefix Tree):** \n*   Insert all strings into a Trie. \n*   Walk down from root until branching occurs. The path is the LCP."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-common-prefix/"
          ]
        },
        {
          "id": "valid_anagram",
          "name": "Valid Anagram",
          "estimatedHours": 1,
          "description": "Check if two strings are anagrams of each other",
          "practiceQuestions": [
            {
              "name": "Valid Anagram",
              "slug": "valid-anagram",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-anagram/"
            }
          ],
          "learningTip": [
            "**Definition:** Same characters, same frequency.",
            "**Approaches:** 1. Sort strings (O(N log N)). 2. Frequency Map (O(N)).",
            "**Unicode:** For standard ASCII, array[26] is best. For Unicode, use HashMap."
          ],
          "mustNotMiss": [
            "**Length:** If `s.length !== t.length` return false.",
            "**Map:** `count` up for `s`, `count` down for `t`.",
            "**Check:** All counts must be 0 (or simply check size if strictly managing deletions)."
          ],
          "interviewQuestions": [
            {
              "question": "What if inputs contain Unicode characters?",
              "answer": "**Use HashMap:** \n*   `int[26]` array won't work. \n*   Use `HashMap<Character, Integer>` to store counts of any character."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-anagram/"
          ]
        },
        {
          "id": "isomorphic_strings",
          "name": "Isomorphic Strings",
          "estimatedHours": 1,
          "description": "Check if two strings have a one-to-one character mapping",
          "practiceQuestions": [
            {
              "name": "Isomorphic Strings",
              "slug": "isomorphic-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/isomorphic-strings/"
            }
          ],
          "learningTip": [
            "**Bijection:** One-to-one mapping. `a->b` means `b` is mapped from `a`. No two chars map to same char.",
            "**Two Maps:** `s->t` map AND `t->s` map are both required.",
            "**Example:** `egg`, `add`. e->a, g->d. Valid. `foo`, `bar`. f->b, o->a, o->r (Conflict!)."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i=0 to n)`.",
            "**Check:** `if (mapS[s[i]] && mapS[s[i]] !== t[i])` return false.",
            "**Check:** `if (mapT[t[i]] && mapT[t[i]] !== s[i])` return false.",
            "**Set:** `mapS[s[i]] = t[i]`, `mapT[t[i]] = s[i]`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use a single map?",
              "answer": "**No.** \n*   Need to ensure no two keys map to the same value (Surjectivity). \n*   `ab` -> `cc`. a->c, b->c. Valid function, but not Isomorphic (needs bijection)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/isomorphic-strings/"
          ]
        },
        {
          "id": "group_anagrams_sorted_key",
          "name": "Group Anagrams - Approach 1 - Sorted Key",
          "estimatedHours": 0.5,
          "description": "Group words that are anagrams using sorted string keys",
          "learningTip": [
            "**Key Idea:** Sorted version of 'eat', 'tea', 'ate' is always 'aet'.",
            "**Map:** Key = Sorted String, Value = List of original strings.",
            "**Complexity:** O(N * K log K) where K is max string length."
          ],
          "mustNotMiss": [
            "**Map:** `groups = {}`.",
            "**Loop:** For each `str`: `key = str.split('').sort().join('')`.",
            "**Append:** `groups[key].push(str)`.",
            "**Result:** `Object.values(groups)`."
          ],
          "interviewQuestions": [
            {
              "question": "What is the worst-case time complexity?",
              "answer": "**O(N * K log K).** \n*   Sorting each of N strings takes K log K. \n*   If K is small, this is effectively O(N)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/group-anagrams/"
          ]
        },
        {
          "id": "group_anagrams_hashed_key",
          "name": "Group Anagrams - Approach 2 - Hashed Key",
          "estimatedHours": 1,
          "description": "Group anagrams using character frequency hash as key",
          "practiceQuestions": [
            {
              "name": "Group Anagrams",
              "slug": "group-anagrams",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/group-anagrams/"
            },
            {
              "name": "Encode and Decode Strings",
              "slug": "encode-and-decode-strings",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/encode-and-decode-strings/"
            }
          ],
          "learningTip": [
            "**Optimization:** Avoid sorting. Use character counts as key.",
            "**Key Format:** String `\"#1#2#0...\"` representing counts of a,b,c...",
            "**Complexity:** O(N * K). Faster when K is large."
          ],
          "mustNotMiss": [
            "**Count:** `count = new Array(26).fill(0)`.",
            "**Key:** Convert array to string (unique hash). e.g., java `Arrays.toString(count)`.",
            "**Map:** `groups[hashedKey].push(str)`."
          ],
          "interviewQuestions": [
            {
              "question": "When is Hashing better than Sorting?",
              "answer": "**Long Strings:** \n*   If K is large, `K` (count) is better than `K log K` (sort). \n*   Sorting dominates only for very short strings."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/group-anagrams/"
          ]
        }
      ]
    },
    {
      "id": "pattern_sliding_window",
      "name": "Pattern: Sliding Window",
      "tier": 2,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "max_sum_subarray_k",
          "name": "Maximum Sum Subarray of Size K",
          "estimatedHours": 1,
          "description": "Find the maximum sum of any contiguous subarray of size k",
          "learningTip": [
            "**Fixed Window:** Window size `k` is constant.",
            "**Logic:** Subtract element entering from left, add element entering from right.",
            "**Complexity:** O(N) instead of O(N*K) brute force."
          ],
          "mustNotMiss": [
            "**Init:** Calculate sum of first `k` elements.",
            "**Slide:** Loop from `k` to `n-1`. `windowSum += arr[i] - arr[i-k]`.",
            "**Max:** Update `maxSum = Math.max(maxSum, windowSum)`."
          ],
          "interviewQuestions": [
            {
              "question": "What if array contains negative numbers?",
              "answer": "**Still works.** Logic doesn't change. Just initialize `maxSum` carefully (e.g., first window sum)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/find-maximum-or-minimum-sum-subarray-of-size-k/"
          ]
        },
        {
          "id": "smallest_subarray_sum",
          "name": "Smallest Subarray with a given Sum",
          "estimatedHours": 1.5,
          "description": "Find the length of the smallest contiguous subarray whose sum is greater than or equal to target",
          "practiceQuestions": [
            {
              "name": "Minimum Size Subarray Sum",
              "slug": "minimum-size-subarray-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/minimum-size-subarray-sum/"
            }
          ],
          "learningTip": [
            "**Dynamic Window:** Window grows to meet condition, then shrinks to optimize.",
            "**Expand:** Add `arr[right]` to `windowSum`.",
            "**Shrink:** While `windowSum >= target`, update `minLength`, subtract `arr[left]`, increment `left`."
          ],
          "mustNotMiss": [
            "**Loop:** `for (right = 0; right < n; right++)`.",
            "**Inner Loop:** `while (windowSum >= target)`.",
            "**Result:** Initialize `minLength` to Infinity. If still Infinity, return 0."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity?",
              "answer": "**O(N).** \n*   Each element is added once and removed once. \n*   It is NOT O(N^2) despite the inner loop."
            }
          ]
        },
        {
          "id": "longest_substring_k_distinct",
          "name": "Longest Substring with K Distinct Characters",
          "estimatedHours": 1.5,
          "description": "Find the length of the longest substring with no more than K distinct characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring with At Most K Distinct Characters",
              "slug": "longest-substring-with-at-most-k-distinct-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/"
            }
          ],
          "learningTip": [
            "**Map:** Use a HashMap to track frequency of characters in the current window.",
            "**Condition:** `map.size` (number of keys) must be <= K.",
            "**Shrink:** If `map.size > K`, increment `left`, decrement count in map. Remove key if count becomes 0."
          ],
          "mustNotMiss": [
            "**Key:** Only removing the key from the map reduces the 'distinct count'.",
            "**Max:** Update `maxLength = Math.max(maxLength, right - left + 1)` in every valid step."
          ],
          "interviewQuestions": [
            {
              "question": "What if K=2?",
              "answer": "**Fruit Into Baskets:** \n*   Basically the same problem (LeetCode 904)."
            }
          ]
        },
        {
          "id": "fruits_into_baskets",
          "name": "Fruits into Baskets",
          "estimatedHours": 2,
          "description": "Find the longest subarray with at most 2 distinct types of elements",
          "practiceQuestions": [
            {
              "name": "Fruit Into Baskets",
              "slug": "fruit-into-baskets",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/fruit-into-baskets/"
            }
          ],
          "learningTip": [
            "**Translation:** This is exactly 'Longest Substring with at most 2 Distinct Characters'.",
            "**Pattern:** Sliding Window + HashMap.",
            "**Real World:** Optimizing resource collection with limited slot types."
          ],
          "mustNotMiss": [
            "**Map:** `counts = new Map()`.",
            "**Condition:** `while (counts.size > 2)` shrink window.",
            "**Ref:** See 'Longest Substring with K Distinct'."
          ]
        },
        {
          "id": "longest_substring_no_repeat",
          "name": "Longest Substring Without Repeating Characters",
          "estimatedHours": 2,
          "description": "Find the length of the longest substring without repeating characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            }
          ],
          "learningTip": [
            "**Optimization:** Instead of shrinking one by one, jump `left` index directly.",
            "**Map:** Store `lastIndex` of each character.",
            "**Jump:** If `char` found in map and `map.get(char) >= left`, move `left = map.get(char) + 1`."
          ],
          "mustNotMiss": [
            "**Update:** Always update `map.set(char, index)`.",
            "**Constraint:** Make sure `left` never moves backward (use `Math.max`)."
          ]
        }
      ]
    },
    {
      "id": "pattern_two_pointers",
      "name": "Pattern: Two Pointers",
      "tier": 2,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "pair_with_target_sum",
          "name": "Pair with Target Sum",
          "estimatedHours": 1,
          "description": "Find indices of two numbers that add up to target in a sorted array",
          "practiceQuestions": [
            {
              "name": "Two Sum II - Input Array Is Sorted",
              "slug": "two-sum-ii-input-array-is-sorted",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
            }
          ],
          "learningTip": [
            "**Sorted:** The array MUST be sorted for this pattern.",
            "**Logic:** `sum < target`? Need bigger number -> `left++`. `sum > target`? Need smaller -> `right--`."
          ],
          "mustNotMiss": [
            "**Constraint:** 1-based indices in LeetCode problem (handle return carefully).",
            "**Proof:** We eliminate elements that cannot possibly be part of the solution."
          ]
        },
        {
          "id": "remove_duplicates_array",
          "name": "Remove Duplicates (Two Pointers)",
          "estimatedHours": 1,
          "description": "Remove duplicates from sorted array in-place",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted Array",
              "slug": "remove-duplicates-from-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
            }
          ],
          "learningTip": [
            "**Read/Write:** `nextNonDuplicate` (Write Pointer) and `i` (Read Pointer).",
            "**Logic:** If `arr[i] != arr[nextNonDuplicate - 1]`, write to `arr[nextNonDuplicate]` and increment."
          ],
          "mustNotMiss": [
            "**Start:** `nextNonDuplicate = 1`. Loop `i` from 1 to `n-1`."
          ]
        },
        {
          "id": "squares_of_sorted_array",
          "name": "Squaring a Sorted Array",
          "estimatedHours": 1.5,
          "description": "Return an array of the squares of each number sorted in non-decreasing order",
          "practiceQuestions": [
            {
              "name": "Squares of a Sorted Array",
              "slug": "squares-of-a-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/squares-of-a-sorted-array/"
            }
          ],
          "learningTip": [
            "**Problem:** Negatives squared become large positives. Order is disrupted.",
            "**Strategy:** Largest squares are at the ends (smallest negative, largest positive).",
            "**Fill:** Fill result array from *end* to *start*."
          ],
          "mustNotMiss": [
            "**Comparison:** `Math.abs(left) > Math.abs(right)`? Use left square, `left++`. Else right square, `right--`."
          ]
        },
        {
          "id": "3sum",
          "name": "3Sum",
          "estimatedHours": 2.5,
          "description": "Find all unique triplets that sum to zero",
          "practiceQuestions": [
            {
              "name": "3Sum",
              "slug": "3sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/3sum/"
            }
          ],
          "learningTip": [
            "**Reduction:** Sort array. Loop `i`. Problem becomes 'Find Pair with Sum = -arr[i]'.",
            "**Duplicates:** crucial. Skip duplicate `arr[i]`. Also skip duplicates during the Two Pointer phase.",
            "**Complexity:** O(N^2)."
          ],
          "mustNotMiss": [
            "**Outer Loop:** `if (i > 0 && arr[i] == arr[i-1]) continue`.",
            "**Inner Loop:** `while (left < right && arr[left] == arr[left+1]) left++` (after finding a valid triplet)."
          ],
          "interviewQuestions": [
            {
              "question": "Why simpler than N^3?",
              "answer": "**Sorting:** Enables Two Pointers (O(N)) for each element (O(N)), upgrading brute force (O(N^3)) to O(N^2)."
            }
          ]
        },
        {
          "id": "subarray_product_less_than_k",
          "name": "Subarrays with Product Less than a Target",
          "estimatedHours": 2,
          "description": "Count subarrays with product strictly less than k",
          "practiceQuestions": [
            {
              "name": "Subarray Product Less Than K",
              "slug": "subarray-product-less-than-k",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subarray-product-less-than-k/"
            }
          ],
          "learningTip": [
            "**Pattern:** Sliding Window (often grouped with Two Pointers).",
            "**Logic:** Expand `right`. Divide `product` by `arr[left]` until `< k`.",
            "**Count:** If valid window `[left, right]`, it adds `right - left + 1` new subarrays."
          ],
          "mustNotMiss": [
            "**Edge Case:** If `k <= 1`, return 0 (since product must be strictly less, and nums >= 1).",
            "**Formula:** The count `right - left + 1` represents all subarrays ending at `right`."
          ]
        }
      ]
    },
    {
      "id": "stack_queues",
      "name": "Stack and Queues",
      "tier": 2,
      "estimatedHours": 16.5,
      "topics": [
        {
          "id": "introduction_stacks_queues",
          "name": "Introduction to Stacks & Queues",
          "estimatedHours": 1,
          "description": "Get introduced to the fundamentals of Stacks and Queues",
          "learningTip": [
            "**LIFO vs FIFO:** Stack is LIFO (Last-In, First-Out) - like a stack of plates. Queue is FIFO (First-In, First-Out) - like a cafeteria line.",
            "**Applications:** Stacks -> Function calls, Undo/Redo, Parsing. Queues -> BFS, Printer jobs, Task scheduling.",
            "**Complexity:** Push/Pop/Enqueue/Dequeue should be O(1)."
          ],
          "mustNotMiss": [
            "**Stack:** `push()`, `pop()`, `peek()`, `isEmpty()`.",
            "**Queue:** `enqueue()`, `dequeue()`, `front()`, `isEmpty()`.",
            "**Implementation:** Arrays are easy but resizing is O(n). Linked Lists are truly O(1) but use more memory."
          ],
          "interviewQuestions": [
            {
              "question": "Real-world example of Stack vs Queue?",
              "answer": "**Stack:** Browser History (Back button), Ctrl+Z (Undo). \n**Queue:** Printer spooler, Server request handling, BFS in graphs."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/stack-data-structure/",
            "https://www.geeksforgeeks.org/queue-data-structure/"
          ]
        },
        {
          "id": "playing_stacks_queues",
          "name": "Playing with Stacks & Queues",
          "estimatedHours": 0.5,
          "description": "Explore basic operations on stacks and queues hands-on",
          "learningTip": [
            "**Stack Overflow:** Pushing to a full stack (limit usually memory-bound in JS).",
            "**Stack Underflow:** Popping an empty stack. ALWAYS check `isEmpty()` before popping.",
            "**JS Note:** JS Arrays are Stacks by default. `push()` and `pop()` are O(1) amortized."
          ],
          "mustNotMiss": [
            "**Simulate Queue with Array:** `push()` and `shift()`? NO! `shift()` is O(n).",
            "**True Queue:** Use a Linked List or a customized class for O(1) dequeue.",
            "**Deque:** Double-ended queue. Supports push/pop from both ends."
          ],
          "interviewQuestions": [
            {
              "question": "Why is `array.shift()` slow in JavaScript?",
              "answer": "**Re-indexing:** \n*   Removing the first element requires shifting all other elements one index to the left. \n*   Time complexity is **O(N)**."
            }
          ],
          "resources": [
            "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"
          ]
        },
        {
          "id": "implement_stack_two_queues",
          "name": "Implement Stack using Two Queues",
          "estimatedHours": 2,
          "description": "Build a stack using two queues",
          "practiceQuestions": [
            {
              "name": "Implement Stack using Queues",
              "slug": "implement-stack-using-queues",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-stack-using-queues/"
            }
          ],
          "learningTip": [
            "**Two Queues:** One `main` queue to store elements, one `helper` queue for reordering.",
            "**Strategy:** Either make `push` costly (O(N)) or `pop` costly (O(N)).",
            "**Common:** Make `push` O(N) so `pop` is O(1) (better for read-heavy)."
          ],
          "mustNotMiss": [
            "**Push O(N):** Enqueue x to `q2`. Dequeue everything from `q1` to `q2`. Swap `q1` and `q2`.",
            "**Result:** `q1` always has the newest element at the front (Stack behavior).",
            "**Pop O(1):** Just `q1.dequeue()`."
          ],
          "interviewQuestions": [
            {
              "question": "Can you do it with only one queue?",
              "answer": "**Yes.** \n*   See next topic! \n*   But strictly speaking, 'implement using queues' usually implies standard FIFO queues."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/implement-stack-using-queues/"
          ]
        },
        {
          "id": "implement_stack_one_queue",
          "name": "Implement Stack using One Queue",
          "estimatedHours": 0.5,
          "description": "Implement a stack using a single queue cleverly",
          "learningTip": [
            "**Rotation Trick:** To keep stack order, after pushing `x`, rotate the queue: dequeue and enqueue `size-1` elements.",
            "**Effect:** The new element `x` moves to the front (top of stack).",
            "**Complexity:** Push is O(n), Pop is O(1)."
          ],
          "mustNotMiss": [
            "**Algorithm:** `push(x)` -> `q.add(x)`. Then loop `size-1` times: `q.add(q.remove())`.",
            "**Pop:** `q.remove()`.",
            "**Top:** `q.peek()`.",
            "**Trade-off:** Push is slow, but space is minimized to O(N) items (no second queue)."
          ],
          "interviewQuestions": [
            {
              "question": "Is this better than 2 queues?",
              "answer": "**Space-wise: Yes.** \n*   Uses one queue structure. \n*   Time complexity is same (O(N) push). \n*   Code is cleaner."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/implement-stack-using-queues/solution/"
          ]
        },
        {
          "id": "implement_queue_stacks",
          "name": "Implement Queue using Stacks",
          "estimatedHours": 1,
          "description": "Simulate a queue using two stacks",
          "practiceQuestions": [
            {
              "name": "Implement Queue using Stacks",
              "slug": "implement-queue-using-stacks",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-queue-using-stacks/"
            }
          ],
          "learningTip": [
            "**Two Stacks:** `Input` stack (push) and `Output` stack (pop/peek).",
            "**Lazy Transfer:** Only move elements from Input to Output when Output is empty.",
            "**Amortized O(1):** Each element is pushed once and popped once from each stack."
          ],
          "mustNotMiss": [
            "**Push:** `input.push(x)`.",
            "**Pop/Peek:** If `output` is empty, while `input` not empty -> `output.push(input.pop())`. Then `output.pop()`.",
            "**Key:** The transfer reverses the order (LIFO + LIFO = FIFO)."
          ],
          "interviewQuestions": [
            {
              "question": "What is the Amortized Time Complexity?",
              "answer": "**O(1).** \n*   Worst case for single pop is O(N) (transferring). \n*   But across N operations, total work is O(N), so average is O(1)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/implement-queue-using-stacks/"
          ]
        },
        {
          "id": "valid_parentheses",
          "name": "Valid Parentheses",
          "estimatedHours": 1,
          "description": "Check if a string of parentheses is valid",
          "practiceQuestions": [
            {
              "name": "Valid Parentheses",
              "slug": "valid-parentheses",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-parentheses/"
            },
            {
              "name": "Decode String",
              "slug": "decode-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/decode-string/"
            }
          ],
          "learningTip": [
            "**Pattern:** Matching/Nesting problems almost always use a Stack.",
            "**Logic:** Push opening brackets. When closing bracket comes, pop and check for match.",
            "**Final Check:** Stack **must** be empty at the end (no unclosed brackets)."
          ],
          "mustNotMiss": [
            "**Map:** `map = {')':'(', '}':'{', ']':'['}`.",
            "**Loop:** `if (open) stack.push`. `if (close) check stack.pop() == map[char]`.",
            "**Return:** `stack.length === 0`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we solve this in O(1) space?",
              "answer": "**No.** \n*   We need to store the sequence of opening brackets to match them in reverse order. \n*   Worst case: `((((...` takes O(N) space."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-parentheses/"
          ]
        },
        {
          "id": "min_stack",
          "name": "Min Stack",
          "estimatedHours": 1,
          "description": "Design a stack that supports retrieving the minimum in O(1)",
          "practiceQuestions": [
            {
              "name": "Min Stack",
              "slug": "min-stack",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-stack/"
            }
          ],
          "learningTip": [
            "**Design:** Standard stack supports push/pop in O(1). Finding min usually takes O(N).",
            "**Trick:** Store `min` *along with* the value. Each node knows 'what is the min below me including me'.",
            "**Auxiliary:** Use a second stack `minStack` or store pairs."
          ],
          "mustNotMiss": [
            "**Push:** `stack.push(val)`. `minStack.push(Math.min(val, minStack.peek()))`.",
            "**Pop:** `stack.pop()`. `minStack.pop()`.",
            "**GetMin:** `minStack.peek()`."
          ],
          "interviewQuestions": [
            {
              "question": "How to optimize space for `minStack`?",
              "answer": "**Conditional Push:** \n*   Only push to `minStack` if `newVal <= currentMin`. \n*   Pop from `minStack` only if `poppedVal == currentMin`. \n*   Saves space for duplicate large values."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/min-stack/"
          ]
        },
        {
          "id": "remove_outermost_parentheses_stack",
          "name": "Remove Outermost Parentheses - Using Stack",
          "estimatedHours": 1,
          "description": "Remove outermost parentheses using a stack-based approach",
          "practiceQuestions": [
            {
              "name": "Remove Outermost Parentheses",
              "slug": "remove-outermost-parentheses",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-outermost-parentheses/"
            }
          ],
          "learningTip": [
            "**Stack:** Push `(`. When `)` comes, pop.",
            "**Primitive:** A primitive string starts with an empty stack (implicitly) and ends when stack becomes empty again.",
            "**Logic:** Only add `(` if stack depth > 0 (it's not the outer one). Only add `)` if stack depth > 1 (after pop it will still be > 0)."
          ],
          "mustNotMiss": [
            "**Start:** `count = 0`.",
            "**Loop:** `c == '('`: if `count++ > 0` add. `c == ')'`: if `count-- > 1` add.",
            "**Result:** String traversal is O(N)."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between Stack and Counter?",
              "answer": "**Counter is simpler here.** \n*   Since we only have one type of bracket '()', a simplified counter mimics the stack depth. \n*   If we had '[]' and '{}', we MUST use a Stack."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-outermost-parentheses/"
          ]
        },
        {
          "id": "remove_outermost_parentheses_no_stack",
          "name": "Remove Outermost Parentheses - without Stack",
          "estimatedHours": 0.5,
          "description": "Remove outer parentheses without using a stack",
          "learningTip": [
            "**Counter Method:** Use an integer `balance` instead of a stack.",
            "**Logic:** Increment for '(', decrement for ')'.",
            "**Action:** Only append '(' if `balance > 0` (opened before). Only append ')' if `balance > 1` (still open)."
          ],
          "mustNotMiss": [
            "**Loop:** `for (char c : s)`.",
            "**Conditions:** `if (c == '(' && balance++ > 0) res += c`. `if (c == ')' && balance-- > 1) res += c`.",
            "**Complexity:** O(N) time, O(1) space (ignoring result storage)."
          ],
          "interviewQuestions": [
            {
              "question": "Why is space O(1)?",
              "answer": "**No extra storage:** \n*   We only use a single integer `balance`. \n*   In Stack approach, we store up to N/2 characters."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-outermost-parentheses/solution/"
          ]
        },
        {
          "id": "evaluate_reverse_polish_notation",
          "name": "Evaluate Reverse Polish Notation",
          "estimatedHours": 2,
          "description": "Evaluate mathematical expressions in postfix notation",
          "practiceQuestions": [
            {
              "name": "Evaluate Reverse Polish Notation",
              "slug": "evaluate-reverse-polish-notation",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
            },
            {
              "name": "Asteroid Collision",
              "slug": "asteroid-collision",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/asteroid-collision/"
            }
          ],
          "learningTip": [
            "**Postfix:** Operators follow operands. `3 4 +` means `3 + 4`.",
            "**Execution:** Stack holds numbers. When you see an operator, pop TWO numbers, apply operator, push result.",
            "**Order:** `val2 = pop()`, `val1 = pop()`. Operation is `val1 op val2`."
          ],
          "mustNotMiss": [
            "**Division:** Integer division truncates toward zero (`Math.trunc`). Be careful with negatives.",
            "**Loop:** `tokens.forEach`. If `!isNaN(token)` push Number. Else pop, pop, calc, push.",
            "**Result:** `stack.pop()`."
          ],
          "interviewQuestions": [
            {
              "question": "Why use Reverse Polish Notation?",
              "answer": "**No Parentheses:** \n*   RPN removes the need for order-of-operations logic and parentheses rules. \n*   Easy for computers to evaluate purely left-to-right."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
          ]
        },
        {
          "id": "next_greater_element",
          "name": "Next Greater Element",
          "estimatedHours": 2,
          "description": "Find the next greater element for each number in an array",
          "practiceQuestions": [
            {
              "name": "Next Greater Element I",
              "slug": "next-greater-element-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/next-greater-element-i/"
            },
            {
              "name": "Online Stock Span",
              "slug": "online-stock-span",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/online-stock-span/"
            }
          ],
          "learningTip": [
            "**Monotonic Stack:** Keep stack sorted (decreasing).",
            "**Next Greater:** The element that 'pops' you from the stack is your Next Greater Element.",
            "**Flow:** For each `num`: while `stack.top < num`, `map[stack.pop()] = num`. Push `num`."
          ],
          "mustNotMiss": [
            "**Map:** Use a generic map to store answers for O(1) lookup later.",
            "**Stack:** Stores values (since they are unique here) or indices.",
            "**Remaining:** Elements left in stack have no greater element (-1)."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity explanation?",
              "answer": "**O(N).** \n*   Each element is pushed exactly once and popped at most once. \n*   Inner loop is amortized O(1)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/next-greater-element-i/"
          ]
        },
        {
          "id": "daily_temperatures",
          "name": "Daily Temperatures",
          "estimatedHours": 1,
          "description": "Find how many days until a warmer temperature",
          "practiceQuestions": [
            {
              "name": "Daily Temperatures",
              "slug": "daily-temperatures",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/daily-temperatures/"
            },
            {
              "name": "Car Fleet",
              "slug": "car-fleet",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/car-fleet/"
            },
            {
              "name": "Largest Rectangle in Histogram",
              "slug": "largest-rectangle-in-histogram",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
            }
          ],
          "learningTip": [
            "**Monotonic Stack:** Store **indices** (days).",
            "**Condition:** If `temp[i] > temp[stack.top]`, then `i` is the warmer day for `stack.top`.",
            "**Distance:** `days = i - stack.pop()`."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0 to n)`.",
            "**While:** `stack` not empty AND `temp[i] > temp[stack.peek()]`.",
            "**Pop:** `prevIndex = stack.pop()`. `ans[prevIndex] = i - prevIndex`.",
            "**Push:** `stack.push(i)`."
          ],
          "interviewQuestions": [
            {
              "question": "What if we search linearly for each day?",
              "answer": "**O(N^2) Time Limit Exceeded.** \n*   For `[99, 98, 97, ... 1, 100]`, linear scan checks everyone for the last 100. \n*   Stack does it in O(N)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/daily-temperatures/"
          ]
        },
        {
          "id": "next_greater_element_ii",
          "name": "Next Greater Element - II",
          "estimatedHours": 1,
          "description": "Solve the circular version of Next Greater Element",
          "practiceQuestions": [
            {
              "name": "Next Greater Element II",
              "slug": "next-greater-element-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/next-greater-element-ii/"
            }
          ],
          "learningTip": [
            "**Circular Array:** The array wraps around.",
            "**Trick:** Concatenate array with itself? `nums + nums`. Or simulate by iterating `2 * N` times and using modulo `i % N`.",
            "**Logic:** Same Monotonic Stack. Just search space is doubled."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0 to 2*N - 1)`.",
            "**Index:** `curr = nums[i % N]`.",
            "**While:** `nums[stack.peek()] < curr` -> `res[stack.pop()] = curr`.",
            "**Push:** If `i < N` push `i` (we only need to resolve the first N elements)."
          ],
          "interviewQuestions": [
            {
              "question": "Do we really need to allocate array of size 2N?",
              "answer": "**No.** \n*   Use modulo operator `%` to simulate the circular traversal. \n*   Saves O(N) auxiliary space."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/next-greater-element-ii/"
          ]
        },
        {
          "id": "rotting_oranges",
          "name": "Rotting Oranges",
          "estimatedHours": 2,
          "description": "BFS algorithm to find time for all oranges to rot",
          "practiceQuestions": [
            {
              "name": "Rotting Oranges",
              "slug": "rotting-oranges",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotting-oranges/"
            }
          ],
          "learningTip": [
            "**Multi-Source BFS:** Start BFS from ALL rotten oranges simultaneously.",
            "**Levels:** Each layer of BFS represents 1 minute.",
            "**Fresh Count:** Track fresh oranges. Decrement as they rot. If fresh > 0 at end -> Impossible (-1)."
          ],
          "mustNotMiss": [
            "**Queue:** Init with coordinates `[r, c]` of all rotten oranges.",
            "**Loop:** `while queue` (process level by level).",
            "**Neighbors:** Check 4 directions. If fresh, make rotten, decrement fresh_count, push to queue.",
            "**Result:** Return `minutes`."
          ],
          "interviewQuestions": [
            {
              "question": "Why BFS and not DFS?",
              "answer": "**Shortest Path:** \n*   We want the *minimum* time. BFS naturally propagates level-by-level (minutes). \n*   DFS would find *a* path for rotting, but not consistent with simultaneous rotting."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/rotting-oranges/"
          ]
        }
      ]
    },
    {
      "id": "binary_search_algorithm",
      "name": "Binary Search Algorithm",
      "tier": 3,
      "estimatedHours": 29,
      "topics": [
        {
          "id": "square_root_x",
          "name": "Square Root of X",
          "estimatedHours": 2.5,
          "description": "Find the square root of a number using binary search",
          "learningTip": [
            "**Search on Answer:** The answer space is [0, x]. We are searching for a value `k` such that `k*k <= x`.",
            "**Integer Overflow:** Be careful when computing `mid*mid`. Use `mid <= x/mid` to avoid overflow."
          ],
          "mustNotMiss": [
            "**Algorithm:** if x < 2 return x. left = 2, right = x/2.",
            "**Loop:** While left <= right: mid = left + (right-left)/2. num = mid * mid.",
            "**Check:** If num > x: right = mid - 1. If num < x: left = mid + 1. If num == x: return mid.",
            "**Return:** `right` (because loop ends when left > right, and right is the floor)."
          ],
          "interviewQuestions": [
            {
              "question": "Why return `right` and not `left`?",
              "answer": "**Truncation:** \n*   The loop breaks when `left > right`. \n*   At this point, `right` is the largest integer whose square is `<= x`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/sqrtx/"
          ]
        },
        {
          "id": "best_practice_finding_middle",
          "name": "Best Practice - Finding Middle Element",
          "estimatedHours": 1,
          "description": "Learn the safe and optimal way to find the middle index",
          "learningTip": [
            "**The Overflow Bug:** `(left + right) / 2` works in math but fails in code if `left + right` > MAX_INT.",
            "**The Fix:** `left + (right - left) / 2`. This is mathematically equivalent but safe."
          ],
          "mustNotMiss": [
            "**Bitwise:** `left + ((right - left) >> 1)` is faster in some low-level languages, but `Math.floor` is fine in JS.",
            "**History:** This bug existed in Java's Arrays.binarySearch() for a decade before being fixed.",
            "**Interview Signal:** Writing the safe version shows you understand computer architecture constraints."
          ],
          "interviewQuestions": [
            {
              "question": "Can `(left+right) >>> 1` solve it in JS?",
              "answer": "**Yes.** \n*   The unsigned right shift `>>>` operator in JS converts operands to 32-bit unsigned integers. \n*   It allows sums up to 2^32 - 1, dealing with positive overflows."
            }
          ],
          "resources": [
            "https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html"
          ]
        },
        {
          "id": "guess_higher_lower",
          "name": "Guess Higher or Lower",
          "estimatedHours": 1,
          "description": "Use binary search to guess a hidden number",
          "learningTip": [
            "**Interactive Problems:** You don't have an array. You have an API `guess(num)`. Treating an API as a sorted array is key.",
            "**Return Values:** -1 (lower), 1 (higher), 0 (match). Map these to your binary search logic."
          ],
          "mustNotMiss": [
            "**Logic:** standard BS template.",
            "**Conditions:** If guess(mid) == -1: target is lower (right = mid - 1).",
            "**Conditions:** If guess(mid) == 1: target is higher (left = mid + 1).",
            "**Conditions:** If guess(mid) == 0: return mid."
          ],
          "interviewQuestions": [
            {
              "question": "What is ternary search?",
              "answer": "**Optimization:** \n*   Divides range into 3 parts. \n*   Used for unimodal functions (finding max/min). \n*   Binary search is strictly better O(log N) for monotonic functions than Ternary."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/guess-number-higher-or-lower/"
          ]
        },
        {
          "id": "search_rotated_sorted_array",
          "name": "Search in Rotated Sorted Array",
          "estimatedHours": 4,
          "description": "Search an element in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Search in Rotated Sorted Array",
              "slug": "search-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
            },
            {
              "name": "Search a 2D Matrix",
              "slug": "search-a-2d-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-a-2d-matrix/"
            }
          ],
          "learningTip": [
            "**Pivot:** The array is sorted, then rotated. One half is ALWAYS sorted.",
            "**Strategy:** Identify the sorted half. Check if target lies in that range. If yes, search there. If no, search the other half.",
            "**Complexity:** O(log N)."
          ],
          "mustNotMiss": [
            "**Check Left:** `if (nums[left] <= nums[mid])` Left is sorted.",
            "**Range:** `if (target >= nums[left] && target < nums[mid]) right = mid - 1`. Else `left = mid + 1`.",
            "**Check Right:** Else (Right is sorted).",
            "**Range:** `if (target > nums[mid] && target <= nums[right]) left = mid + 1`. Else `right = mid - 1`."
          ],
          "interviewQuestions": [
            {
              "question": "What if there are duplicates?",
              "answer": "**Worst Case O(N).** \n*   If `nums[left] == nums[mid] == nums[right]`, we can't tell which half is sorted. \n*   We must shrink search space: `left++` and `right--`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/search-in-rotated-sorted-array/"
          ]
        },
        {
          "id": "first_bad_version",
          "name": "First Bad Version",
          "estimatedHours": 2.5,
          "description": "Identify the first bad version using binary search",
          "practiceQuestions": [
            {
              "name": "First Bad Version",
              "slug": "first-bad-version",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/first-bad-version/"
            }
          ],
          "learningTip": [
            "**Pattern:** Find the *first* element satisfying a condition (True/False boundary).",
            "**Template:** `while (left < right)`. `right = mid` (include mid). `left = mid + 1` (must be after mid).",
            "**Return:** `left` is the start of the True block."
          ],
          "mustNotMiss": [
            "**Loop:** `while (left < right)`.",
            "**Check:** `if (isBadVersion(mid))` -> `right = mid` (This might be the first one, keep it).",
            "**Else:** `left = mid + 1` (It was good, so bad must be after).",
            "**Post:** Return `left`."
          ],
          "interviewQuestions": [
            {
              "question": "Why `left < right` instead of `left <= right`?",
              "answer": "**Convergence:** \n*   When we search for a boundary (not a specific value match), we want `left` and `right` to converge to the answer. \n*   Loop terminates when `left == right`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/first-bad-version/"
          ]
        },
        {
          "id": "find_peak_element",
          "name": "Find Peak Element",
          "estimatedHours": 3,
          "description": "Locate a peak element using binary search",
          "practiceQuestions": [
            {
              "name": "Find Peak Element",
              "slug": "find-peak-element",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-peak-element/"
            },
            {
              "name": "Koko Eating Bananas",
              "slug": "koko-eating-bananas",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/koko-eating-bananas/"
            }
          ],
          "learningTip": [
            "**Peak Property:** `nums[i] > nums[i+1]` means we are on a downward slope (peak is to the left).",
            "**Climb:** Always move towards the higher neighbor.",
            "**Edges:** `-Infinity` at ends implies a peak always exists."
          ],
          "mustNotMiss": [
            "**Comparison:** Compare `nums[mid]` vs `nums[mid+1]`.",
            "**Descending:** `if (nums[mid] > nums[mid+1])` -> `right = mid` (Peak is `mid` or left).",
            "**Ascending:** `else` -> `left = mid + 1` (Peak is strictly right).",
            "**Complexity:** O(log N)."
          ],
          "interviewQuestions": [
            {
              "question": "Can there be multiple peaks?",
              "answer": "**Yes.** \n*   This algorithm finds *any* peak. \n*   It treats the array as a mountain range and just climbs up one slope until it hits a top."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-peak-element/"
          ]
        },
        {
          "id": "find_minimum_rotated_sorted_array",
          "name": "Find Minimum in Rotated Sorted Array",
          "estimatedHours": 3,
          "description": "Find the smallest element in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Find Minimum in Rotated Sorted Array",
              "slug": "find-minimum-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
            }
          ],
          "learningTip": [
            "**Pivot:** The minimum element is the only one that is smaller than its previous element.",
            "**Compare with Right:** If `nums[mid] > nums[right]`, minimum is deeply in the right half (e.g., `[3,4,5,1,2]`).",
            "**Else:** Minimum is in the left half or is `mid` (e.g., `[5,1,2,3,4]`)."
          ],
          "mustNotMiss": [
            "**Loop:** `while (left < right)`.",
            "**Condition:** `if (nums[mid] > nums[right]) left = mid + 1`.",
            "**Else:** `right = mid` (Not `mid - 1` because `mid` could be the minimum).",
            "**Return:** `nums[left]`."
          ],
          "interviewQuestions": [
            {
              "question": "Why compare with `right` and not `left`?",
              "answer": "**Ambiguity:** \n*   In a sorted array (non-rotated), `nums[mid] > nums[left]` is always true, giving no info on where the 'min' (pivot) is. \n*   Comparing with `right` reliably detects the drop."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
          ]
        },
        {
          "id": "find_first_last_position_sorted_array",
          "name": "Find First & Last Position in Sorted Array",
          "estimatedHours": 2.5,
          "description": "Find the first and last index of a target in a sorted array",
          "practiceQuestions": [
            {
              "name": "Find First and Last Position of Element in Sorted Array",
              "slug": "find-first-and-last-position-of-element-in-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
            }
          ],
          "learningTip": [
            "**Double Search:** Run binary search twice.",
            "**Left Bound:** Find first index `i` where `nums[i] == target`.",
            "**Right Bound:** Find last index `j` where `nums[j] == target`."
          ],
          "mustNotMiss": [
            "**Search Left:** `if (nums[mid] >= target) right = mid - 1` (Keep trying to go left).",
            "**Search Right:** `if (nums[mid] <= target) left = mid + 1` (Keep trying to go right).",
            "**Checks:** After loop, check if index is valid and equals target."
          ],
          "interviewQuestions": [
            {
              "question": "What happens if target is not found?",
              "answer": "**Return [-1, -1].** \n*   You must check bounds after the loop. \n*   If `left` index is out of bounds or `nums[left] != target`, it wasn't there."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
          ]
        },
        {
          "id": "find_first_last_position_approach_2",
          "name": "Find First & Last Position in Sorted Array - Approach 2",
          "estimatedHours": 1,
          "description": "Optimized approach for finding first and last index of target",
          "learningTip": [
            "**Lower Bound:** First index where `nums[i] >= target`.",
            "**Upper Bound:** First index where `nums[i] > target`.",
            "**Range:** `[lower_bound, upper_bound - 1]`."
          ],
          "mustNotMiss": [
            "**Libraries:** `std::lower_bound` (C++), `bisect_left` (Python).",
            "**Manual Lower:** `if (array[mid] < k) low = mid + 1; else high = mid;` (converges to first >=).",
            "**Manual Upper:** `if (array[mid] <= k) low = mid + 1; else high = mid;` (converges to first >)."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between `bisect_left` and `bisect_right`?",
              "answer": "**Insertion Points:** \n*   `left`: Insert before existing duplicates. \n*   `right`: Insert after existing duplicates. \n*   Difference gives count of duplicates."
            }
          ],
          "resources": [
            "https://docs.python.org/3/library/bisect.html"
          ]
        },
        {
          "id": "find_peak_mountain_array",
          "name": "Find Peak in a Mountain Array",
          "estimatedHours": 2.5,
          "description": "Find the peak element in a mountain-shaped array",
          "learningTip": [
            "**Structure:** Ascending -> PEAK -> Descending.",
            "**Step 1:** Find Peak Index (Binary Search).",
            "**Step 2:** Binary Search target in Left (Ascending part).",
            "**Step 3:** Binary Search target in Right (Descending part - logic flipped)."
          ],
          "mustNotMiss": [
            "**Peak:** `arr[mid] < arr[mid+1]` means we are on left slope.",
            "**Right Search:** Note that `if (arr[mid] > target)` -> `left = mid + 1` (moving RIGHT for smaller values).",
            "**Don't Sort:** Sorting ruins the mountain structure ($O(N log N)$ vs $O(log N)$)."
          ],
          "interviewQuestions": [
            {
              "question": "Can we do this in one pass?",
              "answer": "**Sort of.** \n*   But it's conceptually cleaner to find the Peak first. \n*   Complexity is still O(3 * log N) ~ O(log N)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-in-mountain-array/"
          ]
        },
        {
          "id": "single_element_sorted_array",
          "name": "Single Element in a Sorted Array",
          "estimatedHours": 3,
          "description": "Find the single non-duplicate element in a sorted array",
          "practiceQuestions": [
            {
              "name": "Single Element in a Sorted Array",
              "slug": "single-element-in-a-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
            }
          ],
          "learningTip": [
            "**Pairs:** In a normal sorted pair array, `(even, odd)` indices match (0,1), (2,3).",
            "**Disruption:** The single element shifts everything. After it, matches are `(odd, even)`.",
            "**Strategy:** Binary Search for the breakpoint where the pattern flips."
          ],
          "mustNotMiss": [
            "**Mid:** If `mid` is odd, decrement to make it even. Now `mid` is the start of a pair.",
            "**Check:** If `nums[mid] == nums[mid+1]`, pattern holds. Move Right (`left = mid + 2`).",
            "**Else:** Pattern broken. Single element is `mid` or to the left (`right = mid`)."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use XOR?",
              "answer": "**Yes, O(N).** \n*   `res ^= num`. \n*   BUT constraint usually asks for **O(log N)**, so XOR is not optimal."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/single-element-in-a-sorted-array/"
          ]
        },
        {
          "id": "find_k_closest_elements",
          "name": "Find k Closest Elements",
          "estimatedHours": 3,
          "description": "Find the k elements closest to a target in a sorted array",
          "practiceQuestions": [
            {
              "name": "Find K Closest Elements",
              "slug": "find-k-closest-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-k-closest-elements/"
            },
            {
              "name": "Time Based Key-Value Store",
              "slug": "time-based-key-value-store",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/time-based-key-value-store/"
            }
          ],
          "learningTip": [
            "**Window:** We need a window of size `k`.",
            "**Binary Search:** Search for the *start index* of this window.",
            "**Condition:** `x - arr[mid] > arr[mid+k] - x`. If true, window should move right."
          ],
          "mustNotMiss": [
            "**Range:** `[0, n-k]`.",
            "**Compare:** Distance of `arr[mid]` to `x` vs Distance of `arr[mid+k]` to `x`.",
            "**Move:** If `arr[mid]` is farther than `arr[mid+k]`, shift window right (`left = mid + 1`)."
          ],
          "interviewQuestions": [
            {
              "question": "Why search for the window start?",
              "answer": "**Efficiency.** \n*   Searching for `x` first and then expanding is messy (two pointers, boundary checks). \n*   Searching for window start directly converges to the optimal subset."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-k-closest-elements/"
          ]
        }
      ]
    },
    {
      "id": "two_pointers_sliding_window",
      "name": "Two Pointers & Sliding Window",
      "tier": 3,
      "estimatedHours": 37.5,
      "topics": [
        {
          "id": "two_sum",
          "name": "Two Sum",
          "estimatedHours": 2.5,
          "description": "Find two numbers that add up to a target using hashing",
          "practiceQuestions": [
            {
              "name": "Two Sum",
              "slug": "two-sum",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/two-sum/"
            },
            {
              "name": "4Sum",
              "slug": "4sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/4sum/"
            }
          ],
          "learningTip": [
            "**HashMap:** One-pass approach. `map[target - num]`. O(N) time/space.",
            "**Two Pointers?** Only works if array is sorted (which changes indices). Standard Two Sum implies unsorted unless specified.",
            "**Edge Case:** The same element cannot be used twice."
          ],
          "mustNotMiss": [
            "**Map:** `const map = new Map()`.",
            "**Loop:** `for (let i = 0; i < nums.length; i++)`.",
            "**Check:** `complement = target - nums[i]`. If `map.has(complement)`, return `[map.get(complement), i]`.",
            "**Set:** `map.set(nums[i], i)`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use Two Pointers?",
              "answer": "**Only if meaningful.** \n*   Sorting takes O(N log N). HashMap is O(N). \n*   If we need to return *indices*, sorting messes them up (unless we store original indices pairs)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/two-sum/"
          ]
        },
        {
          "id": "two_sum_ii_sorted",
          "name": "Two Sum II - Input Array Is Sorted",
          "estimatedHours": 2.5,
          "description": "Solve Two Sum with a sorted array using two pointers",
          "practiceQuestions": [
            {
              "name": "Two Sum II - Input Array Is Sorted",
              "slug": "two-sum-ii-input-array-is-sorted",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
            }
          ],
          "learningTip": [
            "**Sorted Property:** `numbers[0]` is smallest, `numbers[end]` is largest.",
            "**Logic:** `Sum < Target` -> Need bigger number (move left pointer). `Sum > Target` -> Need smaller number (move right pointer).",
            "**O(1) Space:** No HashMap needed."
          ],
          "mustNotMiss": [
            "**Loop:** `while (l < r)`.",
            "**Check:** `sum = numbers[l] + numbers[r]`. `if sum == target` return.",
            "**Move:** `sum < target ? l++ : r--`.",
            "**Note:** 1-based indexing in this problem."
          ],
          "interviewQuestions": [
            {
              "question": "Does this work for unsorted arrays?",
              "answer": "**No.** \n*   We rely on the order to decide which pointer to move. \n*   Moving `l` right implies increasing the sum. This guarantee only holds if sorted."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
          ]
        },
        {
          "id": "is_subsequence",
          "name": "Is Subsequence",
          "estimatedHours": 1,
          "description": "Check if one string is a subsequence of another",
          "practiceQuestions": [
            {
              "name": "Is Subsequence",
              "slug": "is-subsequence",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/is-subsequence/"
            }
          ],
          "learningTip": [
            "**Greedy:** Align current char of `s` with first valid char in `t`.",
            "**Subsequence:** Order matters, continuity doesn't.",
            "**Pointers:** `i` for `s`, `j` for `t`."
          ],
          "mustNotMiss": [
            "**Loop:** `while (i < s.len && j < t.len)`.",
            "**Match:** `if (s[i] == t[j]) i++` (found one char).",
            "**Always:** `j++` (move forward in bigger string).",
            "**Result:** `i == s.len`."
          ],
          "interviewQuestions": [
            {
              "question": "What if there are 1 billion `s` strings?",
              "answer": "**Pre-processing:** \n*   Map each char in `t` to a sorted list of its indices. \n*   For each `s`, use Binary Search (Find Next Greater Index) to verify order efficiently."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/is-subsequence/"
          ]
        },
        {
          "id": "find_index_first_occurrence_string",
          "name": "Find Index of First Occurrence in String",
          "estimatedHours": 2.5,
          "description": "Locate the first occurrence of a substring in a string",
          "practiceQuestions": [
            {
              "name": "Find the Index of the First Occurrence in a String",
              "slug": "find-the-index-of-the-first-occurrence-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
            }
          ],
          "learningTip": [
            "**Naive:** Check every position `i` in haystack. `haystack.substring(i, i+len) == needle`.",
            "**Optimized:** KMP, Rabin-Karp, Z-Algorithm (Overkill for most interviews unless asked).",
            "**Speed:** Standard `indexOf` is usually highly optimized in languages (often checking First/Last chars)."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0; i <= n - m; i++)`.",
            "**Check:** `if (hystack[i] == needle[0] && matches(i))`.",
            "**Return:** `i` on first match, `-1` if none found."
          ],
          "interviewQuestions": [
            {
              "question": "Worst case complexity of Naive vs KMP?",
              "answer": "**Naive:** O(N * M). (e.g., AAAAAA...B searching AAAAAA...A) \n**KMP:** O(N + M). (Skips redundant checks)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
          ]
        },
        {
          "id": "kmp_algorithm",
          "name": "KMP (Knuth-Morris-Pratt) Algorithm",
          "estimatedHours": 4.5,
          "description": "Efficient substring search using the KMP algorithm",
          "learningTip": [
            "**LPS:** Longest Prefix Suffix. The length of the longest proper prefix that is also a proper suffix.",
            "**Skip:** If mismatch at `j`, `LPS[j-1]` tells us where `needle` matches itself, so we don't start from 0.",
            "**Complexity:** Construction O(M), Search O(N)."
          ],
          "mustNotMiss": [
            "**Build LPS:** `len = 0, i = 1`. If match, `lps[i++] = ++len`. Else if len > 0, `len = lps[len-1]`. Else `lps[i++] = 0`.",
            "**Search:** If mismatch, `j = lps[j-1]` (shift pattern). If correct, `i++, j++`."
          ],
          "interviewQuestions": [
            {
              "question": "Explain LPS array for 'ABABAC'?",
              "answer": "**[0, 0, 1, 2, 3, 0]** \n*   A (0) \n*   AB (0) \n*   ABA (1 - A) \n*   ABAB (2 - AB) \n*   ABABA (3 - ABA) \n*   ABABAC (0)"
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
          ]
        },
        {
          "id": "intersection_two_linked_lists_two_pointers",
          "name": "Intersection of Two Linked Lists - Two Pointers",
          "estimatedHours": 2.5,
          "description": "Find the intersection node of two linked lists using two pointers",
          "learningTip": [
            "**Pattern:** Two pointers starting at heads. When one hits end, switch to OTHER head.",
            "**Math:** Path A: `Diff + Common`. Path B: `Diff' + Common`. \n*   `Diff + Common + Diff'` == `Diff' + Common + Diff`.",
            "**Result:** They meet after traversing total `Len(A) + Len(B)`."
          ],
          "mustNotMiss": [
            "**Ptr1:** `headA`. **Ptr2:** `headB`.",
            "**Switch:** `ptr1 = ptr1 ? ptr1.next : headB`.",
            "**Switch:** `ptr2 = ptr2 ? ptr2.next : headA`.",
            "**Meet:** `while ptr1 != ptr2` loop terminates at intersection or `null`."
          ],
          "interviewQuestions": [
            {
              "question": "What if cycles exist?",
              "answer": "**Harder Problem.** \n*   First detect cycles. \n*   If valid cycles exist, logic changes completely (finding entry point of cycle vs intersection)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/intersection-of-two-linked-lists/"
          ]
        },
        {
          "id": "container_most_water",
          "name": "Container with Most Water",
          "estimatedHours": 2.5,
          "description": "Maximize water between two lines using two pointers",
          "practiceQuestions": [
            {
              "name": "Container With Most Water",
              "slug": "container-with-most-water",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/container-with-most-water/"
            }
          ],
          "learningTip": [
            "**Starts Wide:** Initialize pointers at `0` and `n-1` to maximize width.",
            "**Move Shortest:** To potentially find a taller line, you MUST move the shorter pointer inward.",
            "**Greedy:** Local optimal choice leads to global optimum."
          ],
          "mustNotMiss": [
            "**Area:** `min(height[l], height[r]) * (r - l)`.",
            "**Loop:** `while (l < r)`.",
            "**Move:** `if (height[l] < height[r]) l++`. `else r--`.",
            "**Complexity:** O(N) Time, O(1) Space."
          ],
          "interviewQuestions": [
            {
              "question": "Proove why moving the shorter pointer works?",
              "answer": "**Proof by Contradiction:** \n*   If we move the taller pointer, the width decreases, and the height is bounded by the shorter one (which didn't change). \n*   So area can ONLY decrease. \n*   We must move the shorter one to have a chance at a higher height."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/container-with-most-water/"
          ]
        },
        {
          "id": "three_sum",
          "name": "Three Sum",
          "estimatedHours": 2.5,
          "description": "Find all unique triplets that sum to zero",
          "practiceQuestions": [
            {
              "name": "3Sum",
              "slug": "3sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/3sum/"
            }
          ],
          "learningTip": [
            "**Sort:** Sorting allows using Two Pointers to find pairs.",
            "**Fix One:** Iterate `i`. Problem reduces to finding `TwoSum` for target `-nums[i]` in `nums[i+1:]`.",
            "**Duplicates:** Skip `nums[i]` if same as `nums[i-1]`. Skip `l` and `r` duplicates similarly."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0 to n-2)`.",
            "**Two Sum:** `l = i+1, r = n-1`. `sum = nums[i] + nums[l] + nums[r]`.",
            "**Move:** `sum < 0 -> l++`. `sum > 0 -> r--`. `sum == 0 -> add result, l++, r--, skip dupes`.",
            "**Complexity:** O(N^2)."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use a HashMap instead of sorting?",
              "answer": "**Yes.** \n*   But handling duplicates becomes very tricky (need to sort the triplet before adding to a Set). \n*   Sorting the input array is generally preferred for this problem."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/3sum/"
          ]
        },
        {
          "id": "trapping_rain_water",
          "name": "Trapping Rain Water",
          "estimatedHours": 3,
          "description": "Calculate how much water can be trapped after rain",
          "practiceQuestions": [
            {
              "name": "Trapping Rain Water",
              "slug": "trapping-rain-water",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/trapping-rain-water/"
            }
          ],
          "learningTip": [
            "**Concept:** Water relies on the `min(leftMax, rightMax)` boundary.",
            "**Two Pointers:** Maintain `leftMax` and `rightMax` on the fly.",
            "**Logic:** Use `l` and `r`. If `leftMax < rightMax`, we know water at `l` is determined by `leftMax` (right boundary is guaranteed to be taller somewhere)."
          ],
          "mustNotMiss": [
            "**Loop:** `while (l < r)`.",
            "**Check:** `if (height[l] <= height[r])`.",
            "**Update:** `if (height[l] >= leftMax) leftMax = height[l]`. `else ans += leftMax - height[l]`. `l++`.",
            "**Complexity:** O(N) Time, O(1) Space."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between Trapping Rain Water vs Container Most Water?",
              "answer": "**Area vs Accumulation:** \n*   'Container' cares about the *widest* pair of lines. \n*   'Trapping' accumulates water on top of *every* bar based on local peaks."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/trapping-rain-water/"
          ]
        },
        {
          "id": "longest_substring_without_repeating",
          "name": "Longest Substring Without Repeating Characters",
          "estimatedHours": 4,
          "description": "Find the longest substring with all unique characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            }
          ],
          "learningTip": [
            "**Sliding Window:** Expand `right`. If duplicate found (`char` in window), shrink `left`.",
            "**Map:** Store `char -> index`. This lets us jump `left` directly to `index + 1`.",
            "**Max:** Update `maxLen` at every step."
          ],
          "mustNotMiss": [
            "**Loop:** `for (right = 0 to n)`.",
            "**Check:** `if (map.has(s[right])) left = max(left, map.get(s[right]) + 1)`.",
            "**Update:** `map.set(s[right], right)`. `ans = max(ans, right - left + 1)`.",
            "**Complexity:** O(N) Time."
          ],
          "interviewQuestions": [
            {
              "question": "Why do we need `max(left, ...)`?",
              "answer": "**Jump validity:** \n*   The duplicate might be at an index *before* our current `left` pointer (outside window). \n*   We must never move `left` backwards."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
          ]
        },
        {
          "id": "longest_repeating_character_replacement",
          "name": "Longest Repeating Character Replacement",
          "estimatedHours": 4,
          "description": "Maximize the length of a repeating character substring",
          "practiceQuestions": [
            {
              "name": "Longest Repeating Character Replacement",
              "slug": "longest-repeating-character-replacement",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-repeating-character-replacement/"
            }
          ],
          "learningTip": [
            "**Condition:** `WindowSize - MaxCharCount <= k`.",
            "**Expand:** Add char to window using `count[]`. Update `maxFreq`.",
            "**Shrink:** If condition fails, increment `left`, decrement `count[left]`. No need to update `maxFreq` (see trick).",
            "**Result:** Max window size found."
          ],
          "mustNotMiss": [
            "**Optimization:** We don't need to decrement `maxFreq` when shrinking. We only care if we find a NEW `maxFreq` that allows a larger window.",
            "**Window:** size is `right - left + 1`.",
            "**Complexity:** O(N) - no inner loops or map scans."
          ],
          "interviewQuestions": [
            {
              "question": "What if k = 0?",
              "answer": "**Longest Consecutive:** \n*   Problem reduces to finding the longest substring of a single repeating character. \n*   Like 'AAABBB' -> max is 3."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-repeating-character-replacement/"
          ]
        },
        {
          "id": "permutation_in_string",
          "name": "Permutation in String",
          "estimatedHours": 3,
          "description": "Check if one string contains a permutation of another",
          "practiceQuestions": [
            {
              "name": "Permutation in String",
              "slug": "permutation-in-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutation-in-string/"
            },
            {
              "name": "Minimum Window Substring",
              "slug": "minimum-window-substring",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimum-window-substring/"
            }
          ],
          "learningTip": [
            "**Fixed Window:** Size `len(s1)`.",
            "**Matches:** Use an array `count[26]`. Increment for s2, decrement for s1.",
            "**Check:** If all counts are zero (or matches == 26), permutation found."
          ],
          "mustNotMiss": [
            "**Optimization:** Instead of checking full array each time, maintain a `matches` counter.",
            "**Slide:** `Add right char, Remove left char on window slide`.",
            "**Complexity:** O(N)."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle general Unicode?",
              "answer": "**HashMap:** \n*   Array[26] is for lowercase English. \n*   For Unicode, use a HashMap to store frequencies."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/permutation-in-string/"
          ]
        },
        {
          "id": "sliding_window_maximum",
          "name": "Sliding Window Maximum",
          "estimatedHours": 3,
          "description": "Find the max value in every window of size k",
          "practiceQuestions": [
            {
              "name": "Sliding Window Maximum",
              "slug": "sliding-window-maximum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-maximum/"
            }
          ],
          "learningTip": [
            "**Monotonic Deque:** Store **indices** of elements in decreasing order of their values.",
            "**Front:** `deque[0]` is always the index of the max element in current window.",
            "**Maintain:** When moving right, pop elements from back that are smaller than current (useless). Remove elements from front if they are out of window."
          ],
          "mustNotMiss": [
            "**Loop:** `for (i = 0 to n)`.",
            "**Pop Back:** `while (dq && nums[dq.back] < nums[i]) dq.pop()`.",
            "**Push:** `dq.push(i)`.",
            "**Pop Front:** `if (dq.front == i - k) dq.shift()`.",
            "**Result:** `if (i >= k - 1) ans.push(nums[dq.front])`."
          ],
          "interviewQuestions": [
            {
              "question": "Why store indices and not values?",
              "answer": "**Window Tracking:** \n*   We need to know when an element slides out of the window (`i - k`). \n*   Indices allow us to calculate age; values do not."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/sliding-window-maximum/"
          ]
        }
      ]
    },
    {
      "id": "binary_tree",
      "name": "Binary Tree",
      "tier": 3,
      "estimatedHours": 34,
      "topics": [
        {
          "id": "introduction_trees",
          "name": "Introduction to Trees",
          "estimatedHours": 2.5,
          "description": "Understand what trees are and their core properties",
          "learningTip": [
            "**Leap of Faith:** Assume `recursive(node.left)` and `recursive(node.right)` just work. Then combine results.",
            "**Base Case:** Always check `if (!node) return`.",
            "**Visual:** Tree is a recursive data structure. Solution is usually a recursive function."
          ],
          "mustNotMiss": [
            "**Definition:** Binary Tree = Root + Left Subtree + Right Subtree.",
            "**Properties:** Max nodes at level `i` is `2^i`. Height is `log N` (balanced) to `N` (skewed).",
            "**Space:** Recursion uses stack space O(H)."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between Binary Tree and BST?",
              "answer": "**Ordering:** \n*   Binary Tree: No specific order. \n*   BST: left < root < right for ALL nodes."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/data-structure-tree/"
          ]
        },
        {
          "id": "binary_tree_traversals_explained",
          "name": "Binary Tree - Traversals Explained",
          "estimatedHours": 2.5,
          "description": "Explore preorder, inorder, and postorder tree traversals",
          "learningTip": [
            "**Pre (Root First):** Useful for cloning/serialization.",
            "**In (Root Middle):** Sorted order for BSTs.",
            "**Post (Root Last):** Useful for deletion (delete children first) or bottom-up calculations (height)."
          ],
          "mustNotMiss": [
            "**Pre:** `Root -> Left -> Right`.",
            "**In:** `Left -> Root -> Right`.",
            "**Post:** `Left -> Right -> Root`."
          ],
          "interviewQuestions": [
            {
              "question": "Can you reconstruct a tree from one traversal?",
              "answer": "**No.** \n*   You generally need Inorder + Preorder OR Inorder + Postorder to uniquely identify a tree. \n*   (Unless it's a BST or serialized with null markers)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/"
          ]
        },
        {
          "id": "preorder_traversal_recursive",
          "name": "Preorder Traversal - Recursive Approach",
          "estimatedHours": 3,
          "description": "Perform preorder traversal using recursion",
          "practiceQuestions": [
            {
              "name": "Binary Tree Preorder Traversal",
              "slug": "binary-tree-preorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-preorder-traversal/"
            }
          ],
          "learningTip": [
            "**Order:** `Root -> Left -> Right`.",
            "**Action:** Process current node BEFORE recursive calls.",
            "**Context:** 'Top-down' processing."
          ],
          "mustNotMiss": [
            "**Code:** `res.push(root.val)`. `dfs(root.left)`. `dfs(root.right)`.",
            "**One-Liner:** `return root ? [root.val, ...pre(root.left), ...pre(root.right)] : []` (inefficient spread, but conceptual)."
          ],
          "interviewQuestions": [
            {
              "question": "Time and Space Complexity?",
              "answer": "**Time:** O(N) (visit every node). \n**Space:** O(H) (call stack height, worst case O(N))."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-preorder-traversal/"
          ]
        },
        {
          "id": "inorder_postorder_recursive",
          "name": "Inorder & PostOrder - Recursive Approach",
          "estimatedHours": 1,
          "description": "Implement inorder and postorder recursively",
          "practiceQuestions": [
            {
              "name": "Binary Tree Inorder Traversal",
              "slug": "binary-tree-inorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
            },
            {
              "name": "Binary Tree Postorder Traversal",
              "slug": "binary-tree-postorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-postorder-traversal/"
            }
          ],
          "learningTip": [
            "**Inorder:** `Left -> Root -> Right`. (Leftmost processed first).",
            "**Postorder:** `Left -> Right -> Root`. (Root processed last).",
            "**BST:** Inorder on BST gives sorted array."
          ],
          "mustNotMiss": [
            "**In:** `dfs(root.left); print(root); dfs(root.right)`.",
            "**Post:** `dfs(root.left); dfs(root.right); print(root)`."
          ],
          "interviewQuestions": [
            {
              "question": "When to use Postorder?",
              "answer": "**Dependency Resolution:** \n*   When information from children is needed to process the parent (e.g., calculating height, deleting a tree)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-inorder-traversal/"
          ]
        },
        {
          "id": "preorder_traversal_iterative",
          "name": "Preorder Traversal - Iterative Approach",
          "estimatedHours": 2.5,
          "description": "Use a stack to perform preorder traversal iteratively",
          "learningTip": [
            "**Stack:** Simulates recursion stack.",
            "**LIFO:** Push Right THEN Left. Why? So Left pops first.",
            "**Order:** Pop -> Process -> Push Children."
          ],
          "mustNotMiss": [
            "**Stack:** `st = [root]`.",
            "**Loop:** `while st not empty`.",
            "**Pop:** `curr = st.pop()`. Add `curr` to result.",
            "**Push:** `if curr.right push right`. `if curr.left push left`."
          ],
          "interviewQuestions": [
            {
              "question": "Why push Right then Left?",
              "answer": "**Stack Property:** \n*   Stack is LIFO (Last-In First-Out). \n*   We want Left processed first, so it must be the *last* one pushed."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-preorder-traversal/"
          ]
        },
        {
          "id": "inorder_traversal_iterative",
          "name": "Inorder Traversal - Iterative Approach",
          "estimatedHours": 2.5,
          "description": "Inorder traversal using a stack instead of recursion",
          "learningTip": [
            "**Drill Left:** Keep pushing nodes and going `.left` until null.",
            "**Pop:** This returns us to the parent (root of subtree).",
            "**Process:** Add to result.",
            "**Switch Right:** Go `.right` and repeat drilling."
          ],
          "mustNotMiss": [
            "**Outer:** `while (curr || stack.length)`.",
            "**Inner:** `while (curr) { stack.push(curr); curr = curr.left; }`.",
            "**Pop:** `curr = stack.pop()`. Add to result.",
            "**Right:** `curr = curr.right`."
          ],
          "interviewQuestions": [
            {
              "question": "Is iterative faster than recursive?",
              "answer": "**Ideally No.** \n*   Complexity is same O(N). \n*   Iterative avoids stack overflow for very deep trees relative to system stack size, but uses heap memory for its own stack."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-inorder-traversal/"
          ]
        },
        {
          "id": "postorder_iterative_two_stacks",
          "name": "Postorder - Iterative Approach - 2 Stacks",
          "estimatedHours": 2.5,
          "description": "Use two stacks for iterative postorder traversal",
          "learningTip": [
            "**Trick:** Preorder is `Root -> Left -> Right`.",
            "**Reverse:** `Root -> Right -> Left` is easy to do (just swap push order).",
            "**Postorder:** `Left -> Right -> Root`. This is exactly Reverse of (Root -> Right -> Left).",
            "**Two Stacks:** One for traversal, one for result (reversal)."
          ],
          "mustNotMiss": [
            "**S1:** Loop like Preorder, but push Left then Right.",
            "**S2:** When popping from S1, push to S2.",
            "**Result:** Pop all from S2."
          ],
          "interviewQuestions": [
            {
              "question": "Can we do it with one stack?",
              "answer": "**Yes.** \n*   But it's much harder logic (tracking 'last visited' node). \n*   Two stacks is a clever trick acceptable in interviews unless strict space constraints."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-postorder-traversal/"
          ]
        },
        {
          "id": "postorder_iterative_one_stack",
          "name": "Postorder - Iterative Approach - One Stack",
          "estimatedHours": 3,
          "description": "Efficient postorder traversal using just one stack",
          "learningTip": [
            "**Difficulty:** Hardest iterative traversal.",
            "**Logic:** We can't pop parent until right child is done. We need to peek.",
            "**State:** Track `lastVisited` to know if we returned from right child."
          ],
          "mustNotMiss": [
            "**Check:** `peek = stack.peek()`.",
            "**Leaf/Done:** If `(!peek.right && !peek.left)` OR `(peek.right == lastVisited || peek.left == lastVisited)` -> Pop and Process.",
            "**Else:** Push children (Right then Left)."
          ],
          "interviewQuestions": [
            {
              "question": "Detailed logic flow?",
              "answer": "**Wait:** \n*   Only process node if leaf OR coming back from children. \n*   Otherwise, push children to stack to be processed."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/binary-tree-postorder-traversal/"
          ]
        },
        {
          "id": "dfs_bfs_binary_tree",
          "name": "DFS and BFS in Binary Tree",
          "estimatedHours": 2.5,
          "description": "Understand DFS vs BFS in binary trees",
          "learningTip": [
            "**DFS => Stack/Recursion.** Deep dive. Good for path finding, verifying structure.",
            "**BFS => Queue.** Level by level. Good for shortest path (unweighted), levels, proximity."
          ],
          "mustNotMiss": [
            "**DFS:** Pre/In/Post are all DFS.",
            "**BFS:** Level Order.",
            "**Complexity:** Both are O(N) time and O(N) space (worst case)."
          ],
          "interviewQuestions": [
            {
              "question": "When to use BFS over DFS?",
              "answer": "**Shortest Path:** \n*   BFS guarantees shortest path in unweighted graphs/trees. \n*   DFS might go down a deep wrong path 1000 nodes before backtracking."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-queue/"
          ]
        },
        {
          "id": "pattern_tree_bfs",
          "name": "Pattern: Tree Breadth First Search",
          "tier": 3,
          "estimatedHours": 6,
          "topics": [
            {
              "id": "level_order_traversal",
              "name": "Binary Tree Level Order Traversal",
              "estimatedHours": 1,
              "description": "Traverse the tree level by level",
              "practiceQuestions": [
                {
                  "name": "Binary Tree Level Order Traversal",
                  "slug": "binary-tree-level-order-traversal",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
                }
              ],
              "learningTip": [
                "**Queue:** Use a Queue to store nodes for processing.",
                "**Level Size:** At start of each level loop, capture `size = queue.length`. Process exactly that many nodes.",
                "**Children:** Push left and right children of current node to queue."
              ],
              "mustNotMiss": [
                "**Loop:** `while queue not empty`.",
                "**Inner Loop:** `for i from 0 to size`.",
                "**Result:** Add current level values to result array."
              ]
            },
            {
              "id": "reverse_level_order",
              "name": "Binary Tree Level Order Traversal II",
              "estimatedHours": 1,
              "description": "Traverse level by level from bottom to top",
              "practiceQuestions": [
                {
                  "name": "Binary Tree Level Order Traversal II",
                  "slug": "binary-tree-level-order-traversal-ii",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/"
                }
              ],
              "learningTip": [
                "**Standard BFS:** Perform standard Level Order Traversal.",
                "**Reverse:** Instead of appending levels to end of result, prepend them (unshift) or reverse the final result.",
                "**DFS Alternative:** DFS tracking depth, adding to `result[depth]`, then reverse result."
              ],
              "mustNotMiss": [
                "**Efficiency:** `result.unshift` is O(N). Building normally then `result.reverse()` is usually better."
              ]
            },
            {
              "id": "zigzag_level_order",
              "name": "Zigzag Level Order Traversal",
              "estimatedHours": 1,
              "description": "Traverse level by level in zigzag order",
              "practiceQuestions": [
                {
                  "name": "Binary Tree Zigzag Level Order Traversal",
                  "slug": "binary-tree-zigzag-level-order-traversal",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
                }
              ],
              "learningTip": [
                "**Deque:** Use a double-ended queue or standard queue + flag.",
                "**Flag:** `leftToRight = true`. Toggle at end of each level.",
                "**Insert:** If `!leftToRight`, insert at FRONT of level's temp array (or reverse it)."
              ],
              "mustNotMiss": [
                "**Logic:** Ensure children are always pushed Left then Right to Queue regardless of print order."
              ]
            },
            {
              "id": "populating_next_right_pointers",
              "name": "Populating Next Right Pointers",
              "estimatedHours": 1.5,
              "description": "Connect nodes at the same level",
              "practiceQuestions": [
                {
                  "name": "Populating Next Right Pointers in Each Node",
                  "slug": "populating-next-right-pointers-in-each-node",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
                }
              ],
              "learningTip": [
                "**BFS:** Standard Level Order. Iterate through level, linking `node[i].next = node[i+1]`.",
                "**O(1) Space:** Use `next` pointers of *current* level to traverse and link *next* level.",
                "**Key:** `head.left.next = head.right`. `head.right.next = head.next.left` (if head.next exists)."
              ],
              "mustNotMiss": [
                "**Constraint:** If perfect binary tree, logic is simpler."
              ]
            }
          ],
          "practiceQuestions": [
            {
              "name": "Binary Tree Level Order Traversal",
              "slug": "binary-tree-level-order-traversal",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
            },
            {
              "name": "Binary Tree Right Side View",
              "slug": "binary-tree-right-side-view",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-right-side-view/"
            }
          ]
        },
        {
          "id": "pattern_tree_dfs",
          "name": "Pattern: Tree Depth First Search",
          "tier": 3,
          "estimatedHours": 6,
          "topics": [
            {
              "id": "path_sum",
              "name": "Path Sum",
              "estimatedHours": 1,
              "description": "Determine if the tree has a root-to-leaf path summing to target",
              "practiceQuestions": [
                {
                  "name": "Path Sum",
                  "slug": "path-sum",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/path-sum/"
                }
              ],
              "learningTip": [
                "**Recursion:** `hasPathSum(root, target)`. Check `target - root.val` for children.",
                "**Leaf Check:** Must be a LEAF (no children). `!root.left && !root.right && target == root.val`.",
                "**Base Case:** `if (!root) return false`."
              ],
              "mustNotMiss": [
                "**Short Circuit:** Return `dfs(left) || dfs(right)`."
              ]
            },
            {
              "id": "path_sum_ii",
              "name": "Path Sum II",
              "estimatedHours": 1.5,
              "description": "Find all root-to-leaf paths where each path's sum equals target",
              "practiceQuestions": [
                {
                  "name": "Path Sum II",
                  "slug": "path-sum-ii",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/path-sum-ii/"
                }
              ],
              "learningTip": [
                "**Backtracking:** Maintain `currentPath`. Push node. Recurse. Pop node.",
                "**Copy:** When finding a valid path, push a COPY (e.g. `[...currentPath]`) to results.",
                "**State:** `dfs(node, remainingSum, currentPath)`."
              ],
              "mustNotMiss": [
                "**Leaf:** Check validity only at leaves."
              ]
            },
            {
              "id": "path_sum_iii",
              "name": "Path Sum III",
              "estimatedHours": 2,
              "description": "Find the number of paths that sum to a given value (starting anywhere, going downwards)",
              "practiceQuestions": [
                {
                  "name": "Path Sum III",
                  "slug": "path-sum-iii",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/path-sum-iii/"
                }
              ],
              "learningTip": [
                "**Double Recursion:** `pathSum(root) = countPaths(root) + pathSum(root.left) + pathSum(root.right)`.",
                "**Optimization:** Use Prefix Sum HashMap (O(N)). Store `currentSum` frequencies.",
                "**Logic:** `count += map.get(currSum - target)`."
              ],
              "mustNotMiss": [
                "**Backtrack:** Remove `currentSum` from map after visiting children."
              ]
            },
            {
              "id": "lowest_common_ancestor",
              "name": "Lowest Common Ancestor",
              "estimatedHours": 2,
              "description": "Find the lowest common ancestor of two nodes",
              "practiceQuestions": [
                {
                  "name": "Lowest Common Ancestor of a Binary Tree",
                  "slug": "lowest-common-ancestor-of-a-binary-tree",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"
                }
              ],
              "learningTip": [
                "**Split Point:** LCA is the node where `p` and `q` diverge.",
                "**Recursive:** If found `p` or `q`, return it. If both children return non-null, current is LCA.",
                "**Base:** `if (!root || root == p || root == q) return root`."
              ],
              "mustNotMiss": [
                "**Result:** `left = dfs(left)`, `right = dfs(right)`. If `left && right` return `root`. Else return `left || right`."
              ]
            },
            {
              "id": "maximum_depth_binary_tree",
              "name": "Maximum Depth of Binary Tree",
              "estimatedHours": 1,
              "description": "Find the maximum depth (height) of a binary tree",
              "practiceQuestions": [
                {
                  "name": "Maximum Depth of Binary Tree",
                  "slug": "maximum-depth-of-binary-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
                }
              ],
              "learningTip": [
                "**Recursive:** `depth = 1 + max(left, right)`. Base: `0`.",
                "**Iterative:** BFS level count.",
                "**Height vs Depth:** Height is bottom-up (leaves are 0 or 1). Depth is top-down (root is 0 or 1)."
              ],
              "mustNotMiss": [
                "**Code:** `return root ? 1 + Math.max(maxDepth(root.left), maxDepth(root.right)) : 0;`.",
                "**Complexity:** O(N) Time.",
                "**Skewed:** In worst case (line), recursion stack is O(N)."
              ],
              "interviewQuestions": [
                {
                  "question": "How to find min depth?",
                  "answer": "**Careful:** \n*   It's NOT `1 + min(left, right)` if one child is null. \n*   If one child is null, you MUST takes the other path. (Leaf must have NO children)."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
              ]
            },
            {
              "id": "symmetric_tree_recursive",
              "name": "Symmetric Tree - Recursive Approach",
              "estimatedHours": 1,
              "description": "Check if a binary tree is symmetric using recursion",
              "practiceQuestions": [
                {
                  "name": "Symmetric Tree",
                  "slug": "symmetric-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/symmetric-tree/"
                }
              ],
              "learningTip": [
                "**Mirror Property:** `Left.left == Right.right` AND `Left.right == Right.left`.",
                "**Helper:** Need a helper `isMirror(t1, t2)`.",
                "**Root:** `isMirror(root.left, root.right)`."
              ],
              "mustNotMiss": [
                "**Base:** `if (!t1 && !t2) return true`. `if (!t1 || !t2) return false`.",
                "**Check:** `t1.val == t2.val`.",
                "**Recurse:** `isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left)`."
              ],
              "interviewQuestions": [
                {
                  "question": "Time complexity?",
                  "answer": "**O(N).** \n*   We visit every node pair once."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/symmetric-tree/"
              ]
            },
            {
              "id": "symmetric_tree_iterative",
              "name": "Symmetric Tree - Iterative Approach",
              "estimatedHours": 1,
              "description": "Check symmetry in a binary tree using BFS",
              "learningTip": [
                "**Queue Pairs:** Push pairs that *should* be equal.",
                "**Init:** `q.push(root.left, root.right)`.",
                "**Loop:** Pop `t1, t2`. Check values. Push `(t1.left, t2.right)` and `(t1.right, t2.left)`."
              ],
              "mustNotMiss": [
                "**Check:** `if (!t1 && !t2) continue`. `if (!t1 || !t2 || t1.val != t2.val) return false`.",
                "**Order:** Crucial to push 'outer' pair then 'inner' pair (or vice versa, just consistent)."
              ],
              "interviewQuestions": [
                {
                  "question": "Can we use stack?",
                  "answer": "**Yes.** \n*   Logic is exactly same (DFS vs BFS), just order of processing changes."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/symmetric-tree/"
              ]
            },
            {
              "id": "invert_binary_tree",
              "name": "Invert a Binary Tree",
              "estimatedHours": 1,
              "description": "Flip a binary tree by swapping left and right nodes",
              "practiceQuestions": [
                {
                  "name": "Invert Binary Tree",
                  "slug": "invert-binary-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/invert-binary-tree/"
                }
              ],
              "learningTip": [
                "**Concept:** Swap left and right children of EVERY node.",
                "**Traversal:** Can be Preorder, Postorder, BFS.",
                "**Inorder?** Tricky (you might swap back if not careful)."
              ],
              "mustNotMiss": [
                "**Recursive:** `temp = root.left; root.left = invert(root.right); root.right = invert(temp)`.",
                "**Iterative (BFS):** Pop node. Swap its children. Push children to queue."
              ],
              "interviewQuestions": [
                {
                  "question": "Does it change structure?",
                  "answer": "**Yes.** \n*   It creates a mirror image of the original tree."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/invert-binary-tree/"
              ]
            },
            {
              "id": "same_tree",
              "name": "Same Tree",
              "estimatedHours": 1,
              "description": "Check if two binary trees are exactly the same",
              "practiceQuestions": [
                {
                  "name": "Same Tree",
                  "slug": "same-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/same-tree/"
                }
              ],
              "learningTip": [
                "**Identity:** Same structure AND same values.",
                "**Traversal:** Traverse both simultaneously.",
                "**Check:** `p.val == q.val` at every step."
              ],
              "mustNotMiss": [
                "**Base:** `if (!p && !q) return true`. `if (!p || !q) return false`.",
                "**Recurse:** `p.val == q.val && isSame(p.left, q.left) && isSame(p.right, q.right)`."
              ],
              "interviewQuestions": [
                {
                  "question": "Iterative approach?",
                  "answer": "**Double Queue:** \n*   Use one queue for P and one for Q (or one queue of pairs). \n*   Process in lock-step."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/same-tree/"
              ]
            },
            {
              "id": "balanced_binary_tree",
              "name": "Balanced Binary Tree",
              "estimatedHours": 1,
              "description": "Check if a binary tree is height-balanced",
              "practiceQuestions": [
                {
                  "name": "Balanced Binary Tree",
                  "slug": "balanced-binary-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/balanced-binary-tree/"
                }
              ],
              "learningTip": [
                "**Definition:** Height of left subtree and right subtree differ by at most 1.",
                "**Recursion:** Need to return height, but ALSO check balance.",
                "**Sentinel:** Return `-1` (or special value) if unbalanced, to bubble up failure immediately."
              ],
              "mustNotMiss": [
                "**Helper:** `dfs(node)` returns height.",
                "**Check:** `left = dfs(node.left)`. `if (left == -1) return -1`.",
                "**Check:** `right = dfs(node.right)`. `if (right == -1) return -1`.",
                "**Balance:** `if (abs(left - right) > 1) return -1`. `return max(left,right) + 1`."
              ],
              "interviewQuestions": [
                {
                  "question": "Time complexity?",
                  "answer": "**O(N).** \n*   The bottom-up approach visits every node once. \n*   (Top-down approach calling height() at every node is O(N^2))."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/balanced-binary-tree/"
              ]
            },
            {
              "id": "diameter_binary_tree",
              "name": "Diameter of a Binary Tree",
              "estimatedHours": 2.5,
              "description": "Find the longest path between any two nodes",
              "practiceQuestions": [
                {
                  "name": "Diameter of Binary Tree",
                  "slug": "diameter-of-binary-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/diameter-of-binary-tree/"
                }
              ],
              "learningTip": [
                "**Path:** Longest path between ANY two nodes.",
                "**Through Root?** Not necessarily.",
                "**Formula:** At any node, longest path passing through it = `Height(Left) + Height(Right)`."
              ],
              "mustNotMiss": [
                "**Global Max:** Maintain `maxDia`.",
                "**Postorder:** Compute height of left, height of right.",
                "**Update:** `maxDia = max(maxDia, left + right)`.",
                "**Return:** `max(left, right) + 1` (Height for parent)."
              ],
              "interviewQuestions": [
                {
                  "question": "Is diameter always passing through root?",
                  "answer": "**No.** \n*   It could be entirely in the left or right subtree."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/diameter-of-binary-tree/"
              ]
            },
            {
              "id": "subtree_another_tree",
              "name": "Subtree of another Tree",
              "estimatedHours": 3,
              "description": "Check if one binary tree is a subtree of another",
              "practiceQuestions": [
                {
                  "name": "Subtree of Another Tree",
                  "slug": "subtree-of-another-tree",
                  "difficulty": "Easy",
                  "link": "https://leetcode.com/problems/subtree-of-another-tree/"
                }
              ],
              "learningTip": [
                "**Definition:** A subtree must match the structure and values completely from that node down.",
                "**Reuse:** Use `isSameTree` helper function.",
                "**Logic:** `isSameTree(root, subRoot) || isSubtree(root.left) || isSubtree(root.right)`."
              ],
              "mustNotMiss": [
                "**Nulls:** `if (!subRoot) return true`. `if (!root) return false`.",
                "**Match:** If `isSameTree(root, subRoot)` is true, return true.",
                "**Complexity:** O(N * M) because for every node in N we might check M nodes."
              ],
              "interviewQuestions": [
                {
                  "question": "Can we do O(N + M)?",
                  "answer": "**Merkle Hashing / Serialization:** \n*   Serialize both trees to strings (with null markers). \n*   Check if `subRootStr` is a substring of `rootStr` using KMP."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/subtree-of-another-tree/"
              ]
            },
            {
              "id": "binary_tree_right_side_view",
              "name": "Binary Tree Right Side View",
              "estimatedHours": 1,
              "description": "Print the nodes visible from the right side",
              "practiceQuestions": [
                {
                  "name": "Binary Tree Right Side View",
                  "slug": "binary-tree-right-side-view",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/binary-tree-right-side-view/"
                }
              ],
              "learningTip": [
                "**BFS:** The last element of each level is the right side view.",
                "**DFS:** Visit Right child BEFORE Left child (`Root -> Right -> Left`).",
                "**Capture:** If `currentDepth == result.length`, add node (it's the first one we see at this depth)."
              ],
              "mustNotMiss": [
                "**DFS Trick:** `if (depth == res.length) res.push(val)`. Then `dfs(right, d+1)`, `dfs(left, d+1)`.",
                "**BFS:** `res.push(level[level.length - 1])`.",
                "**Connectivity:** Don't just take right children. If right is null, we see the left child."
              ],
              "interviewQuestions": [
                {
                  "question": "Left Side View?",
                  "answer": "**Reverse Logic:** \n*   BFS: First element of level. \n*   DFS: Visit Left before Right."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/binary-tree-right-side-view/"
              ]
            },
            {
              "id": "count_good_nodes_binary_tree",
              "name": "Count Good Nodes in Binary Tree",
              "estimatedHours": 2.5,
              "description": "Count nodes that are greater than all previous nodes on the path",
              "practiceQuestions": [
                {
                  "name": "Count Good Nodes in Binary Tree",
                  "slug": "count-good-nodes-in-binary-tree",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/"
                }
              ],
              "learningTip": [
                "**Path Prop:** Pass `maxSoFar` down the recursion.",
                "**Good:** `if (node.val >= maxSoFar)` -> Good Node. Update max.",
                "**Recurse:** `dfs(node.left, newMax) + dfs(node.right, newMax)`."
              ],
              "mustNotMiss": [
                "**Root:** Root is always good.",
                "**Arg:** `dfs(root, -Infinity)`.",
                "**Return:** `(good ? 1 : 0) + dfs(left) + dfs(right)`."
              ],
              "interviewQuestions": [
                {
                  "question": "Iterative approach?",
                  "answer": "**Stack:** \n*   Store pairs `(node, maxSoFar)` in the stack/queue."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/count-good-nodes-in-binary-tree/"
              ]
            },
            {
              "id": "populating_next_right_pointers",
              "name": "Populating Next Right Pointers in Each Node",
              "estimatedHours": 1,
              "description": "Connect each node to its next right node in the same level",
              "practiceQuestions": [
                {
                  "name": "Populating Next Right Pointers in Each Node",
                  "slug": "populating-next-right-pointers-in-each-node",
                  "difficulty": "Medium",
                  "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
                }
              ],
              "learningTip": [
                "**Perfect Binary Tree:** We can use `node.left.next = node.right`.",
                "**Bridge:** `if (node.next) node.right.next = node.next.left`.",
                "**O(1) Space:** Use `next` pointers to traverse current level while building next level."
              ],
              "mustNotMiss": [
                "**Level 0:** Root.",
                "**Traversal:** `leftmost = root`. While `leftmost.left` exists.",
                "**Inner:** Iterate `head` across current level using `head.next`.",
                "**Link:** `head.left.next = head.right`. `if(head.next) head.right.next = head.next.left`."
              ],
              "interviewQuestions": [
                {
                  "question": "What if tree is not perfect?",
                  "answer": "**Dummy Head:** \n*   Maintain a 'dummmy' node for the next level. \n*   Traverse current level, appending children to the dummy's list."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
              ]
            },
            {
              "id": "binary_tree_maximum_path_sum",
              "name": "Binary Tree Maximum Path Sum",
              "estimatedHours": 2.5,
              "description": "Find the path in a tree with the maximum sum",
              "practiceQuestions": [
                {
                  "name": "Binary Tree Maximum Path Sum",
                  "slug": "binary-tree-maximum-path-sum",
                  "difficulty": "Hard",
                  "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
                }
              ],
              "learningTip": [
                "**Hard Problem:** Path can start and end anywhere.",
                "**Contribution:** A node can contribute `val + max(left, right)` to its parent.",
                "**Bridge:** A node can BE the curved path top: `val + left + right`. Update global max with this."
              ],
              "mustNotMiss": [
                "**Ignore Negatives:** If `leftSum < 0`, ignore it (take 0).",
                "**Global Update:** `maxSum = max(maxSum, left + right + node.val)`.",
                "**Return:** `node.val + max(left, right)`."
              ],
              "interviewQuestions": [
                {
                  "question": "Handle all negative numbers?",
                  "answer": "**Yes.** \n*   The generic logic `maxSum = max(maxSum, ...)` handles strictly negative trees by picking the single largest node (least negative)."
                }
              ],
              "resources": [
                "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
              ]
            }
          ],
          "practiceQuestions": [
            {
              "name": "Maximum Depth of Binary Tree",
              "slug": "maximum-depth-of-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
            },
            {
              "name": "Same Tree",
              "slug": "same-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/same-tree/"
            },
            {
              "name": "Invert Binary Tree",
              "slug": "invert-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/invert-binary-tree/"
            },
            {
              "name": "Subtree of Another Tree",
              "slug": "subtree-of-another-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/subtree-of-another-tree/"
            },
            {
              "name": "Count Good Nodes in Binary Tree",
              "slug": "count-good-nodes-in-binary-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/"
            },
            {
              "name": "Construct Binary Tree from Preorder and Inorder Traversal",
              "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
            },
            {
              "name": "Binary Tree Maximum Path Sum",
              "slug": "binary-tree-maximum-path-sum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
            }
          ]
        }
      ]
    },
    {
      "id": "binary_search_tree",
      "name": "Binary Search Tree",
      "tier": 3,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "binary_search_tree_introduction",
          "name": "Binary Search Tree - Introduction",
          "estimatedHours": 1,
          "description": "Learn the basics of Binary Search Trees",
          "learningTip": [
            "**Property:** `Left.val < Root.val < Right.val` for ALL nodes.",
            "**Inorder:** Inorder traversal of a BST gives elements in purely **sorted ascending order**.",
            "**Search:** Similar to Binary Search in an array."
          ],
          "mustNotMiss": [
            "**Complexity:** Search/Insert/Delete is O(H).",
            "**H:** Height is O(log N) if balanced, O(N) if skewed.",
            "**Balancing:** AVL Trees or Red-Black Trees automatically keep H = log N."
          ],
          "interviewQuestions": [
            {
              "question": "BST vs Hash Table?",
              "answer": "**Trade-off:** \n*   Hash Table: O(1) search/insert, but unordered. \n*   BST: O(log n) search/insert, but preserves order and supports range queries and 'next smallest' operations."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/"
          ]
        },
        {
          "id": "valid_binary_search_tree",
          "name": "Valid Binary Search Tree",
          "estimatedHours": 2.5,
          "description": "Check if a tree is a valid BST",
          "practiceQuestions": [
            {
              "name": "Validate Binary Search Tree",
              "slug": "validate-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/validate-binary-search-tree/"
            }
          ],
          "learningTip": [
            "**Common Trap:** Checking only `left.val < root.val` and `right.val > root.val` is WRONG.",
            "**Reason:** A node in the right subtree could be smaller than the root (e.g., Root=10, Right=20, Right.Left=5).",
            "**Solution:** Validate range `(min, max)` passed down recursively."
          ],
          "mustNotMiss": [
            "**Range:** `isValid(node, min, max)`.",
            "**Check:** `if (node.val <= min || node.val >= max) return false`.",
            "**Recurse:** `isValid(left, min, node.val) && isValid(right, node.val, max)`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use Inorder Traversal?",
              "answer": "**Yes.** \n*   Perform Inorder traversal. \n*   Check if the resulting values are strictly increasing."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/validate-binary-search-tree/"
          ]
        },
        {
          "id": "search_in_bst",
          "name": "Search in a BST",
          "estimatedHours": 1,
          "description": "Search for a value in a Binary Search Tree",
          "practiceQuestions": [
            {
              "name": "Search in a Binary Search Tree",
              "slug": "search-in-a-binary-search-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/search-in-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "**Logic:** Binary Search.",
            "**Left:** If target < root, go Left.",
            "**Right:** If target > root, go Right.",
            "**Found:** If target == root, return root."
          ],
          "mustNotMiss": [
            "**Iterative:** `while(root && root.val != val) { root = val < root.val ? root.left : root.right } return root`.",
            "**Space:** Iterative is O(1) space. Recursive is O(H) stack space."
          ],
          "interviewQuestions": [
            {
              "question": "Search in Generic Binary Tree?",
              "answer": "**O(N).** \n*   Without BST property, we might have to visit every node."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/search-in-a-binary-search-tree/"
          ]
        },
        {
          "id": "insert_into_bst",
          "name": "Insert into a BST",
          "estimatedHours": 1,
          "description": "Insert a new node in a BST",
          "practiceQuestions": [
            {
              "name": "Insert into a Binary Search Tree",
              "slug": "insert-into-a-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/insert-into-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "**Leaf:** You can always find a spot to insert a new value as a **leaf**.",
            "**Traverse:** Go left/right until you hit null. That's your spot.",
            "**Return:** Return the root to maintain tree structure (for recursive)."
          ],
          "mustNotMiss": [
            "**Recursive:** `if (!root) return new Node(val)`. `if (val < root.val) root.left = insert...`.",
            "**Iterative:** Keep `prev` pointer. Link `prev.left` or `prev.right` to new node."
          ],
          "interviewQuestions": [
            {
              "question": "Worst case insertion order?",
              "answer": "**Sorted Data.** \n*   Inserting 1, 2, 3, 4, 5 creates a skewed tree (linked list) with height N."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/insert-into-a-binary-search-tree/"
          ]
        },
        {
          "id": "kth_smallest_element",
          "name": "Kth Smallest Element",
          "estimatedHours": 1,
          "description": "Find the kth smallest element in BST",
          "practiceQuestions": [
            {
              "name": "Kth Smallest Element in a BST",
              "slug": "kth-smallest-element-in-a-bst",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
            }
          ],
          "learningTip": [
            "**Property:** Inorder traversal of BST gives 1st, 2nd, 3rd... Kth smallest elements.",
            "**Stop Early:** We don't need full traversal. Stop when we visit the Kth node."
          ],
          "mustNotMiss": [
            "**Iterative Stack:** Go left. Pop. Decrement k. `if (k == 0) return val`. Go right.",
            "**Complexity:** O(H + K). We go down depth H, then index K elements."
          ],
          "interviewQuestions": [
            {
              "question": "Optimize for frequent calls?",
              "answer": "**Augmented Tree:** \n*   Store `nodeCount` in every node (nodes in left subtree + 1). \n*   Allows finding Kth element in O(H) time like binary search."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
          ]
        },
        {
          "id": "lowest_common_ancestor_bst",
          "name": "Lowest Common Ancestor of a BST",
          "estimatedHours": 1,
          "description": "Find the lowest common ancestor in a Binary Search Tree",
          "practiceQuestions": [
            {
              "name": "Lowest Common Ancestor of a Binary Search Tree",
              "slug": "lowest-common-ancestor-of-a-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "**Better than Binary Tree LCA:** We can use the values to guide us.",
            "**Split Point:** The LCA is the first node where `p` and `q` diverge (one is on left, one is on right, or one is the current node)."
          ],
          "mustNotMiss": [
            "**Logic:** `if (p, q < root) go left`. `if (p, q > root) go right`.",
            "**Else:** Return root (Found split point).",
            "**Complexity:** O(H) time, O(1) space (iterative)."
          ],
          "interviewQuestions": [
            {
              "question": "Iterative Implementation?",
              "answer": "**Simple:** \n*   `while(true) { if (val > p && val > q) root = root.left; else if ... root = root.right; else break; }`"
            }
          ],
          "resources": [
            "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
          ]
        }
      ]
    },
    {
      "id": "heap_priority_queue",
      "name": "Heap / Priority Queue",
      "tier": 3,
      "estimatedHours": 25,
      "topics": [
        {
          "id": "introduction_heaps",
          "name": "Introduction to Heaps",
          "estimatedHours": 2.5,
          "description": "Understand the fundamentals of Heaps",
          "learningTip": [
            "**Structure:** Complete Binary Tree (filled top-down, left-to-right).",
            "**Property:** Min-Heap: Parent <= Children. Max-Heap: Parent >= Children.",
            "**Storage:** Usually stored in an Array."
          ],
          "mustNotMiss": [
            "**Indices:** For node `i`: Parent=`floor((i-1)/2)`, Left=`2i+1`, Right=`2i+2` (0-based).",
            "**Root:** Min/Max element is always at `arr[0]` (O(1) access)."
          ],
          "interviewQuestions": [
            {
              "question": "Heap vs BST?",
              "answer": "**Access:** \n*   Heap: Find Min/Max is O(1). Find arbitrary is O(N). \n*   BST: Find Min/Max is O(log N). Find arbitrary is O(log N)."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/heap/"
          ]
        },
        {
          "id": "creating_heap",
          "name": "Creating a Heap",
          "estimatedHours": 3,
          "description": "Learn how to build a heap from an array",
          "learningTip": [
            "**Heapify:** Process non-leaf nodes in reverse order (bottom-up).",
            "**Direction:** Start from last parent `(n/2 - 1)` down to `0`.",
            "**Action:** Call `siftDown` (heapify) on each."
          ],
          "mustNotMiss": [
            "**Complexity:** Building a heap is **O(N)**, NOT O(N log N).",
            "**Math:** Most nodes are at the bottom and travel short distances. The sum converges to linear time."
          ],
          "interviewQuestions": [
            {
              "question": "Can we build O(N) by sifting up?",
              "answer": "**No.** \n*   Sifting up (repeated insertion) takes O(N log N). \n*   Sifting down (bottom-up build) takes O(N)."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/"
          ]
        },
        {
          "id": "inserting_node_heap",
          "name": "Inserting a node in Heap",
          "estimatedHours": 3,
          "description": "Insert an element into a heap and maintain the heap property",
          "learningTip": [
            "**End:** Add element to the very end of the array (bottom-left most spot).",
            "**Bubble Up:** Compare with parent. If violated (child < parent in MinHeap), swap.",
            "**Repeat:** Keep swapping up until root or valid."
          ],
          "mustNotMiss": [
            "**Code:** `arr.push(val); i = arr.length-1; while(i > 0) { p = floor((i-1)/2); if(arr[p] > arr[i]) { swap; i = p; } else break; }`.",
            "**Complexity:** O(log N)."
          ],
          "interviewQuestions": [
            {
              "question": "Worst case insertion?",
              "answer": "**O(log N).** \n*   Element travels from leaf to root."
            }
          ],
          "resources": [
            "https://visualgo.net/en/heap"
          ]
        },
        {
          "id": "extracting_values_heap_heapify_down",
          "name": "Extracting Values in Heap & HeapifyDown",
          "estimatedHours": 3,
          "description": "Remove the root and restore heap order",
          "learningTip": [
            "**Swap:** Swap Root (index 0) with Last element.",
            "**Pop:** Remove the last element (which was the root).",
            "**Bubble Down:** Compare new Root with children. Swap with *smaller* child (MinHeap). Repeat."
          ],
          "mustNotMiss": [
            "**Trick:** Always swap with the 'target' child (smallest in MinHeap, largest in MaxHeap) to protect property.",
            "**Complexity:** O(log N)."
          ],
          "interviewQuestions": [
            {
              "question": "Why swap with last?",
              "answer": "**Completeness:** \n*   Deleting root directly leaves a hole. \n*   Moving the last node fills the hole and preserves the 'Complete Binary Tree' shape."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/kth-largest-element-in-an-array/"
          ],
          "practiceQuestions": [
            {
              "name": "Last Stone Weight",
              "slug": "last-stone-weight",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/last-stone-weight/"
            }
          ]
        },
        {
          "id": "heap_sort_algorithm",
          "name": "Heap Sort Algorithm",
          "estimatedHours": 3,
          "description": "Understand the Heap Sort algorithm step-by-step",
          "practiceQuestions": [
            {
              "name": "Sort an Array",
              "slug": "sort-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-an-array/"
            }
          ],
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "heap_sort_code",
          "name": "Heap Sort Code",
          "estimatedHours": 2.5,
          "description": "Implement Heap Sort in code",
          "learningTip": [
            "**Two Phases:** 1. Build Heap (O(N)). 2. Sort (O(N log N)).",
            "**Phase 2:** Swap `arr[0]` with `arr[end]`. Decrement `end`. Heapify `arr[0]`."
          ],
          "mustNotMiss": [
            "**Logic:** `for (i = n/2 - 1; i >= 0; i--) heapify(n, i)`.",
            "**Loop:** `for (i = n - 1; i > 0; i--) { swap(0, i); heapify(i, 0); }`.",
            "**Note:** Pass 'size' to heapify so it ignores already sorted elements at end."
          ],
          "interviewQuestions": [
            {
              "question": "Is Heap Sort stable?",
              "answer": "**No.** \n*   The structure and swaps destroy original relative order of equal elements."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/sort-an-array/"
          ]
        },
        {
          "id": "heap_sort_dive_deep",
          "name": "Heap Sort - Dive Deep",
          "estimatedHours": 2.5,
          "description": "Explore advanced insights into Heap Sort",
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "priority_queues_introduction",
          "name": "Priority Queues - Introduction",
          "estimatedHours": 3,
          "description": "Learn how priority queues work using heaps",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ],
          "practiceQuestions": [
            {
              "name": "K Closest Points to Origin",
              "slug": "k-closest-points-to-origin",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/k-closest-points-to-origin/"
            }
          ]
        },
        {
          "id": "priority_queue_code",
          "name": "Priority Queue Code",
          "estimatedHours": 2.5,
          "description": "Implement a priority queue in code",
          "learningTip": [
            "**JS:** No built-in `PriorityQueue`. Need to write `class MinHeap`.",
            "**Methods:** `push(val)`, `pop()`, `peek()`, `size()`.",
            "**Helpers:** `_siftUp(idx)`, `_siftDown(idx)`."
          ],
          "mustNotMiss": [
            "**Interview:** If allowed, just say 'Assume we have a PriorityQueue class'. If asked to implement, write the array-based Heap.",
            "**Python/Java:** Use `heapq` or `PriorityQueue`."
          ],
          "interviewQuestions": [
            {
              "question": "Applications of PQ?",
              "answer": "**OS Scheduling, Dijkstra's Algorithm, Prim's Algorithm, Huffman Coding.**"
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/heap/643/heap/4018/"
          ]
        }
      ]
    },
    {
      "id": "hashing",
      "name": "Hashing",
      "tier": 3,
      "estimatedHours": 54,
      "topics": [
        {
          "id": "linked_list_cycle_hash_table_hashing",
          "name": "Linked List Cycle - Hash Table",
          "estimatedHours": 2.5,
          "description": "Detect cycles in a Linked List using extra space",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle",
              "slug": "linked-list-cycle",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/linked-list-cycle/"
            }
          ],
          "learningTip": [
            "**HashSet:** Store every visited *node reference* (not just value) in a Set.",
            "**Cycle:** If we encounter a node already in the Set, there is a cycle."
          ],
          "mustNotMiss": [
            "**Time:** O(N).",
            "**Space:** O(N) (unlike Floyd's Cycle Finding which is O(1)).",
            "**JS:** Use `new Set()`. Storing objects works by reference."
          ],
          "interviewQuestions": [
            {
              "question": "Constraint: O(1) Memory?",
              "answer": "**Floyd's Tortoise and Hare:** \n*   Use slow and fast pointers. If they meet, cycle exists."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/linked-list-cycle/"
          ]
        },
        {
          "id": "palindrome_linked_list_hashing",
          "name": "Palindrome Linked List",
          "estimatedHours": 3,
          "description": "Check if a Linked List is a palindrome",
          "practiceQuestions": [
            {
              "name": "Palindrome Linked List",
              "slug": "palindrome-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-linked-list/"
            }
          ],
          "learningTip": [
            "**Array Approach:** Copy all values to an array/string. Check if palindrome.",
            "**Stack Approach:** Push all to stack. Iterate list again and pop to compare."
          ],
          "mustNotMiss": [
            "**Space:** These approaches use O(N) space.",
            "**Optimized:** Reverse the second half of the list in-place for O(1) space."
          ],
          "interviewQuestions": [
            {
              "question": "Can we do it without reversing list?",
              "answer": "**Recursion:** \n*   Use a global pointer `front`. \n*   Recurse to end (`back`). Compare `front.val` with `back.val`. Advance `front`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/palindrome-linked-list/"
          ]
        },
        {
          "id": "intersection_two_linked_lists_two_pointers_hashing",
          "name": "Intersection of Two Linked Lists - Two Pointers",
          "estimatedHours": 2.5,
          "description": "Find the intersection node of two linked lists using two pointers",
          "learningTip": [
            "**History match:** We only need to check if we've seen a node before.",
            "**Set:** Add all nodes of List A to a Set. Iterate List B, check set.",
            "**Intersection:** The first node in B that is also in Set."
          ],
          "mustNotMiss": [
            "**Complexity:** O(N + M) time, O(N) space.",
            "**Two Pointer Trick:** `a = a ? a.next : headB`. Equalizes lengths for O(1) space."
          ],
          "interviewQuestions": [
            {
              "question": "Why not compare values?",
              "answer": "**Distinct Nodes:** \n*   Two different nodes can have the same value. Intersection means same *reference*."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/intersection-of-two-linked-lists/"
          ]
        },
        {
          "id": "remove_duplicates_sorted_list_hashing",
          "name": "Remove Duplicates from Sorted List",
          "estimatedHours": 1,
          "description": "Remove consecutive duplicates from a sorted Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted List",
              "slug": "remove-duplicates-from-sorted-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
            }
          ],
          "learningTip": [
            "**Sorted:** Duplicates are adjacent. No hash needed.",
            "**Check:** `current.val == current.next.val`.",
            "**Action:** `current.next = current.next.next`."
          ],
          "mustNotMiss": [
            "**Unsorted:** If unsorted, you MUST use a HashSet to track seen values.",
            "**Memory:** For this problem (sorted), O(1) space is standard."
          ],
          "interviewQuestions": [
            {
              "question": "What if unsorted?",
              "answer": "**HashSet:** \n*   `seen = new Set()`. \n*   If `set.has(val)`, delete node. Else `set.add(val)`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
          ]
        },
        {
          "id": "find_words_containing_character_hashing",
          "name": "Find Words Containing Character",
          "estimatedHours": 2.5,
          "description": "Find words from a list that contain a specific character",
          "practiceQuestions": [
            {
              "name": "Find Words Containing Character",
              "slug": "find-words-containing-character",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-words-containing-character/"
            }
          ],
          "learningTip": [
            "**Simple Check:** Iterate through each word.",
            "**String Method:** Use `word.includes(char)` or `word.indexOf(char) != -1`."
          ],
          "mustNotMiss": [
            "**Indices:** Return a list of *indices* of the words.",
            "**Complexity:** O(N * K) where N is array length, K is average word length."
          ],
          "interviewQuestions": [
            {
              "question": "Optimize for many queries?",
              "answer": "**Inverted Index:** \n*   Pre-process: Map `char -> [list of word indices]`. \n*   Query becomes O(1) to lookup list."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-words-containing-character/"
          ]
        },
        {
          "id": "jewels_stones_hashing",
          "name": "Jewels and Stones",
          "estimatedHours": 2.5,
          "description": "Count how many stones are also jewels",
          "practiceQuestions": [
            {
              "name": "Jewels and Stones",
              "slug": "jewels-and-stones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/jewels-and-stones/"
            }
          ],
          "learningTip": [
            "**Set:** Convert `jewels` string to a Set for O(1) lookup.",
            "**Iterate:** Loop through `stones`, check if `set.has(stone)`.",
            "**Count:** Increment counter if true."
          ],
          "mustNotMiss": [
            "**Complexity:** O(J + S).",
            "**Naive:** Checking string `includes` is O(J*S). Set reduces it to linear.",
            "**Case:** 'a' is different from 'A'."
          ],
          "interviewQuestions": [
            {
              "question": "Constraint: Time O(1)?",
              "answer": "**Not possible.** \n*   We must read the input at least once."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/jewels-and-stones/"
          ]
        },
        {
          "id": "find_most_frequent_vowel_consonant_hashing",
          "name": "Find Most Frequent Vowel and Consonant",
          "estimatedHours": 3,
          "description": "Identify the most frequent vowel and consonant in a string",
          "learningTip": [
            "**Vowels:** a, e, i, o, u.",
            "**Map:** Use two HashMaps or objects: one for vowels, one for consonants.",
            "**Max:** Track `maxVowel` and `maxConsonant` while iterating or after."
          ],
          "mustNotMiss": [
            "**ASCII:** Can use array `int[256]` or `int[26]` if only lowercase.",
            "**Ordering:** If tie in frequency, usually return the first one (or lexicographically first, check constraints)."
          ],
          "interviewQuestions": [
            {
              "question": "Optimize space?",
              "answer": "**Fixed Array:** \n*   Since alphabet size is small (26), array is O(1) space technically."
            }
          ],
          "resources": [
            "https://www.geeksforgeeks.org/find-the-most-frequent-vowel-in-a-string/"
          ]
        },
        {
          "id": "valid_palindrome_extra_space_hashing",
          "name": "Valid Palindrome - Approach 1 - Extra Space",
          "estimatedHours": 2.5,
          "description": "Check palindrome by cleaning and reversing a string",
          "learningTip": [
            "**Clean:** Regex `str.replace(/[^a-z0-9]/gi, '').toLowerCase()`.",
            "**Reverse:** `clean.split('').reverse().join('')`.",
            "**Compare:** `clean === reversed`."
          ],
          "mustNotMiss": [
            "**Space:** O(N) to store the cleaned string.",
            "**Interview:** This approach is fine for 'Easy' version, but interviewer will ask for O(1) space (Two Pointers)."
          ],
          "interviewQuestions": [
            {
              "question": "Why O(1) space?",
              "answer": "**Large Strings:** \n*   For massive text, allocating new strings is expensive. Two pointers operate in-place."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-palindrome/"
          ]
        },
        {
          "id": "valid_anagram_hashing",
          "name": "Valid Anagram",
          "estimatedHours": 3,
          "description": "Check if two strings are anagrams of each other",
          "practiceQuestions": [
            {
              "name": "Valid Anagram",
              "slug": "valid-anagram",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-anagram/"
            }
          ],
          "learningTip": [
            "**Definition:** Same characters, same counts.",
            "**Hash Map:** Count char frequencies of `s`. Decrement for `t`.",
            "**Check:** All counts must be zero."
          ],
          "mustNotMiss": [
            "**Optimization:** Use array `int[26]` for lowercase English letters (faster than Map).",
            "**Length:** If `s.length != t.length`, return false immediately.",
            "**Unicode:** For unicode, Map is strictly required."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use sorting?",
              "answer": "**Yes.** \n*   `s.sort() === t.sort()`. \n*   O(N log N) vs O(N) for Hashing."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-anagram/"
          ]
        },
        {
          "id": "isomorphic_strings_hashing",
          "name": "Isomorphic Strings",
          "estimatedHours": 3,
          "description": "Check if two strings have a one-to-one character mapping",
          "practiceQuestions": [
            {
              "name": "Isomorphic Strings",
              "slug": "isomorphic-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/isomorphic-strings/"
            }
          ],
          "learningTip": [
            "**Mapping:** `s[i]` maps to `t[i]`. AND `t[i]` maps to `s[i]`.",
            "**Two Maps:** Need `mapS` and `mapT` to ensure bijection (one-to-one).",
            "**Consistency:** If we see `s[i]` again, it MUST map to the same `t[i]`."
          ],
          "mustNotMiss": [
            "**Failure:** `if (mapS.has(s[i]) && mapS.get(s[i]) != t[i]) return false`.",
            "**Failure 2:** `if (mapT.has(t[i]) && mapT.get(t[i]) != s[i]) return false`.",
            "**Format:** 'egg', 'add'. e->a, g->d. Consistent."
          ],
          "interviewQuestions": [
            {
              "question": "Can we use one map?",
              "answer": "**No.** \n*   'badc' -> 'baba'. b->b is fine. a->a is fine. d->b? b is already mapped from b, but map(d) is empty. We need to check if target char is already *taken* (using Set or 2nd Map)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/isomorphic-strings/"
          ]
        },
        {
          "id": "group_anagrams_sorted_key_hashing",
          "name": "Group Anagrams - Approach 1 - Sorted Key",
          "estimatedHours": 2.5,
          "description": "Group words that are anagrams using sorted string keys",
          "learningTip": [
            "**Key:** Anagrams have the same sorted string. `eat` -> `aet`. `tea` -> `aet`.",
            "**Map:** `Map<SortedString, List<OriginalString>>`.",
            "**Process:** Iterate words. Sort word. Add to map list. Return map values."
          ],
          "mustNotMiss": [
            "**Complexity:** O(N * K log K) where K is max word length.",
            "**JS:** `key = word.split('').sort().join('')`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we optimize K log K?",
              "answer": "**Counting Sort Key:** \n*   Use character magnitude array '1#2#0...' as key. O(N * K)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/group-anagrams/"
          ]
        },
        {
          "id": "group_anagrams_hashed_key_hashing",
          "name": "Group Anagrams - Approach 2 - Hashed Key",
          "estimatedHours": 2.5,
          "description": "Group anagrams using character frequency hash as key",
          "practiceQuestions": [
            {
              "name": "Group Anagrams",
              "slug": "group-anagrams",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/group-anagrams/"
            }
          ],
          "learningTip": [
            "**Key Generation:** Create a string 'countOfA#countOfB#...'.",
            "**Optimization:** Avoids sorting each word.",
            "**Complexity:** O(N * K) where K is word length."
          ],
          "mustNotMiss": [
            "**Delimiter:** Use a separator like '#' to distinguish counts (e.g., 10 vs 1,0).",
            "**Trade-off:** Faster time but slightly more complex implementation than sorting."
          ],
          "interviewQuestions": [
            {
              "question": "When is this better?",
              "answer": "**Long words:** \n*   If words are very long, sorting O(K log K) dominates. Counting O(K) is better."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/group-anagrams/"
          ]
        },
        {
          "id": "next_greater_element_hashing",
          "name": "Next Greater Element",
          "estimatedHours": 4,
          "description": "Find the next greater element for each number in an array",
          "practiceQuestions": [
            {
              "name": "Next Greater Element I",
              "slug": "next-greater-element-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/next-greater-element-i/"
            }
          ],
          "learningTip": [
            "**Stack:** Monotonic Decreasing Stack.",
            "**Map:** Store `result[val] = nextGreater` in a Map for quick lookup.",
            "**Logic:** `while (stack && val > stack.peek()) { map.set(stack.pop(), val) } stack.push(val)`."
          ],
          "mustNotMiss": [
            "**Purpose:** Find the *next* larger item. O(N).",
            "**Hashing:** Used here because query array is a subset, so we need Map for O(1) answer retrieval."
          ],
          "interviewQuestions": [
            {
              "question": "Circular Array?",
              "answer": "**Loop Twist:** \n*   Iterate `2*N` times. Use logic `% N`. Stack stores indices."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/next-greater-element-i/"
          ]
        },
        {
          "id": "two_sum_ii_sorted_hashing",
          "name": "Two Sum II - Input Array Is Sorted",
          "estimatedHours": 2.5,
          "description": "Solve Two Sum with a sorted array using two pointers",
          "practiceQuestions": [
            {
              "name": "Two Sum II - Input Array Is Sorted",
              "slug": "two-sum-ii-input-array-is-sorted",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
            },
            {
              "name": "Subarray Sum Equals K",
              "slug": "subarray-sum-equals-k",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subarray-sum-equals-k/"
            }
          ],
          "learningTip": [
            "**Two Pointers:** `Left=0`, `Right=N-1`.",
            "**Sorted:** If `sum < target`, `Left++`. If `sum > target`, `Right--`.",
            "**Not Hashing:** Typically NOT solved with Hashing because sorting allows O(1) space."
          ],
          "mustNotMiss": [
            "**Constraint:** Must use O(1) extra space.",
            "**Hashing:** `Map` would be O(N) space, which is suboptimal here."
          ],
          "interviewQuestions": [
            {
              "question": "Why not Binary Search?",
              "answer": "**O(N log N):** \n*   Iterate one, binary search the complement. Two Pointers O(N) is faster."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
          ]
        },
        {
          "id": "find_index_first_occurrence_string_hashing",
          "name": "Find Index of First Occurrence in String",
          "estimatedHours": 2.5,
          "description": "Locate the first occurrence of a substring in a string",
          "practiceQuestions": [
            {
              "name": "Find the Index of the First Occurrence in a String",
              "slug": "find-the-index-of-the-first-occurrence-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
            }
          ],
          "learningTip": [
            "**Naive:** Nested loop O(N*M).",
            "**String:** `haystack.indexOf(needle)` or `substring` check.",
            "**Advanced:** KMP or Rabin-Karp (Rolling Hash)."
          ],
          "mustNotMiss": [
            "**Rolling Hash:** `hash = (hash * base + char) % mod`. Subtract outgoing, add incoming.",
            "**Collision:** Handle collisions by checking actual substring."
          ],
          "interviewQuestions": [
            {
              "question": "What is Rabin-Karp?",
              "answer": "**Rolling Hash:** \n*   Slide window, update hash in O(1). Only check string equality if hash matches."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
          ]
        },
        {
          "id": "kmp_algorithm_hashing",
          "name": "KMP (Knuth-Morris-Pratt) Algorithm",
          "estimatedHours": 4.5,
          "description": "Efficient substring search using the KMP algorithm",
          "learningTip": [
            "**LPS:** Longest Prefix that is also a Suffix.",
            "**Logic:** When mismatch, don't restart. Use LPS array to skip known matches.",
            "**Build:** Constructing LPS is O(M). Search is O(N)."
          ],
          "mustNotMiss": [
            "**LPS Construction:** `len = lps[i-1]`. If match `lps[i] = len+1`. If mismatch `len = lps[len-1]`.",
            "**Search:** If mismatch `j = lps[j-1]`. Avoid backtracking `i`."
          ],
          "interviewQuestions": [
            {
              "question": "Complexity?",
              "answer": "**O(N + M).** \n*   Linear time compared to Naive O(N * M)."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/array-and-string/203/introduction-to-string/1161/"
          ]
        },
        {
          "id": "permutation_in_string_hashing",
          "name": "Permutation in String",
          "estimatedHours": 3,
          "description": "Check if one string contains a permutation of another",
          "practiceQuestions": [
            {
              "name": "Permutation in String",
              "slug": "permutation-in-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutation-in-string/"
            }
          ],
          "learningTip": [
            "**Fixed Window:** Window size = `s1.length`.",
            "**Hash/Array:** Maintain count of chars in window vs `s1`.",
            "**Update:** Slide right. Add input char, remove outgoing char."
          ],
          "mustNotMiss": [
            "**Matches:** Track number of characters with correct frequency count to avoid O(26) check every time.",
            "**Exact:** If `matches == 26`, found."
          ],
          "interviewQuestions": [
            {
              "question": "Difference from Anagram?",
              "answer": "**Substring:** \n*   Anagram is whole string. \n*   Permutation in string checks if *any substring* is an anagram."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/permutation-in-string/"
          ]
        },
        {
          "id": "longest_substring_without_repeating_hashing",
          "name": "Longest Substring Without Repeating Characters",
          "estimatedHours": 4,
          "description": "Find the longest substring with all unique characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            }
          ],
          "learningTip": [
            "**Set:** Use Set to track characters in current window.",
            "**Slide:** Expand `right`. If `right` char in Set, shrink `left` until valid.",
            "**Max:** Update `maxLen` at every step."
          ],
          "mustNotMiss": [
            "**Optimization:** Map `char -> index`. Jump `left` directly to `index + 1` instead of single steps.",
            "**Base:** `Math.max(left, map.get(char) + 1)` to prevent moving back."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity?",
              "answer": "**O(N).** \n*   Each character added and removed at most once."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
          ]
        },
        {
          "id": "sliding_window_maximum_hashing",
          "name": "Sliding Window Maximum",
          "estimatedHours": 3,
          "description": "Find the max value in every window of size k",
          "practiceQuestions": [
            {
              "name": "Sliding Window Maximum",
              "slug": "sliding-window-maximum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-maximum/"
            }
          ],
          "learningTip": [
            "**Deque:** Monotonic Decreasing Deque.",
            "**Stores:** Indices.",
            "**Logic:** Remove indices out of window. Remove indices from back with values <= current. Push current."
          ],
          "mustNotMiss": [
            "**Front:** `deque[0]` is always the max for current window.",
            "**Complexity:** O(N). Each element pushed/popped at most once.",
            "**Heap:** Heap O(N log K) is accepted but Deque O(N) is optimal."
          ],
          "interviewQuestions": [
            {
              "question": "Why store indices?",
              "answer": "**Validation:** \n*   To check if the max element is still inside the sliding window `i - k >= idx`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/sliding-window-maximum/"
          ]
        }
      ]
    },
    {
      "id": "pattern_two_heaps",
      "name": "Pattern: Two Heaps",
      "tier": 4,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "find_median_data_stream",
          "name": "Find Median from Data Stream",
          "estimatedHours": 2,
          "description": "Design a data structure that supports adding integers and finding the median",
          "practiceQuestions": [
            {
              "name": "Design Twitter",
              "slug": "design-twitter",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-twitter/"
            },
            {
              "name": "Find Median from Data Stream",
              "slug": "find-median-from-data-stream",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/find-median-from-data-stream/"
            }
          ],
          "learningTip": [
            "**Two Heaps:** Max-Heap used for the smaller half, Min-Heap for the larger half.",
            "**Invariants:** `maxHeap.size >= minHeap.size`. `maxHeap.top <= minHeap.top`.",
            "**Median:** If sizes equal, average of tops. Else, `maxHeap.top`."
          ],
          "mustNotMiss": [
            "**Balance:** Rebalance heaps after every insertion to maintain size property (diff <= 1)."
          ]
        },
        {
          "id": "sliding_window_median",
          "name": "Sliding Window Median",
          "estimatedHours": 2,
          "description": "Find the median of the sliding window at each position",
          "practiceQuestions": [
            {
              "name": "Sliding Window Median",
              "slug": "sliding-window-median",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-median/"
            }
          ],
          "learningTip": [
            "**Lazy Removal:** Deleting from heap is O(N). Lazy removal (marking as invalid) keeps it O(log N).",
            "**Two Heaps:** Same logic as Data Stream Median."
          ],
          "mustNotMiss": [
            "**Pruning:** Pop from top of heaps if they contain 'deleted' elements."
          ]
        },
        {
          "id": "ipo",
          "name": "IPO",
          "estimatedHours": 2,
          "description": "Select projects to maximize capital",
          "practiceQuestions": [
            {
              "name": "IPO",
              "slug": "ipo",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/ipo/"
            }
          ],
          "learningTip": [
            "**Two Heaps:** Min-Heap for projects sorted by Capital. Max-Heap for projects sorted by Profit.",
            "**Greedy:** Move all affordable projects from Min-Heap to Max-Heap. Pick best from Max-Heap."
          ],
          "mustNotMiss": [
            "**Loop:** Repeat `k` times."
          ]
        }
      ]
    },
    {
      "id": "pattern_k_way_merge",
      "name": "Pattern: K-way Merge",
      "tier": 4,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "merge_k_sorted_lists",
          "name": "Merge k Sorted Lists",
          "estimatedHours": 2,
          "description": "Merge k linked lists into one sorted list",
          "practiceQuestions": [
            {
              "name": "Merge k Sorted Lists",
              "slug": "merge-k-sorted-lists",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/merge-k-sorted-lists/"
            }
          ],
          "learningTip": [
            "**Min-Heap:** Store the head of each list in a Min-Heap.",
            "**Extract:** Pop min, add to result, push `next` node from that list.",
            "**Complexity:** O(N log K)."
          ],
          "mustNotMiss": [
            "**Custom Comparator:** Heap must compare nodes by value."
          ]
        },
        {
          "id": "kth_smallest_element_sorted_matrix",
          "name": "Kth Smallest Element in a Sorted Matrix",
          "estimatedHours": 2,
          "description": "Find the kth smallest element in a sorted matrix",
          "practiceQuestions": [
            {
              "name": "Kth Smallest Element in a Sorted Matrix",
              "slug": "kth-smallest-element-in-a-sorted-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/"
            }
          ],
          "learningTip": [
            "**Min-Heap:** Initialize heap with first element of each row: `(val, r, c)`.",
            "**Iterate:** Pop min `k-1` times. Push `(matrix[r][c+1], r, c+1)` if valid."
          ],
          "mustNotMiss": [
            "**Binary Search:** Alternative solution using value range."
          ]
        },
        {
          "id": "find_k_pairs_smallest_sums",
          "name": "Find K Pairs with Smallest Sums",
          "estimatedHours": 2,
          "description": "Find k pairs with the smallest sums from two arrays",
          "practiceQuestions": [
            {
              "name": "Find K Pairs with Smallest Sums",
              "slug": "find-k-pairs-with-smallest-sums",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/"
            }
          ],
          "learningTip": [
            "**Min-Heap:** Store triplets `(sum, i, j)`.",
            "**Init:** Push `(nums1[i] + nums2[0], i, 0)` for all `i` (or just `0,0`).",
            "**Next:** Push `(nums1[i] + nums2[j+1], i, j+1)` when expanding."
          ],
          "mustNotMiss": [
            "**Optimization:** Only push first `k` elements of nums1 initially."
          ]
        }
      ]
    },
    {
      "id": "pattern_top_k_elements",
      "name": "Pattern: Top 'K' Elements",
      "tier": 4,
      "estimatedHours": 9.5,
      "topics": [
        {
          "id": "top_k_frequent_elements",
          "name": "Top K Frequent Elements",
          "estimatedHours": 2,
          "description": "Find the k most frequent elements in an array",
          "practiceQuestions": [
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            }
          ],
          "learningTip": [
            "**Map + Heap:** Count freq in Map. Push `(freq, key)` to Min-Heap of size K.",
            "**Bucket Sort:** Since frequencies are bounded by N, use array `bucket[freq] = [keys]`.",
            "**Bucket:** Iterate buckets from N down to 1 to find Top K."
          ],
          "mustNotMiss": [
            "**Bucket Sort Complexity:** O(N) time and O(N) space. Faster than Heap's O(N log K)."
          ]
        },
        {
          "id": "kth_largest_element_array",
          "name": "Kth Largest Element in an Array",
          "estimatedHours": 2,
          "description": "Find the kth largest element",
          "practiceQuestions": [
            {
              "name": "Kth Largest Element in an Array",
              "slug": "kth-largest-element-in-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
            }
          ],
          "learningTip": [
            "**QuickSelect:** Average O(N). Partition array around pivot.",
            "**Min-Heap:** Maintain heap of size K. O(N log K)."
          ],
          "mustNotMiss": [
            "**Selection:** QuickSelect is preferred for static arrays in interviews."
          ]
        },
        {
          "id": "kth_largest_element_stream",
          "name": "Kth Largest Element in a Stream",
          "estimatedHours": 2,
          "description": "Maintain the kth largest value in a stream",
          "practiceQuestions": [
            {
              "name": "Kth Largest Element in a Stream",
              "slug": "kth-largest-element-in-a-stream",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
            }
          ],
          "learningTip": [
            "**Min-Heap:** Maintain heap of size K.",
            "**Add:** Push val. If size > K, pop min."
          ],
          "mustNotMiss": [
            "**K-th Largest:** Is always the root of the Min-Heap of size K."
          ]
        },
        {
          "id": "reorganize_string",
          "name": "Reorganize String",
          "estimatedHours": 2,
          "description": "Rearrange string so no two adjacent characters are same",
          "practiceQuestions": [
            {
              "name": "Reorganize String",
              "slug": "reorganize-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reorganize-string/"
            }
          ],
          "learningTip": [
            "**Max-Heap:** Store `(freq, char)`. Pop most frequent.",
            "**Hold:** Hold the popped char. Pop *next* most frequent. Append. Push back held char.",
            "**Greedy:** Always use most frequent available char."
          ],
          "mustNotMiss": [
            "**Impossible:** If `maxFreq > (N+1)/2`, return empty."
          ]
        },
        {
          "id": "frequency_sort",
          "name": "Sort Characters By Frequency",
          "estimatedHours": 1.5,
          "description": "Sort string in decreasing order of frequency",
          "practiceQuestions": [
            {
              "name": "Sort Characters By Frequency",
              "slug": "sort-characters-by-frequency",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-characters-by-frequency/"
            }
          ],
          "learningTip": [
            "**Bucket Sort:** Array of strings. `bucket[freq].append(char)`. Build string from end.",
            "**Heap:** Max-Heap of `(freq, char)`."
          ],
          "mustNotMiss": [
            "**Output:** Repeat char `freq` times in output."
          ]
        }
      ]
    },
    {
      "id": "pattern_modified_binary_search",
      "name": "Pattern: Modified Binary Search",
      "tier": 4,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "binary_search",
          "name": "Binary Search",
          "estimatedHours": 1,
          "description": "Classic Binary Search",
          "practiceQuestions": [
            {
              "name": "Binary Search",
              "slug": "binary-search",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-search/"
            }
          ],
          "learningTip": [
            "**Order-Agnostic:** Check `nums[0] < nums[n-1]` to determine order if unknown.",
            "**Mid:** `mid = start + floor((end - start) / 2)` (prevents overflow)."
          ],
          "mustNotMiss": [
            "**Loop:** `while (start <= end)`."
          ]
        },
        {
          "id": "search_rotated_sorted_array",
          "name": "Search in Rotated Sorted Array",
          "estimatedHours": 1.5,
          "description": "Search for a target value in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Search in Rotated Sorted Array",
              "slug": "search-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
            }
          ],
          "learningTip": [
            "**Halves:** One half (left or right) is ALWAYS sorted.",
            "**Check:** Determine which half is sorted, then check if target lies within that range."
          ],
          "mustNotMiss": [
            "**Sorted Check:** `nums[start] <= nums[mid]` implies left half is sorted."
          ]
        },
        {
          "id": "find_minimum_rotated_sorted_array",
          "name": "Find Minimum in Rotated Sorted Array",
          "estimatedHours": 1.5,
          "description": "Find the minimum element in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Find Minimum in Rotated Sorted Array",
              "slug": "find-minimum-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
            }
          ],
          "learningTip": [
            "**Pivot:** We look for the pivot where order breaks.",
            "**Logic:** If `nums[mid] > nums[end]`, min is to the right (`start = mid + 1`). Else, min is at `mid` or left (`end = mid`)."
          ],
          "mustNotMiss": [
            "**End:** Loop `while (start < end)`. Return `nums[start]`."
          ]
        },
        {
          "id": "single_element_sorted_array",
          "name": "Single Element in a Sorted Array",
          "estimatedHours": 1.5,
          "description": "Find the element that appears only once",
          "practiceQuestions": [
            {
              "name": "Single Element in a Sorted Array",
              "slug": "single-element-in-a-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
            }
          ],
          "learningTip": [
            "**Pairs:** In normal array, `nums[2i] == nums[2i+1]`.",
            "**Pattern:** If `nums[mid] == nums[mid^1]`, we are in valid left half.",
            "**XOR:** `mid^1` gives the partner index."
          ],
          "mustNotMiss": [
            "**Binary Search:** Use index properties to decide direction."
          ]
        },
        {
          "id": "median_two_sorted_arrays",
          "name": "Median of Two Sorted Arrays",
          "estimatedHours": 2.5,
          "description": "Find the median of two sorted arrays",
          "practiceQuestions": [
            {
              "name": "Median of Two Sorted Arrays",
              "slug": "median-of-two-sorted-arrays",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
            }
          ],
          "learningTip": [
            "**Partition:** Cut both arrays such that elements on left <= elements on right.",
            "**Binary Search:** Search for partition index on the smaller array."
          ],
          "mustNotMiss": [
            "**Complex:** O(log(min(M, N)))."
          ]
        }
      ]
    },
    {
      "id": "pattern_subsets",
      "name": "Pattern: Subsets",
      "tier": 4,
      "estimatedHours": 13.5,
      "topics": [
        {
          "id": "subsets_power_set",
          "name": "Subsets",
          "estimatedHours": 2,
          "description": "Generate all subsets of a set",
          "practiceQuestions": [
            {
              "name": "Subsets",
              "slug": "subsets",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subsets/"
            }
          ],
          "learningTip": [
            "**Backtracking:** Choice to Include or Exclude each element.",
            "**Iterative:** Start with `[[]]`. Add current num to all existing subsets."
          ],
          "mustNotMiss": [
            "**Power Set:** Size is `2^N`."
          ]
        },
        {
          "id": "subset_ii",
          "name": "Subsets II",
          "estimatedHours": 2,
          "description": "Subsets with duplicates",
          "practiceQuestions": [
            {
              "name": "Subsets II",
              "slug": "subsets-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subsets-ii/"
            }
          ],
          "learningTip": [
            "**Sort:** Must sort to handle duplicates.",
            "**Skip:** `if (i > start && nums[i] == nums[i-1]) continue`."
          ],
          "mustNotMiss": [
            "**Logic:** Skip 'sibling' duplicates during backtracking loop."
          ]
        },
        {
          "id": "permutations",
          "name": "Permutations",
          "estimatedHours": 2,
          "description": "Generate all permutations",
          "practiceQuestions": [
            {
              "name": "Permutations",
              "slug": "permutations",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutations/"
            }
          ],
          "learningTip": [
            "**Used Array:** Track `used` elements.",
            "**Backtrack:** `path.push(x), used[i]=true, recurse, used[i]=false, path.pop()`."
          ],
          "mustNotMiss": [
            "**Size:** `N!`."
          ]
        },
        {
          "id": "permutations_ii",
          "name": "Permutations II",
          "estimatedHours": 2,
          "description": "Permutations with duplicates",
          "practiceQuestions": [
            {
              "name": "Permutations II",
              "slug": "permutations-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutations-ii/"
            }
          ],
          "learningTip": [
            "**Sort:** Sort first.",
            "**Skip:** `if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) continue`."
          ],
          "mustNotMiss": [
            "**!used[i-1]:** Ensure we maintain relative order of duplicates."
          ]
        },
        {
          "id": "combinations",
          "name": "Combinations",
          "estimatedHours": 2,
          "description": "Find all combinations of k numbers",
          "practiceQuestions": [
            {
              "name": "Combinations",
              "slug": "combinations",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combinations/"
            }
          ],
          "learningTip": [
            "**Loop:** `for i from start to n`.",
            "**Pruning:** Stop if not enough elements remain to fill `k`."
          ],
          "mustNotMiss": [
            "**Difference:** Order doesn't matter (unlike permutations)."
          ]
        },
        {
          "id": "combination_sum",
          "name": "Combination Sum",
          "estimatedHours": 2,
          "description": "Find combinations that sum to target (unlimited reuse)",
          "practiceQuestions": [
            {
              "name": "Combination Sum",
              "slug": "combination-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combination-sum/"
            }
          ],
          "learningTip": [
            "**Reuse:** `backtrack(i, ...)` allows reusing same index.",
            "**Base:** `sum == target`."
          ],
          "mustNotMiss": [
            "**Positive:** Only works naturally if numbers are positive (otherwise infinite loop)."
          ]
        },
        {
          "id": "letter_case_permutation",
          "name": "Letter Case Permutation",
          "estimatedHours": 1.5,
          "description": "Transform string to all case permutations",
          "practiceQuestions": [
            {
              "name": "Letter Case Permutation",
              "slug": "letter-case-permutation",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/letter-case-permutation/"
            }
          ],
          "learningTip": [
            "**Branch:** If char, branch Lower and Upper. If digit, just continue.",
            "**BFS:** Can also be solved breadth-first."
          ],
          "mustNotMiss": [
            "**Toggle:** `char ^ 32` toggles case in ASCII."
          ]
        }
      ]
    },
    {
      "id": "backtracking",
      "name": "Backtracking",
      "tier": 4,
      "estimatedHours": 22.5,
      "topics": [
        {
          "id": "introduction_backtracking",
          "name": "Introduction to Backtracking",
          "estimatedHours": 5.5,
          "description": "Understand the core concept of backtracking",
          "learningTip": [
            "**Definition:** DFS on a state-space tree. Explore paths, valid? continue; invalid? backtrack.",
            "**Template:** `def backtrack(path): if goal: add result; return. for choice in choices: make choice; backtrack(path + choice); undo choice;`"
          ],
          "mustNotMiss": [
            "**Pruning:** Stop branches early if they violate constraints (e.g., sum > target).",
            "**Complexity:** Generally exponential O(b^d) or factorial O(N!)."
          ],
          "interviewQuestions": [
            {
              "question": "Difference vs DFS?",
              "answer": "**State Reset:** \n*   Backtracking explicitly 'undoes' the move to explore other paths from the same state. DFS explores fully before returning."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/"
          ]
        },
        {
          "id": "palindrome_partitioning",
          "name": "Palindrome Partitioning",
          "estimatedHours": 3.5,
          "description": "Partition a string into palindromes",
          "practiceQuestions": [
            {
              "name": "Palindrome Partitioning",
              "slug": "palindrome-partitioning",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/palindrome-partitioning/"
            },
            {
              "name": "Generate Parentheses",
              "slug": "generate-parentheses",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/generate-parentheses/"
            },
            {
              "name": "Combination Sum II",
              "slug": "combination-sum-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combination-sum-ii/"
            }
          ],
          "learningTip": [
            "**Strategy:** Try cutting at index `i` (from `start` to `end`).",
            "**Check:** Is `s[start...i]` a palindrome?",
            "**Recurse:** If yes, add substring to path and `backtrack(i+1)`."
          ],
          "mustNotMiss": [
            "**Helper:** Need efficient `isPalindrome` check. Can Pre-compute (DP) or just check on fly.",
            "**Expansion:** Worst case is O(N * 2^N) (e.g., 'aaaa')."
          ],
          "interviewQuestions": [
            {
              "question": "Optimize Palindrome Check?",
              "answer": "**DP Table:** \n*   `dp[i][j]` = is `s[i:j]` palindrome. Precompute in O(N^2) to save repetitive checks."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/palindrome-partitioning/"
          ]
        },
        {
          "id": "word_search",
          "name": "Word Search",
          "estimatedHours": 5.5,
          "description": "Search a word in a grid",
          "practiceQuestions": [
            {
              "name": "Word Search",
              "slug": "word-search",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/word-search/"
            },
            {
              "name": "Letter Combinations of a Phone Number",
              "slug": "letter-combinations-of-a-phone-number",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
            }
          ],
          "learningTip": [
            "**Idea:** It's DFS on a Grid. Attempt to build word character by character.",
            "**Visited:** Must mark current cell as visited to avoid cycles.",
            "**Backtrack:** Unmark cell after returning from recursion."
          ],
          "mustNotMiss": [
            "**Technique:** `temp = board[r][c]`. `board[r][c] = '#'`.",
            "**Optimization:** Check if board actually contains enough chars of each type before starting DFS (pruning)."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity?",
              "answer": "**O(N * M * 4^L):** \n*   Start at any cell (NM). Max depth L (word length). 4 branches."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/word-search/"
          ]
        },
        {
          "id": "n_queens",
          "name": "N Queens",
          "estimatedHours": 8,
          "description": "Place queens safely on a chessboard",
          "practiceQuestions": [
            {
              "name": "N-Queens",
              "slug": "n-queens",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/n-queens/"
            },
            {
              "name": "Sudoku Solver",
              "slug": "sudoku-solver",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sudoku-solver/"
            }
          ],
          "learningTip": [
            "**Strategy:** Place One Queen per Row.",
            "**Constraints:** Column check. Diagonal check (Top-Left to Bottom-Right). Anti-Diagonal check (Top-Right to Bottom-Left).",
            "**Sets:** Use Sets for O(1) lookups of attacked lines."
          ],
          "mustNotMiss": [
            "**Diagonals:** `diag1 = row - col`. `diag2 = row + col`.",
            "**Backtrack:** `cols.add(c)`. recurse. `cols.delete(c)`."
          ],
          "interviewQuestions": [
            {
              "question": "Count solutions vs valid board?",
              "answer": "**N-Queens II:** \n*   Same logic, just return count. Simpler since we don't need to construct strings."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/n-queens/"
          ]
        }
      ]
    },
    {
      "id": "greedy_algorithm",
      "name": "Greedy Algorithm",
      "tier": 4,
      "estimatedHours": 30.5,
      "topics": [
        {
          "id": "introduction_greedy_algorithm",
          "name": "Introduction to Greedy Algorithm",
          "estimatedHours": 3.5,
          "description": "Learn the basics of the Greedy Algorithm technique with simple examples",
          "learningTip": [
            "**Core Idea:** Make the locally optimal choice at each step with the hope of finding a global optimum.",
            "**Prerequisites:** Sorting or Heap is often the first step to enable greedy choices.",
            "**Warning:** Doesn't work for all problems (e.g., Knapsack 0/1 requires DP, but Fractional Knapsack is Greedy)."
          ],
          "mustNotMiss": [
            "**Proof:** Hard to prove correctness. Generally, if 'swapping' an element with another worsens the result, Greedy might work.",
            "**Structure:** Sort -> Loop -> Select/Reject."
          ],
          "interviewQuestions": [
            {
              "question": "Greedy vs DP?",
              "answer": "**Future vs Present:** \n*   Greedy makes a decision and never looks back. DP considers all decisions (subproblems) to find the best."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/greedy/"
          ]
        },
        {
          "id": "two_city_scheduling",
          "name": "Two City Scheduling",
          "estimatedHours": 2.5,
          "description": "Minimize total costs to fly 2N people to two cities by analyzing cost differences.",
          "practiceQuestions": [
            {
              "name": "Two City Scheduling",
              "slug": "two-city-scheduling",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-city-scheduling/"
            }
          ],
          "learningTip": [
            "**Opportunity Cost:** Cost of sending to A vs B is `priceA - priceB`.",
            "**Sort:** Sort by this difference. Smallest difference (meaning A is much cheaper than B) goes first.",
            "**Split:** First N go to A, Last N go to B."
          ],
          "mustNotMiss": [
            "**Logic:** `(a[0] - a[1]) - (b[0] - b[1])` to sort.",
            "**Sum:** Iterate `0..N-1` for A, `N..2N-1` for B.",
            "**Time:** O(N log N)."
          ],
          "interviewQuestions": [
            {
              "question": "Why sorting works?",
              "answer": "**Minimizing Loss:** \n*   We pick the people who would 'waste' the most money if sent to the wrong city first."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/two-city-scheduling/"
          ]
        },
        {
          "id": "assign_cookies",
          "name": "Assign Cookies",
          "estimatedHours": 2,
          "description": "Maximize satisfied children by assigning cookies efficiently",
          "practiceQuestions": [
            {
              "name": "Assign Cookies",
              "slug": "assign-cookies",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/assign-cookies/"
            }
          ],
          "learningTip": [
            "**Strategy:** Smallest cookie to smallest greed factor child.",
            "**Sort:** Sort both `g` (greed) and `s` (size).",
            "**Pointers:** Iterate `s`. If `s[j] >= g[i]`, satisfied! `i++`."
          ],
          "mustNotMiss": [
            "**Waste Not:** Don't give a huge cookie to a child with small greed if a smaller cookie suffices.",
            "**Result:** `i` is the count of content children."
          ],
          "interviewQuestions": [
            {
              "question": "Can we sort descending?",
              "answer": "**Yes:** \n*   Match largest cookie with largest greed. Same result."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/assign-cookies/"
          ]
        },
        {
          "id": "lemonade_change",
          "name": "Lemonade Change",
          "estimatedHours": 2.5,
          "description": "Manage change in a lemonade stand",
          "practiceQuestions": [
            {
              "name": "Lemonade Change",
              "slug": "lemonade-change",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/lemonade-change/"
            },
            {
              "name": "Valid Parenthesis String",
              "slug": "valid-parenthesis-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/valid-parenthesis-string/"
            }
          ],
          "learningTip": [
            "**Wallet:** Track count of $5 and $10 bills.",
            "**Priority:** When giving change for $20, try to give $10 + $5 first (keep $5s for $10s).",
            "**Fail:** If we can't give change, return false."
          ],
          "mustNotMiss": [
            "**Greedy Choice:** Always get rid of largest denomination first ($10) when making change.",
            "**State:** Only need variables `five` and `ten`. No need for array."
          ],
          "interviewQuestions": [
            {
              "question": "Optimization?",
              "answer": "**O(1) Space:** \n*   Unlike DP, we don't store history. Just current counts."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/lemonade-change/"
          ]
        },
        {
          "id": "best_time_buy_sell_stock_ii",
          "name": "Best Time to Buy and Sell Stock - II",
          "estimatedHours": 2,
          "description": "Maximize stock profit with multiple transactions",
          "practiceQuestions": [
            {
              "name": "Best Time to Buy and Sell Stock II",
              "slug": "best-time-to-buy-and-sell-stock-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
            },
            {
              "name": "Jump Game",
              "slug": "jump-game",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/jump-game/"
            },
            {
              "name": "Jump Game II",
              "slug": "jump-game-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/jump-game-ii/"
            }
          ],
          "learningTip": [
            "**Valley & Peak:** Capture every upward slope.",
            "**Simplification:** `profit += max(0, prices[i] - prices[i-1])`.",
            "**Greedy:** If tomorrow is higher, buy today and sell tomorrow."
          ],
          "mustNotMiss": [
            "**Explanation:** Buying at Day 1, Selling at Day 3 is mathematically same as (D2-D1) + (D3-D2).",
            "**Constraint:** Must sell before buying again (handled by the loop logic)."
          ],
          "interviewQuestions": [
            {
              "question": "Versus Stock I?",
              "answer": "**One vs Many:** \n*   Stock I is single transaction (Min so far). Stock II is accumulation of all positive gradients."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
          ]
        },
        {
          "id": "partition_labels",
          "name": "Partition Labels",
          "estimatedHours": 2.5,
          "description": "Partition string so each letter appears in at most one part",
          "practiceQuestions": [
            {
              "name": "Partition Labels",
              "slug": "partition-labels",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/partition-labels/"
            },
            {
              "name": "Hand of Straights",
              "slug": "hand-of-straights",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/hand-of-straights/"
            },
            {
              "name": "Merge Triplets to Form Target Triplet",
              "slug": "merge-triplets-to-form-target-triplet",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/merge-triplets-to-form-target-triplet/"
            }
          ],
          "learningTip": [
            "**Map:** First pass -> find `lastIndex` of every char.",
            "**Greedy:** Iterate. `end = max(end, lastIndex[char])`.",
            "**Cut:** If `i == end`, we found a valid partition. Push length."
          ],
          "mustNotMiss": [
            "**Reset:** `anchor = i + 1` after cutting.",
            "**Two Pass:** O(N) time. O(1) space (26 chars)."
          ],
          "interviewQuestions": [
            {
              "question": "Why greedy works?",
              "answer": "**Extension:** \n*   Once we see 'a', we MUST include everything up to the last 'a'. This forces the partition to grow. We stop only when 'grown' enough."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/partition-labels/"
          ]
        },
        {
          "id": "non_overlapping_intervals",
          "name": "Non Overlapping Intervals",
          "estimatedHours": 2.5,
          "description": "Find minimum removals to avoid overlaps",
          "practiceQuestions": [
            {
              "name": "Non-overlapping Intervals",
              "slug": "non-overlapping-intervals",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/non-overlapping-intervals/"
            }
          ],
          "learningTip": [
            "**Sort:** Sort by **END** time (Critical!).",
            "**Logic:** Keep the interval that finishes earliest to leave room for others.",
            "**Loop:** If `curr.start < prev.end`, remove `curr` (increment count) and keep `prev`."
          ],
          "mustNotMiss": [
            "**Why End Time?** Sorting by start time doesn't guarantee optimal space usage (e.g., one long interval starting early).",
            "**Comparison:** `prev` is the last *kept* interval."
          ],
          "interviewQuestions": [
            {
              "question": "Max Non-Overlapping?",
              "answer": "**Dual:** \n*   Min Removals = Total Intervals - Max Non-Overlapping Intervals. Same problem."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/non-overlapping-intervals/"
          ]
        },
        {
          "id": "task_scheduler",
          "name": "Task Scheduler",
          "estimatedHours": 3,
          "description": "Schedule tasks with cooling periods",
          "practiceQuestions": [
            {
              "name": "Task Scheduler",
              "slug": "task-scheduler",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/task-scheduler/"
            }
          ],
          "learningTip": [
            "**Gap Filling:** Max frequency task creates `maxFreq - 1` gaps.",
            "**Idle Slots:** `gaps * n`. Fill these with other tasks.",
            "**Formula:** `tasks.length` vs `(maxFreq - 1) * (n + 1) + countMax`."
          ],
          "mustNotMiss": [
            "**Bottleneck:** The most frequent task determines the minimum length.",
            "**Result:** `Math.max(tasks.length, calculated_min_len)`."
          ],
          "interviewQuestions": [
            {
              "question": "Priority Queue approach?",
              "answer": "**Simulation:** \n*   Use Max-Heap to pick most frequent task available. Use Queue to store tasks in 'cooldown'."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/task-scheduler/"
          ]
        },
        {
          "id": "gas_station",
          "name": "Gas Station",
          "estimatedHours": 2.5,
          "description": "Find start station for circular route",
          "practiceQuestions": [
            {
              "name": "Gas Station",
              "slug": "gas-station",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/gas-station/"
            }
          ],
          "learningTip": [
            "**Total Check:** If `totalGas < totalCost`, return -1.",
            "**Current Tank:** Iterate. `tank += gas[i] - cost[i]`.",
            "**Reset:** If `tank < 0`, start cannot be `0..i`. Set `start = i + 1` and `tank = 0`."
          ],
          "mustNotMiss": [
            "**Insight:** If you can't reach `B` from `A`, you can't reach `B` from any station between `A` and `B` either.",
            "**One Pass:** O(N) time. O(1) space."
          ],
          "interviewQuestions": [
            {
              "question": "Why greedy works?",
              "answer": "**Proof:** \n*   If `sum(gas) >= sum(cost)`, a solution is guaranteed to exist. We just need to find the non-negative prefix sum start."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/gas-station/"
          ]
        },
        {
          "id": "car_pooling",
          "name": "Car Pooling",
          "estimatedHours": 2,
          "description": "Verify if a vehicle with fixed capacity can service all trips",
          "practiceQuestions": [
            {
              "name": "Car Pooling",
              "slug": "car-pooling",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/car-pooling/"
            }
          ],
          "learningTip": [
            "**Sweep Line:** Create events `(time, change_in_passengers)`.",
            "**Sort:** Sort events by time. Drop-offs before Pick-ups if time matches.",
            "**Simulate:** Iterate events, update `capacity`. If `capacity > limit`, false."
          ],
          "mustNotMiss": [
            "**Bucket Sort:** Since range is 0-1000, use array `diff[1001]` instead of full sort.",
            "**Update:** `diff[start] += num`, `diff[end] -= num`."
          ],
          "interviewQuestions": [
            {
              "question": "Bucket vs Sort?",
              "answer": "**Range:** \n*   If timestamp range is small (1000), Bucket O(N) is better than Sort O(N log N)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/car-pooling/"
          ]
        },
        {
          "id": "candy_two_pass",
          "name": "Candy - Two Pass",
          "estimatedHours": 2.5,
          "description": "Distribute minimum candies satisfying neighbor constraints",
          "practiceQuestions": [
            {
              "name": "Candy",
              "slug": "candy",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/candy/"
            }
          ],
          "learningTip": [
            "**Pass 1 (L->R):** If `rate[i] > rate[i-1]`, `candies[i] = candies[i-1] + 1`.",
            "**Pass 2 (R->L):** If `rate[i] > rate[i+1]`, `candies[i] = max(candies[i], candies[i+1] + 1)`.",
            "**Sum:** Total sum is the answer."
          ],
          "mustNotMiss": [
            "**Init:** Start with all 1s.",
            "**Max Condition:** Logic depends on *both* neighbors being satisfied."
          ],
          "interviewQuestions": [
            {
              "question": "Why 1 candy?",
              "answer": "**Constraint:** \n*   Each child must have at least one candy."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/candy/"
          ]
        },
        {
          "id": "candy_one_pass",
          "name": "Candy - One Pass - O(1) Space",
          "estimatedHours": 3,
          "description": "Optimize Candy distribution to O(1) space",
          "practiceQuestions": [
            {
              "name": "Candy",
              "slug": "candy",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/candy/"
            }
          ],
          "learningTip": [
            "**Peaks & Valleys:** Count size of increasing slope (`up`) and decreasing slope (`down`).",
            "**Peak Logic:** The peak element needs to be `max(up, down) + 1`.",
            "**Sum:** Add values on the fly."
          ],
          "mustNotMiss": [
            "**Tricky:** Need to handle flat surfaces `rate[i] == rate[i-1]` (reset slopes).",
            "**Implementation:** Keep track of `old_slope` and `new_slope`."
          ],
          "interviewQuestions": [
            {
              "question": "Is One Pass required?",
              "answer": "**Optimization:** \n*   Two pass O(N) space is usually acceptable. O(1) One Pass is a follow-up optimization."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/candy/"
          ]
        }
      ]
    },
    {
      "id": "dynamic_programming",
      "name": "Dynamic Programming",
      "tier": 1,
      "estimatedHours": 52.5,
      "topics": [
        {
          "id": "dp_introduction",
          "name": "Introduction to Dynamic Programming",
          "estimatedHours": 2,
          "description": "Master the art of solving complex optimization problems by breaking them down into simpler, overlapping subproblems.",
          "learningTip": [
            "Core Pattern: Identify if the problem asks for a maximum, minimum, or count of ways (Optimization/Counting).",
            "Properties: 1. Optimal Substructure (solution constructed from sub-solutions). 2. Overlapping Subproblems (sub-problems repeated).",
            "Strategy: First write the recursive solution (Brute Force), then add Memoization (Top-Down), then convert to Tabulation (Bottom-Up)."
          ],
          "mustNotMiss": [
            "Framework: 1. Define the 'State' (variables). 2. Formulate Recurrence Relation. 3. Identify Base Cases.",
            "Top-Down: Recursion + Cache. Easy to implement, handles sparse states well.",
            "Bottom-Up: Iteration + Table. explicit ordering, better memory locality, no recursion limit.",
            "Complexity: States x Transitions per state."
          ]
        },
        {
          "id": "fibonacci_dp",
          "name": "Fibonacci Numbers using DP",
          "estimatedHours": 1.5,
          "description": "The 'Hello World' of DP: Learn Memoization vs Tabulation",
          "practiceQuestions": [
            {
              "name": "Fibonacci Number",
              "slug": "fibonacci-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fibonacci-number/"
            }
          ],
          "learningTip": [
            "**Approaches:** 1. Recursion (O(2^n)). 2. Memoization (O(n)). 3. Tabulation (O(n)). 4. Space Optimized (O(1)).",
            "**Memo Pattern:** `if (memo[n]) return memo[n]`.",
            "**Tabulation:** `dp[i] = dp[i-1] + dp[i-2]`."
          ],
          "mustNotMiss": [
            "**Space Optimization:** You only need the last two numbers (`prev1`, `prev2`) to calculate the current one.",
            "**Base Cases:** `F(0)=0`, `F(1)=1`."
          ],
          "interviewQuestions": [
            {
              "question": "Can we do better than O(N)?",
              "answer": "**Matrix Exponentiation:** \n*   Yes, O(log N) using Matrix alternatives. But O(N) is standard for DP interviews."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/fibonacci-number/"
          ]
        },
        {
          "id": "top_down_bottom_up",
          "name": "Top Down & Bottom Up - DP approach",
          "estimatedHours": 2,
          "description": "Understand the trade-offs: Recursion depth vs Iterative control.",
          "learningTip": [
            "Top-Down (Memoization): 'Lazy' evaluation. Only computes states required to reach the answer. Good when many states are unreachable.",
            "Bottom-Up (Tabulation): 'Eager' evaluation. Computes all subproblems in order. Easier to analyze space complexity and optimize."
          ],
          "mustNotMiss": [
            "Top-Down Skeleton: `if (memo[key]) return memo[key]; ans = solve(); memo[key] = ans; return ans`.",
            "Bottom-Up Skeleton: `dp = array; for i from base to target: dp[i] = ...`.",
            "Advice: Start with Top-Down in interviews (more intuitive), then convert to Bottom-Up if asked or for space optimization."
          ]
        },
        {
          "id": "climbing_stairs",
          "name": "Climbing Stairs",
          "estimatedHours": 1.5,
          "description": "Count distinct ways to reach the top",
          "practiceQuestions": [
            {
              "name": "Climbing Stairs",
              "slug": "climbing-stairs",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/climbing-stairs/"
            }
          ],
          "learningTip": [
            "**Link to Fib:** Reaching step `N` is sum of ways to reach `N-1` (jump 1) and `N-2` (jump 2).",
            "**Distinct Ways:** This is a Counting DP problem.",
            "**Pattern:** `dp[i] = dp[i-1] + dp[i-2]`."
          ],
          "mustNotMiss": [
            "**Base Case:** `dp[1]=1`, `dp[2]=2` (or `dp[0]=1` if 0 definition allows).",
            "**Optimization:** Reduces to Fibonacci variable swap."
          ],
          "interviewQuestions": [
            {
              "question": "What if we can take 1, 2, or 3 steps?",
              "answer": "**Extension:** \n*   `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`. Complexity remains O(N)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/climbing-stairs/"
          ]
        },
        {
          "id": "min_cost_climbing_stairs",
          "name": "Minimum Cost Climbing Stairs",
          "estimatedHours": 2,
          "description": "Find the cheapest path to the top",
          "practiceQuestions": [
            {
              "name": "Min Cost Climbing Stairs",
              "slug": "min-cost-climbing-stairs",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/min-cost-climbing-stairs/"
            }
          ],
          "learningTip": [
            "**Choice:** From `i`, pay `cost[i]` and go to `i+1` or `i+2`.",
            "**Backward Thinking:** To reach top from `i`, `cost = cost[i] + min(dp[i+1], dp[i+2])`.",
            "**Forward Thinking:** To reach `i`, `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`."
          ],
          "mustNotMiss": [
            "**Top Floor:** Note if the 'top' is index `n` (beyond last element). Usually `min(dp[n-1], dp[n-2])`.",
            "**Mutable:** Can overwrite input array `cost` to save O(N) space."
          ],
          "interviewQuestions": [
            {
              "question": "Greedy approach?",
              "answer": "**Fails:** \n*   Always picking the smaller step might lead to a huge cost later. DP is required."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/min-cost-climbing-stairs/"
          ]
        },
        {
          "id": "house_robber",
          "name": "House Robber",
          "estimatedHours": 2.5,
          "description": "Maximize profit with adjacency constraints (1D DP)",
          "practiceQuestions": [
            {
              "name": "House Robber",
              "slug": "house-robber",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/house-robber/"
            },
            {
              "name": "Best Time to Buy and Sell Stock with Cooldown",
              "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"
            }
          ],
          "learningTip": [
            "**Decision:** Detect optimal sub-structure. At house `i`, `max(rob_current + dp[i-2], skip_current + dp[i-1])`.",
            "**Constraint:** Cannot rob adjacent houses.",
            "**Space:** Only need `rob1` (prev-prev) and `rob2` (prev)."
          ],
          "mustNotMiss": [
            "**Pattern:** `current = max(nums[i] + rob1, rob2)`.",
            "**Update:** `rob1 = rob2`, `rob2 = current`.",
            "**Base Case:** Check for empty or single element array."
          ],
          "interviewQuestions": [
            {
              "question": "Recursive relations?",
              "answer": "**Formula:** \n*   `f(i) = max(arr[i] + f(i-2), f(i-1))`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/house-robber/"
          ]
        },
        {
          "id": "house_robber_ii",
          "name": "House Robber II",
          "estimatedHours": 2.5,
          "description": "Solve optimization on circular arrays",
          "practiceQuestions": [
            {
              "name": "House Robber II",
              "slug": "house-robber-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/house-robber-ii/"
            },
            {
              "name": "Best Time to Buy and Sell Stock with Transaction Fee",
              "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/"
            },
            {
              "name": "Best Time to Buy and Sell Stock IV",
              "slug": "best-time-to-buy-and-sell-stock-iv",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"
            }
          ],
          "learningTip": [
            "**Circle:** First and Last are neighbors.",
            "**Break it:** Solve linear House Robber twice.",
            "**Case 1:** Rob `0` to `N-2` (exclude last).",
            "**Case 2:** Rob `1` to `N-1` (exclude first)."
          ],
          "mustNotMiss": [
            "**Result:** `max(Case1, Case2)`.",
            "**Edge Case:** If `length == 1`, return `nums[0]` (loop logic might return 0)."
          ],
          "interviewQuestions": [
            {
              "question": "Why 2 passes?",
              "answer": "**Constraint:** \n*   You cannot rob both index 0 and index N-1. So we explicitly separate the scenarios where 0 is available vs not available."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/house-robber-ii/"
          ]
        },
        {
          "id": "coin_change_top_down",
          "name": "Coin Change - Top Down",
          "estimatedHours": 2.5,
          "description": "Find minimum coins using Memoization",
          "practiceQuestions": [
            {
              "name": "Coin Change",
              "slug": "coin-change",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change/"
            }
          ],
          "learningTip": [
            "**Technique:** Recursion + Memo.",
            "**Recurrence:** `minCoins(amount) = 1 + min(minCoins(amount - c))` for all coins `c`.",
            "**Memo:** Map `amount -> result`."
          ],
          "mustNotMiss": [
            "**Infinity:** Initialize `min` with Infinity. If subproblem returns -1/Infinity, ignore it.",
            "**Base Case:** `amount == 0` returns 0. `amount < 0` returns -1."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity?",
              "answer": "**States * Transitions:** \n*   O(Amount * Coins). We solve for each amount once, and iterate coins for each."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/coin-change/"
          ]
        },
        {
          "id": "coin_change_bottom_up",
          "name": "Coin Change - Bottom Up",
          "estimatedHours": 2.5,
          "description": "Solve Coin Change iteratively (Unbounded Knapsack)",
          "practiceQuestions": [
            {
              "name": "Coin Change",
              "slug": "coin-change",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change/"
            },
            {
              "name": "Burst Balloons",
              "slug": "burst-balloons",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/burst-balloons/"
            },
            {
              "name": "Minimum Cost to Cut a Stick",
              "slug": "minimum-cost-to-cut-a-stick",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/"
            }
          ],
          "learningTip": [
            "**Table:** `dp[i]` = min coins to make amount `i`.",
            "**Init:** `dp[0]=0`, others `Infinity`.",
            "**Loop:** Outer `1..amount`. Inner `coin in coins`."
          ],
          "mustNotMiss": [
            "**Check:** `if (i - coin >= 0) dp[i] = min(dp[i], 1 + dp[i-coin])`.",
            "**Result:** `dp[amount] > amount ? -1 : dp[amount]`."
          ],
          "interviewQuestions": [
            {
              "question": "Top-Down vs Bottom-Up?",
              "answer": "**Overhead:** \n*   Bottom-Up avoids recursion limit and function call overhead. Preferred for production code."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/coin-change/"
          ]
        },
        {
          "id": "palindromic_substrings",
          "name": "Palindromic Substrings",
          "estimatedHours": 2.5,
          "description": "Count all palindromic substrings",
          "practiceQuestions": [
            {
              "name": "Palindromic Substrings",
              "slug": "palindromic-substrings",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/palindromic-substrings/"
            },
            {
              "name": "Longest Palindromic Subsequence",
              "slug": "longest-palindromic-subsequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-subsequence/"
            }
          ],
          "learningTip": [
            "**Center Expansion:** Treat every character and every 'space' between characters as a center.",
            "**Centers:** `2*N - 1` centers in total.",
            "**Expand:** While `L >= 0 && R < N && s[L] == s[R]`: count++, L--, R++."
          ],
          "mustNotMiss": [
            "**Odd vs Even:** `expand(i, i)` (Odd length) and `expand(i, i+1)` (Even length).",
            "**Complexity:** O(N^2) Time. O(1) Space."
          ],
          "interviewQuestions": [
            {
              "question": "Manacher's Algorithm?",
              "answer": "**O(N):** \n*   Exists but rarely asked. Focus on the O(N^2) expansion method."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/palindromic-substrings/"
          ]
        },
        {
          "id": "longest_palindromic_substring",
          "name": "Longest Palindromic Substring",
          "estimatedHours": 2.5,
          "description": "Find maximum length palindrome",
          "practiceQuestions": [
            {
              "name": "Longest Palindromic Substring",
              "slug": "longest-palindromic-substring",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-substring/"
            }
          ],
          "learningTip": [
            "**Same Logic:** Use Expand Around Center.",
            "**Track:** Keep `start` index and `maxLength` globally.",
            "**Update:** If `right - left - 1 > maxLength`, update `start = left + 1`."
          ],
          "mustNotMiss": [
            "**Length Calculation:** Length is `right - left - 1` because variables are decremented/incremented *after* last valid match.",
            "**Substring:** Return `s.substring(start, start + maxLength)`."
          ],
          "interviewQuestions": [
            {
              "question": "DP approach space?",
              "answer": "**O(N^2):** \n*   DP table requires O(N^2) space. Expansion only requires O(1)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-palindromic-substring/"
          ]
        },
        {
          "id": "decode_ways",
          "name": "Decode Ways",
          "estimatedHours": 2.5,
          "description": "Count valid decodings of a digit string",
          "practiceQuestions": [
            {
              "name": "Decode Ways",
              "slug": "decode-ways",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/decode-ways/"
            }
          ],
          "learningTip": [
            "**Constraints:** 1-digit (1-9), 2-digit (10-26).",
            "**Recurrence:** `dp[i]` = (valid 1-digit ? `dp[i-1]` : 0) + (valid 2-digit ? `dp[i-2]` : 0).",
            "**Base:** `dp[0] = 1` (empty string way)."
          ],
          "mustNotMiss": [
            "**Zero Check:** '0' by itself is invalid. '06' is invalid.",
            "**Logic:** `if (s[i-1] != '0') dp[i] += dp[i-1]`.",
            "**Logic:** `val = stoi(s[i-2..i-1]); if (val >= 10 && val <= 26) dp[i] += dp[i-2]`."
          ],
          "interviewQuestions": [
            {
              "question": "Leading Zeros?",
              "answer": "**Invalid:** \n*   String beginning with '0' has 0 ways to decode."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/decode-ways/"
          ]
        },
        {
          "id": "max_subarray_kadane",
          "name": "Maximum Subarray - Kadane's Algorithm",
          "estimatedHours": 2,
          "description": "Find contiguous subarray with largest sum",
          "practiceQuestions": [
            {
              "name": "Maximum Subarray",
              "slug": "maximum-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-subarray/"
            }
          ],
          "learningTip": [
            "**Choice:** Either start fresh at current number `nums[i]` OR extend previous subarray (`currentSum + nums[i]`).",
            "**Logic:** `currentSum = max(nums[i], currentSum + nums[i])`.",
            "**Global:** `maxSum = max(maxSum, currentSum)`."
          ],
          "mustNotMiss": [
            "**Negative:** Handles all negatives correctly (will pick the single largest negative number).",
            "**Reset:** Effectively, if `currentSum` drops below 0, we reset to 0 (implicit in the `max` logic)."
          ],
          "interviewQuestions": [
            {
              "question": "Return the subarray?",
              "answer": "**Indices:** \n*   Track `start`, `end`, and `tempStart`. Reset `tempStart` when starting fresh."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/maximum-subarray/"
          ]
        },
        {
          "id": "max_product_subarray_1",
          "name": "Maximum Product Subarray",
          "estimatedHours": 2.5,
          "description": "Find contiguous subarray with largest product",
          "practiceQuestions": [
            {
              "name": "Maximum Product Subarray",
              "slug": "maximum-product-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-product-subarray/"
            }
          ],
          "learningTip": [
            "**Flip:** Signs flip! Min becomes Max when multiplied by negative.",
            "**State:** Track `maxSoFar` and `minSoFar`.",
            "**Swap:** If `nums[i] < 0`, swap `maxSoFar` and `minSoFar` before multiplying."
          ],
          "mustNotMiss": [
            "**Recurrence:** `maxSoFar = max(nums[i], maxSoFar * nums[i])`.",
            "**Recurrence:** `minSoFar = min(nums[i], minSoFar * nums[i])`.",
            "**Result:** Update global max at each step."
          ],
          "interviewQuestions": [
            {
              "question": "Zeros?",
              "answer": "**Reset:** \n*   '0' effectively breaks the subarray. Logic handles it: `max(0, 0*x) -> 0`. Next iteration starts fresh."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/maximum-product-subarray/"
          ]
        },
        {
          "id": "max_product_subarray_2",
          "name": "Maximum Product Subarray - Two Pass",
          "estimatedHours": 2,
          "description": "Prefix and Suffix product approach",
          "practiceQuestions": [
            {
              "name": "Maximum Product Subarray",
              "slug": "maximum-product-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-product-subarray/"
            }
          ],
          "learningTip": [
            "**Observation:** If valid, max product starts from beginning OR ends at last element (excluding 0s).",
            "**Pass 1:** Left to Right product. Update global max.",
            "**Pass 2:** Right to Left product. Update global max."
          ],
          "mustNotMiss": [
            "**Zero Handle:** If `product == 0`, reset `product = 1`.",
            "**Initial:** `max = nums[0]`.",
            "**Simpler?** Often easier to code than the Min/Max swap tracking."
          ],
          "interviewQuestions": [
            {
              "question": "Why works?",
              "answer": "**Odd Negatives:** \n*   With odd negatives, one must be excluded. Either the first negative (Suffix covers rest) or last negative (Prefix covers rest)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/maximum-product-subarray/"
          ]
        },
        {
          "id": "word_break",
          "name": "Word Break",
          "estimatedHours": 2.5,
          "description": "Determine if string can be segmented",
          "practiceQuestions": [
            {
              "name": "Word Break",
              "slug": "word-break",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/word-break/"
            },
            {
              "name": "Regular Expression Matching",
              "slug": "regular-expression-matching",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/regular-expression-matching/"
            }
          ],
          "learningTip": [
            "**State:** `dp[i] = true` means substring `0..i` can be segmented.",
            "**Transition:** `dp[i]` is true IF there exists `j < i` where `dp[j]` is true AND `s[j..i]` is in dict.",
            "**Set:** Convert dictionary list to Set for O(1) lookups."
          ],
          "mustNotMiss": [
            "**Base Case:** `dp[0] = true`.",
            "**Inner Loop:** Check all possible cut points `j`.",
            "**Optimization:** Only check `j` going back up to `maxLength` of words in dict."
          ],
          "interviewQuestions": [
            {
              "question": "Complexity?",
              "answer": "**O(N^3):** \n*   Outer loop N, Inner loop N, Substring O(N). Can be O(N^2) with Trie or better substring handling."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/word-break/"
          ]
        },
        {
          "id": "longest_increasing_subsequence",
          "name": "Longest Increasing Subsequence",
          "estimatedHours": 3,
          "description": "Find the length of the longest strictly increasing subsequence",
          "practiceQuestions": [
            {
              "name": "Longest Increasing Subsequence",
              "slug": "longest-increasing-subsequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-increasing-subsequence/"
            }
          ],
          "learningTip": [
            "**Standard DP:** `dp[i]` = length of LIS ending at `i`. O(N^2).",
            "**Patience Sort:** Maintain piles (tails list). O(N log N).",
            "**Greedy:** Always Append if largest. Else, replace first element `>= num`."
          ],
          "mustNotMiss": [
            "**Binary Search:** Use `bisect_left` to find insertion point in `tails`.",
            "**Tails Array:** `tails` is sorted but is NOT the LIS itself.",
            "**Difference:** Subsequence (skip elements) vs Subarray (contiguous)."
          ],
          "interviewQuestions": [
            {
              "question": "Reconstruct LIS?",
              "answer": "**Traceback:** \n*   Store `prev` index array or `parent` pointers. Patience sort requires extra tracking."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/longest-increasing-subsequence/"
          ]
        },
        {
          "id": "partition_equal_subset_sum",
          "name": "Partition Equal Subset Sum",
          "estimatedHours": 2.5,
          "description": "Check if valid partition exists (0/1 Knapsack)",
          "practiceQuestions": [
            {
              "name": "Partition Equal Subset Sum",
              "slug": "partition-equal-subset-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/partition-equal-subset-sum/"
            },
            {
              "name": "Target Sum",
              "slug": "target-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/target-sum/"
            }
          ],
          "learningTip": [
            "**Target:** Find subset with sum `Total / 2`.",
            "**Odd Check:** If total sum is odd, return False.",
            "**Knapsack 0/1:** Can I fill a bag of capacity `target` using these items?"
          ],
          "mustNotMiss": [
            "**Space Optimization:** Use 1D Set or Boolean Array.",
            "**Reverse Loop:** `for t from target down to num` to avoid using same item twice in one step.",
            "**Base:** `dp[0] = true`."
          ],
          "interviewQuestions": [
            {
              "question": "Bitset optimization?",
              "answer": "**Bit Manipulation:** \n*   `bits |= (bits << num)`. Very fast solution in C++/Java."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/partition-equal-subset-sum/"
          ]
        },
        {
          "id": "coin_change_ii",
          "name": "Coin Change II",
          "estimatedHours": 2.5,
          "description": "Find number of ways to make amount (Combinations)",
          "practiceQuestions": [
            {
              "name": "Coin Change II",
              "slug": "coin-change-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change-ii/"
            }
          ],
          "learningTip": [
            "**Combination vs Permutation:** WE WANT COMBINATIONS (e.g., 1+2 is same as 2+1).",
            "**Loop Order:** Coins ON OUTSIDE. `for coin in coins: for i in coin..amount`.",
            "**Logic:** Why? Because fixing a coin first forces an order (e.g. all 1s, then all 2s)."
          ],
          "mustNotMiss": [
            "**State:** `dp[i]` = ways to make amount `i`.",
            "**Relation:** `dp[i] += dp[i-coin]`.",
            "**Contrast:** If loops swapped (Amount outside), you get Permutations."
          ],
          "interviewQuestions": [
            {
              "question": "Unbounded Knapsack?",
              "answer": "**Yes:** \n*   Similar to Unbounded Knapsack since we can use coins infinitely."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/coin-change-ii/"
          ]
        },
        {
          "id": "unique_paths",
          "name": "Unique Paths",
          "estimatedHours": 2,
          "description": "Count paths from top-left to bottom-right",
          "practiceQuestions": [
            {
              "name": "Unique Paths",
              "slug": "unique-paths",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/unique-paths/"
            },
            {
              "name": "Minimum Path Sum",
              "slug": "minimum-path-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/minimum-path-sum/"
            },
            {
              "name": "Unique Paths II",
              "slug": "unique-paths-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/unique-paths-ii/"
            }
          ],
          "learningTip": [
            "**Grid DP:** `dp[i][j]` depends on TOP `dp[i-1][j]` and LEFT `dp[i][j-1]`.",
            "**Base:** First row and col are all 1s (only one way to reach them - straight line).",
            "**Combinatorics:** `(m+n-2)! / ((m-1)! * (n-1)!)`."
          ],
          "mustNotMiss": [
            "**Space Optimization:** Use 1D array `row`. `row[j] += row[j-1]`.",
            "**Explanation:** `row[j]` (current) = `row[j]` (from top, old value) + `row[j-1]` (from left, new value)."
          ],
          "interviewQuestions": [
            {
              "question": "Obstacles?",
              "answer": "**Zero:** \n*   If obstacle at `(i,j)`, set `dp[i][j] = 0`. If `(0,0)` is obstacle, answer is 0."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/unique-paths/"
          ]
        },
        {
          "id": "longest_common_subsequence",
          "name": "Longest Common Subsequence",
          "estimatedHours": 2.5,
          "description": "Find the length of the longest common subsequence of two strings.",
          "practiceQuestions": [
            {
              "name": "Longest Common Subsequence",
              "slug": "longest-common-subsequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-common-subsequence/"
            },
            {
              "name": "Edit Distance",
              "slug": "edit-distance",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/edit-distance/"
            },
            {
              "name": "Interleaving String",
              "slug": "interleaving-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/interleaving-string/"
            },
            {
              "name": "Distinct Subsequences",
              "slug": "distinct-subsequences",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/distinct-subsequences/"
            }
          ],
          "learningTip": [
            "**2D DP:** `dp[i][j]` = LCS of `text1[0..i]` and `text2[0..j]`.",
            "**Match:** If `c1 == c2`, `dp[i][j] = 1 + dp[i-1][j-1]`.",
            "**Mismatch:** `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`."
          ],
          "mustNotMiss": [
            "**Base:** Row 0 and Col 0 are 0."
          ]
        },
        {
          "id": "longest_increasing_subsequence",
          "name": "Longest Increasing Subsequence",
          "estimatedHours": 2.5,
          "description": "Find the length of the longest strictly increasing subsequence.",
          "practiceQuestions": [
            {
              "name": "Longest Increasing Subsequence",
              "slug": "longest-increasing-subsequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-increasing-subsequence/"
            }
          ],
          "learningTip": [
            "**DP:** `dp[i]` = LIS ending at index `i`. Iterate `j < i`. If `nums[i] > nums[j]`, `dp[i] = max(dp[i], dp[j] + 1)`.",
            "**Binary Search (Patience Sorting):** Build `tails` array. If `x > tails.last`, append. Else, replace smallest element `>= x`."
          ],
          "mustNotMiss": [
            "**Complexity:** DP is O(N^2). Binary Search is O(N log N)."
          ]
        },
        {
          "id": "palindromic_substrings",
          "name": "Palindromic Substrings",
          "estimatedHours": 2,
          "description": "Count how many palindromic substrings in a string.",
          "practiceQuestions": [
            {
              "name": "Palindromic Substrings",
              "slug": "palindromic-substrings",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/palindromic-substrings/"
            },
            {
              "name": "Longest Palindromic Substring",
              "slug": "longest-palindromic-substring",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-substring/"
            }
          ],
          "learningTip": [
            "**Expand Around Center:** For each `i`, expand `(i,i)` (oddlen) and `(i, i+1)` (evenlen).",
            "**Count:** Incremenet count while characters match."
          ],
          "mustNotMiss": [
            "**Complexity:** O(N^2). Better than Naive O(N^3)."
          ]
        }
      ]
    },
    {
      "id": "graphs",
      "name": "Graphs",
      "tier": 1,
      "estimatedHours": 77,
      "topics": [
        {
          "id": "graphs_introduction",
          "name": "Introduction to Graphs",
          "estimatedHours": 2,
          "description": "Understand the fundamental Graph data structure",
          "learningTip": [
            "**Representations:** Adjacency List (Map<Node, List>) vs Adjacency Matrix (V*V grid).",
            "**Choice:** List is O(V+E) space (good for sparse). Matrix is O(V^2) (good for dense/weighted).",
            "**Terms:** Directed/Undirected, Cyclic/Acyclic, Weighted/Unweighted."
          ],
          "mustNotMiss": [
            "**Adj List:** `graph = { 0: [1, 2], 1: [2] }`.",
            "**Edge Case:** Disconnected graphs (need to iterate all nodes to visit everyone).",
            "**Degree:** In-degree vs Out-degree."
          ],
          "interviewQuestions": [
            {
              "question": "Max Edges?",
              "answer": "**Complete Graph:** \n*   Directed: V*(V-1). Undirected: V*(V-1)/2."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/graph/"
          ]
        },
        {
          "id": "bfs_graph",
          "name": "Breadth First Search (BFS)",
          "estimatedHours": 2.5,
          "description": "Traverse graph layer-by-layer (Queue)",
          "learningTip": [
            "**Queue:** FIFO structure essential for 'By Layer' traversal.",
            "**Levels:** Exploring neighbors (Dist 1), then neighbor's neighbors (Dist 2).",
            "**Shortest Path:** BFS guarantees shortest path in unweighted graphs."
          ],
          "mustNotMiss": [
            "**Visited:** Mark `visited` WHEN PUSHING to queue, NOT when popping.",
            "**Why:** Prevents duplicate entries in the queue (exponential explosion).",
            "**Template:** `q.push(start); visited.add(start); while q: ...`."
          ],
          "interviewQuestions": [
            {
              "question": "Space Complexity?",
              "answer": "**Width:** \n*   O(W) where W is max width of the graph. Worst case O(V)."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/"
          ]
        },
        {
          "id": "dfs_graph",
          "name": "Depth First Search (DFS)",
          "estimatedHours": 2.5,
          "description": "Traverse graph deep-path first (Stack/Recursion)",
          "learningTip": [
            "**Stack:** LIFO structure (or Call Stack).",
            "**Nature:** Boldly go deep, hit dead end, backtrack.",
            "**Use Cases:** Cycle detection, Topological Sort, Connected Components."
          ],
          "mustNotMiss": [
            "**Visited:** Can mark visited on entry.",
            "**Stack Overflow:** Be wary of recursion depth O(V) in deep graphs (e.g., straight line).",
            "**Iterative:** Use explicit stack to avoid recursion limit."
          ],
          "interviewQuestions": [
            {
              "question": "BFS vs DFS?",
              "answer": "**Path vs Connectivity:** \n*   BFS for shortest path. DFS for exhaustively searching complex conditions or cycles."
            }
          ],
          "resources": [
            "https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/"
          ]
        },
        {
          "id": "find_path_exists_bfs",
          "name": "Find if Path Exists",
          "estimatedHours": 2,
          "description": "Check connectivity between nodes",
          "practiceQuestions": [
            {
              "name": "Find if Path Exists in Graph",
              "slug": "find-if-path-exists-in-graph",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-if-path-exists-in-graph/"
            }
          ],
          "learningTip": [
            "**BFS or DFS:** Both work for reachability.",
            "**Union-Find:** Also a strong candidate (Disjoint Set).",
            "**Bidirectional BFS:** Can be faster if graph is huge."
          ],
          "mustNotMiss": [
            "**Optimization:** If specific target, return `true` immediately when found.",
            "**Disconnected:** Graph might be a forest (sets of trees)."
          ],
          "interviewQuestions": [
            {
              "question": "Which is faster?",
              "answer": "**Depends:** \n*   DFS is often simpler code. BFS finds shortest path. Union-Find is fastest for static connectivity queries."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/find-if-path-exists-in-graph/"
          ]
        },
        {
          "id": "dfs_recursive",
          "name": "DFS Recursive Code",
          "estimatedHours": 2,
          "description": "Implement DFS utilizing the system stack",
          "learningTip": [
            "**Closure:** Define `dfs` inside main function to access `visited` and `graph` easily.",
            "**Base Case:** Implicit (when loop finishes or `visited` check).",
            "**Clean:** `const dfs = (node) => { visited.add(node); for (let neighbor of graph[node]) ... }`."
          ],
          "mustNotMiss": [
            "**Pre-order:** Process node *before* recursion.",
            "**Post-order:** Process node *after* recursion (useful for Topological Sort).",
            "**Reference:** Pass strict objects/arrays carefully if defined outside."
          ],
          "interviewQuestions": [
            {
              "question": "Stack Overflow?",
              "answer": "**Limit:** \n*   JS Call stack limit is ~10k. For larger graphs, use Iterative DFS (explicit stack)."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/depth-first-search/"
          ],
          "practiceQuestions": [
            {
              "name": "Number of Islands",
              "slug": "number-of-islands",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-islands/"
            },
            {
              "name": "Clone Graph",
              "slug": "clone-graph",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/clone-graph/"
            },
            {
              "name": "Max Area of Island",
              "slug": "max-area-of-island",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/max-area-of-island/"
            }
          ]
        },
        {
          "id": "all_paths_source_target",
          "name": "All Paths from Source to Target",
          "estimatedHours": 2.5,
          "description": "Backtracking DFS to enumerate every valid path",
          "practiceQuestions": [
            {
              "name": "All Paths From Source to Target",
              "slug": "all-paths-from-source-to-target",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/all-paths-from-source-to-target/"
            }
          ],
          "learningTip": [
            "**Backtracking:** Standard DFS but with Undo.",
            "**DAG:** Input is Directed Acyclic Graph, so no infinite cycles.",
            "**Logic:** `path.push(u) -> dfs(v) -> path.pop()`."
          ],
          "mustNotMiss": [
            "**Goal:** If `curr == target`, add copy of path to results.",
            "**Copy:** `results.push([...path])` (Spread operator essential).",
            "**Complexity:** O(2^N) paths possible."
          ],
          "interviewQuestions": [
            {
              "question": "Why Backtracking?",
              "answer": "**Enumeration:** \n*   We need *every* path, not just one. Backtracking allows re-using nodes for different paths."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/all-paths-from-source-to-target/"
          ]
        },
        {
          "id": "reconstruct_itinerary",
          "name": "Reconstruct Itinerary",
          "estimatedHours": 3,
          "description": "Find an Eulerian Path (visit every edge exactly once)",
          "practiceQuestions": [
            {
              "name": "Reconstruct Itinerary",
              "slug": "reconstruct-itinerary",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/reconstruct-itinerary/"
            }
          ],
          "learningTip": [
            "**Hierholzer's Algorithm:** Used to find Eulerian path in connected graph.",
            "**Greedy DFS:** Visit smallest lexical neighbor, assume it leads to solution.",
            "**Stuck?** If stuck, it means we finished a cycle/sub-component. Add to result."
          ],
          "mustNotMiss": [
            "**Post-Order:** Must add node to result *after* visiting neighbors.",
            "**Reverse:** The built path is in reverse order.",
            "**Data Structure:** Map<String, PriorityQueue<String>> for lexical order."
          ],
          "interviewQuestions": [
            {
              "question": "Eulerian Circuit vs Path?",
              "answer": "**Differences:** \n*   Circuit starts/ends at same node (Even degree). Path starts/ends different (Odd degree)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/reconstruct-itinerary/"
          ]
        },
        {
          "id": "detect_cycle_undirected",
          "name": "Detect Cycle in Undirected Graph",
          "estimatedHours": 2.5,
          "description": "Detect if a cycle exists in an undirected graph",
          "practiceQuestions": [
            {
              "name": "Redundant Connection",
              "slug": "redundant-connection",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/redundant-connection/"
            }
          ],
          "learningTip": [
            "**DFS State:** pass `(node, parent)` to distinguish cycle from trivial back-and-forth.",
            "**Condition:** If `neighbor` visited AND `neighbor != parent`, then Cycle.",
            "**Union-Find:** If `find(u) == find(v)` for edge `u-v`, then Cycle."
          ],
          "mustNotMiss": [
            "**BFS:** Can also use BFS with a `parent` map.",
            "**Disjoint Set:** Often easiest for 'edge list' inputs (Redundant Connection)."
          ],
          "interviewQuestions": [
            {
              "question": "Directed Graph Cycle?",
              "answer": "**Different Logic:** \n*   Undirected checks `visited`. Directed checks `recursionStack` (back edge)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/redundant-connection/"
          ]
        },
        {
          "id": "pattern_topological_sort",
          "name": "Pattern: Topological Sort",
          "estimatedHours": 6,
          "description": "Linear ordering of vertices in a Directed Acyclic Graph (DAG)",
          "practiceQuestions": [
            {
              "name": "Course Schedule",
              "slug": "course-schedule",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule/"
            },
            {
              "name": "Course Schedule II",
              "slug": "course-schedule-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule-ii/"
            },
            {
              "name": "Alien Dictionary",
              "slug": "alien-dictionary",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/alien-dictionary/"
            }
          ],
          "learningTip": [
            "**Kahn's Algorithm (BFS):** Count in-degrees. Queue 0-degree nodes. Pop, reduce neighbors. If neighbor hits 0, queue.",
            "**DFS:** Post-order traversal reversed.",
            "**Cycle:** If BFS processed count < V, cycle exists."
          ],
          "mustNotMiss": [
            "**DAG Requirement:** Only works on Directed Acyclic Graphs.",
            "**Alien Dictionary:** Build graph where `char1 -> char2` if `char1` appears before `char2`. Then Topo Sort."
          ],
          "interviewQuestions": [
            {
              "question": "DFS vs BFS?",
              "answer": "**Implementation:** BFS (Kahn's) is easier for cycle detection (count check). DFS requires recursion stack tracking."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/topological-sort/"
          ]
        },
        {
          "id": "shortest_path_overview",
          "name": "Shortest Path Algorithms in Graphs",
          "estimatedHours": 2,
          "description": "Survey the landscape of Shortest Path algorithms.",
          "learningTip": [
            "Unweighted: BFS (O(V+E)).",
            "Weighted (Positive): Dijkstra (O(E log V)).",
            "Weighted (Negative edges): Bellman-Ford (O(VE)).",
            "All-Pairs: Floyd-Warshall (O(V^3))."
          ],
          "mustNotMiss": [
            "Interview Check: Are weights negative? Is graph dense/sparse? Need single or all pairs?",
            "Most Common: BFS and Dijkstra.",
            "Rare but check constraints: Bellman-Ford (Detect negative cycle)."
          ]
        },
        {
          "id": "shortest_path_bfs",
          "name": "Shortest Path - BFS",
          "estimatedHours": 2,
          "description": "Find shortest distance in Unweighted Graph",
          "practiceQuestions": [
            {
              "name": "Shortest Path in Binary Matrix",
              "slug": "shortest-path-in-binary-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/shortest-path-in-binary-matrix/"
            },
            {
              "name": "Word Ladder",
              "slug": "word-ladder",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/word-ladder/"
            }
          ],
          "learningTip": [
            "**Unweighted:** BFS is King. First time visit = Shortest path.",
            "**Layers:** Expands like a ripple.",
            "**State:** `(row, col, distance)` in queue or separate `dist` matrix."
          ],
          "mustNotMiss": [
            "**Grid:** Check 8 directions for diagonal, 4 for cardinal.",
            "**Blocking:** 0s are free, 1s are obstacles.",
            "**Termination:** Return immediately `if (r == destR && c == destC)`."
          ],
          "interviewQuestions": [
            {
              "question": "Why not DFS?",
              "answer": "**Inefficient:** \n*   DFS might go down a long path before finding the short one nearby. No guarantee of shortest path."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/shortest-path-in-binary-matrix/"
          ]
        },
        {
          "id": "dijkstra_explanation",
          "name": "Dijkstra's Algorithm",
          "estimatedHours": 3,
          "description": "Find shortest paths in Weighted Graph (Non-Negative)",
          "learningTip": [
            "**Greedy:** 'Who is the closest node I haven't finished yet?'",
            "**Relaxation:** If `dist[u] + weight(u,v) < dist[v]`, update `dist[v]`.",
            "**Non-Negative:** Cannot handle negative edges (once a node is 'finished', it's final)."
          ],
          "mustNotMiss": [
            "**Priority Queue:** Essential for O(E log V). Min-Heap of `(dist, node)`.",
            "**Lazy Deletion:** If popped node has `dist > currentDist`, ignore (stale entry).",
            "**Init:** `dist` array to Infinity, `dist[src] = 0`."
          ],
          "interviewQuestions": [
            {
              "question": "Complexity?",
              "answer": "**O(E log V):** \n*   Each edge is relaxed once. Heap operations are log V."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/shortest-path/"
          ]
        },
        {
          "id": "dijkstra_code",
          "name": "Dijkstra's Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Implement Dijkstra's Algorithm in code",
          "practiceQuestions": [
            {
              "name": "Network Delay Time",
              "slug": "network-delay-time",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/network-delay-time/"
            }
          ],
          "learningTip": [
            "Use MinPriorityQueue or implement with array (O(V²) simpler version)",
            "JavaScript: can use sorted array or external library",
            "Process each node at most once (skip if dist[node] > popped distance)"
          ],
          "mustNotMiss": [
            "const pq = new MinPriorityQueue(); pq.enqueue([0, source])",
            "while (!pq.isEmpty()): [d, node] = pq.dequeue(); if (d > dist[node]) continue;",
            "for [neighbor, weight] of graph[node]: if dist[node] + weight < dist[neighbor]: update, enqueue"
          ]
        },
        {
          "id": "bellman_ford_explanation",
          "name": "Bellman Ford Algorithm",
          "estimatedHours": 3,
          "description": "Shortest Path with Negative Weights",
          "learningTip": [
            "**Relaxation:** Try to improve distance to EVERY node, V-1 times.",
            "**Logic:** Shortest path can have at most V-1 edges (no cycles).",
            "**Cycle:** If V-th relaxation reduces a distance, there is a Negative Cycle."
          ],
          "mustNotMiss": [
            "**Edge List:** Iterate over ALL edges (u, v, w) in each pass.",
            "**Robust:** Slower O(VE) than Dijkstra, but works with negatives.",
            "**Detection:** Can return 'Cycle Detected' instead of values."
          ],
          "interviewQuestions": [
            {
              "question": "Can it find Longest Path?",
              "answer": "**Yes:** \n*   Negate all weights and find Shortest Path. (DAGs can use Topo Sort for O(V+E))."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/shortest-path/"
          ]
        },
        {
          "id": "bellman_ford_code",
          "name": "Bellman Ford Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Code the Bellman-Ford Algorithm step by step",
          "practiceQuestions": [
            {
              "name": "Cheapest Flights Within K Stops",
              "slug": "cheapest-flights-within-k-stops",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/"
            }
          ],
          "learningTip": [
            "**Loop:** `V-1` times over all edges.",
            "**K-Stops:** Modify to loop `K+1` times.",
            "**Temp Array:** Use copy of distances to avoid 'cascading' updates in a single iteration."
          ],
          "mustNotMiss": [
            "**Core:** `if (dist[u] != Infinity && dist[u] + w < dist[v])`.",
            "**Infinity Check:** Essential to avoid `Infinity + w` becoming valid.",
            "**Swap:** `dist = clone(tempDist)`."
          ],
          "interviewQuestions": [
            {
              "question": "Why V-1 iterations?",
              "answer": "**Path Length:** \n*   The longest possible shortest path without a cycle contains V vertices and V-1 edges."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/shortest-path/"
          ]
        },
        {
          "id": "floyd_warshall_explanation",
          "name": "Floyd Warshall Algorithm",
          "estimatedHours": 3,
          "description": "All-Pairs Shortest Paths (O(V^3))",
          "learningTip": [
            "**DP:** `dist[i][j]` = shortest path from `i` to `j`.",
            "**Intermediate k:** Can we improve the path `i->j` by going through `k`?",
            "**Code:** Triple loop. Simple but slow."
          ],
          "mustNotMiss": [
            "**Order:** `k` (intermediate) loop MUST be OUTSIDE `i` and `j` loops.",
            "**Check:** `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`.",
            "**Init:** `dist[i][i] = 0`, others `Infinity`."
          ],
          "interviewQuestions": [
            {
              "question": "Negative Cycles?",
              "answer": "**Yes:** \n*   Check diagonal `dist[i][i]`. If `< 0`, a negative cycle involving `i` exists."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/graph/"
          ]
        },
        {
          "id": "floyd_warshall_code",
          "name": "Floyd Warshall - Code",
          "estimatedHours": 2.5,
          "description": "Implement the Floyd-Warshall Algorithm step by step in code",
          "practiceQuestions": [
            {
              "name": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
              "slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/"
            }
          ],
          "learningTip": [
            "Simple triple nested loop",
            "k (intermediate) must be outermost loop",
            "After algorithm: dist[i][j] is shortest path from i to j"
          ],
          "mustNotMiss": [
            "for (let k = 0; k < V; k++) { for (let i = 0; i < V; i++) { for (let j = 0; j < V; j++) { dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } }",
            "Negative cycle exists if any dist[i][i] < 0"
          ]
        },
        {
          "id": "comparing_shortest_path_algorithms",
          "name": "Comparing all Shortest Path Graph Algorithms",
          "estimatedHours": 1.5,
          "description": "Decision Framework: How to choose the right algorithm for the job.",
          "learningTip": [
            "1. Unweighted? -> BFS (Fastest, O(V+E)).",
            "2. Weighted & Positive? -> Dijkstra (Standard, O(E log V)).",
            "3. Negative Weights? -> Bellman-Ford (Necessary).",
            "4. All-Pairs or Very Dense? -> Floyd-Warshall (Simple to code)."
          ],
          "mustNotMiss": [
            "Cheat Sheet:",
            "- BFS: Level Order.",
            "- Dijkstra: Greedy + Heap.",
            "- Bellman: Relax V-1 times.",
            "- Floyd: Triple Loop (k, i, j)."
          ]
        },
        {
          "id": "mst_introduction",
          "name": "Minimum Spanning Tree",
          "estimatedHours": 2,
          "description": "Understand the concept of a Minimum Spanning Tree (MST)",
          "learningTip": [
            "**Spanning Tree:** Subgraph connecting ALL vertices with V-1 edges.",
            "**Minimum:** Sum of edge weights is minimized.",
            "**Algos:** Prim's (Vertex based, like Dijkstra). Kruskal's (Edge based, Union-Find)."
          ],
          "mustNotMiss": [
            "**Cut Property:** For any cut (partition of V into 2 sets), the minimum weight edge crossing the cut represents an MST edge.",
            "**Existence:** MST always exists for a connected graph."
          ],
          "interviewQuestions": [
            {
              "question": "Unique?",
              "answer": "**No:** \n*   If edge weights are distinct, MST is unique. If duplicates exist, multiple MSTs may exist (but same total weight)."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/minimum-spanning-tree/"
          ]
        },
        {
          "id": "prims_algorithm",
          "name": "Prim's Algorithm",
          "estimatedHours": 2.5,
          "description": "MST algorithm using Vertex-based Greedy Strategy",
          "learningTip": [
            "**Concept:** Grow the cloud. Start at arbitrary node.",
            "**Greedy:** Always pick the smallest edge connecting 'Inside Cloud' to 'Outside Cloud'.",
            "**DS:** Priority Queue `(weight, node)`."
          ],
          "mustNotMiss": [
            "**Visited:** Keep track of nodes in the MST.",
            "**Relax:** When adding `u` to MST, push all its edges `(u, v)` to PQ.",
            "**Skip:** If `v` is already visited, ignore the edge."
          ],
          "interviewQuestions": [
            {
              "question": "Prim vs Dijkstra?",
              "answer": "**Difference:** \n*   Dijkstra minimizes distance from Source. Prim minimizes edge weight from Tree."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/minimum-spanning-tree/"
          ]
        },
        {
          "id": "prims_code",
          "name": "Prim's Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Implement Prim's Algorithm in code",
          "practiceQuestions": [
            {
              "name": "Min Cost to Connect All Points",
              "slug": "min-cost-to-connect-all-points",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/"
            }
          ],
          "learningTip": [
            "Min-heap stores [weight, node]",
            "Start with arbitrary node, add all its edges",
            "Pop minimum, if node not visited, add to MST, add its edges"
          ],
          "mustNotMiss": [
            "visited = new Set(); totalWeight = 0; pq = [[0, startNode]];",
            "while (visited.size < V): [weight, node] = pq.pop(); if visited: skip; add to visited, totalWeight += weight; add edges to pq",
            "Time: O(E log V) with heap"
          ]
        },
        {
          "id": "pattern_union_find",
          "name": "Pattern: Union Find",
          "estimatedHours": 6,
          "description": "Disjoint Set Union (DSU) data structure and applications",
          "practiceQuestions": [
            {
              "name": "Redundant Connection",
              "slug": "redundant-connection",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/redundant-connection/"
            },
            {
              "name": "Number of Provinces",
              "slug": "number-of-provinces",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-provinces/"
            },
            {
              "name": "Accounts Merge",
              "slug": "accounts-merge",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/accounts-merge/"
            },
            {
              "name": "Longest Consecutive Sequence",
              "slug": "longest-consecutive-sequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-consecutive-sequence/"
            },
            {
              "name": "Surrounded Regions",
              "slug": "surrounded-regions",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/surrounded-regions/"
            }
          ],
          "learningTip": [
            "**Path Compression:** Point node to its grandparent or root during find.",
            "**Union by Rank/Size:** Attach smaller tree to larger tree.",
            "**Complexity:** Nearly O(1) (Ackermann function)."
          ],
          "mustNotMiss": [
            "**Cycle Detection:** If `find(u) == find(v)`, adding edge `u-v` creates a cycle.",
            "**Components:** Count number of disjoint sets."
          ],
          "interviewQuestions": [
            {
              "question": "Time Complexity?",
              "answer": "**Alpha(N):** \n*   The Inverse Ackermann function is < 5 for all practical N. So effectively O(1)."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/union-find/"
          ]
        },
        {
          "id": "kruskals_algorithm",
          "name": "Kruskal's Algorithm",
          "estimatedHours": 2.5,
          "description": "MST algorithm using Edge-based Greedy Strategy (Union-Find)",
          "learningTip": [
            "**Concept:** Sort all edges by weight.",
            "**Greedy:** Pick smallest edge. If it forms a cycle (already connected), discard it.",
            "**Tool:** Union-Find handles the 'already connected' check."
          ],
          "mustNotMiss": [
            "**Sort:** O(E log E).",
            "**Loop:** `if (find(u) != find(v)) { union(u, v); addToMST(edge); }`.",
            "**Stop:** When MST has V-1 edges."
          ],
          "interviewQuestions": [
            {
              "question": "Complexity Dominator?",
              "answer": "**Sorting:** \n*   Sorting edges O(E log E) dominates the Union-Find operations O(E alpha(V))."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/minimum-spanning-tree/"
          ]
        },
        {
          "id": "kruskal_union_find_code",
          "name": "Kruskal + Union Find - Code",
          "estimatedHours": 2.5,
          "description": "Implement Kruskal's Algorithm using Union-Find",
          "learningTip": [
            "Sort edges, iterate through, use union-find for cycle detection"
          ],
          "mustNotMiss": [
            "edges.sort((a, b) => a[2] - b[2]); // sort by weight",
            "for (const [u, v, w] of edges) { if (find(u) !== find(v)) { mst.push([u, v, w]); union(u, v); } }",
            "Stop when mst.length === V - 1"
          ]
        },
        {
          "id": "prims_vs_kruskal",
          "name": "Comparison - Prim's vs Kruskal Algorithm",
          "estimatedHours": 1.5,
          "description": "Comparison of two MST giants: Vertex-growth vs Edge-selection.",
          "learningTip": [
            "Prim's: Better for Dense Graphs (E ~ V^2). Works locally from a node.",
            "Kruskal's: Better for Sparse Graphs (E ~ V) or pre-sorted edges. Simple logic with DSU.",
            "Cut Property: Prim's uses this (Lightest crossing edge is in MST)."
          ],
          "mustNotMiss": [
            "Prim's with Array: O(V^2). Prim's with Heap: O(E log V).",
            "Kruskal's: O(E log E) (Edge sorting dominates).",
            "Interview Rule of Thumb: Kruskal's is easier to code if you know DSU."
          ]
        },
        {
          "id": "network_connected_operations",
          "name": "Number of Operations to Make Network Connected",
          "estimatedHours": 2.5,
          "description": "Find minimum operations (edge moves) to connect a network.",
          "practiceQuestions": [
            {
              "name": "Number of Operations to Make Network Connected",
              "slug": "number-of-operations-to-make-network-connected",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-operations-to-make-network-connected/"
            }
          ],
          "learningTip": [
            "To connect `N` nodes, you need at least `N-1` edges.",
            "Step 1: If `totalEdges < N-1`, impossible (return -1).",
            "Step 2: Find number of Connected Components `k`.",
            "Step 3: You need `k-1` cables to merge `k` components."
          ],
          "mustNotMiss": [
            "Count components using DFS or Union-Find.",
            "If Union-Find: Start with `count = N`. Decr every successful `union`.",
            "Or Iterate nodes: `if !visited dfs(node); components++`.",
            "Result: `components - 1`."
          ]
        },
        {
          "id": "cheapest_flights_k_stops",
          "name": "Cheapest Flight with K Stops",
          "estimatedHours": 3,
          "description": "Shortest Path constraint on edges (hops)",
          "practiceQuestions": [
            {
              "name": "Cheapest Flights Within K Stops",
              "slug": "cheapest-flights-within-k-stops",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/"
            }
          ],
          "learningTip": [
            "**Standard Dijkstra fails:** It finds shortest path by weight, might use too many stops.",
            "**Bellman-Ford:** Run exactly `K+1` iterations.",
            "**Algorithm:** `dist[v] = min(dist[v], tempDist[u] + w)`."
          ],
          "mustNotMiss": [
            "**Temp Array:** Must use a copy of distances from *previous* iteration.",
            "**Why:** To ensure we only use paths of length `i` to compute length `i+1`.",
            "**BFS:** Can also use BFS `(node, cost, stops)` with PQ, but Bellman is cleaner."
          ],
          "interviewQuestions": [
            {
              "question": "Why K+1?",
              "answer": "**Edges vs Nodes:** \n*   K stops means we can use K+1 edges (flights)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/cheapest-flights-within-k-stops/"
          ]
        },
        {
          "id": "ways_to_arrive_destination",
          "name": "Number of Ways to Arrive at Destination",
          "estimatedHours": 2.5,
          "description": "Count the number of distinct shortest paths using Modified Dijkstra.",
          "practiceQuestions": [
            {
              "name": "Number of Ways to Arrive at Destination",
              "slug": "number-of-ways-to-arrive-at-destination",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/"
            }
          ],
          "learningTip": [
            "Track `ways[u]` = count of shortest paths to `u`.",
            "Relax Logic:",
            "  1. If `newDist < dist[v]`: Found strictly better path. `dist[v]=newDist`, `ways[v]=ways[u]`.",
            "  2. If `newDist == dist[v]`: Found alternative path. `ways[v] = (ways[v] + ways[u]) % MOD`."
          ],
          "mustNotMiss": [
            "Initialize `ways[src] = 1`, `ways[others] = 0`.",
            "Use Priority Queue.",
            "Use Modulo (`1e9 + 7`) at each addition to prevent overflow."
          ]
        },
        {
          "id": "min_cost_connect_points",
          "name": "Min Cost to Connect All Points",
          "estimatedHours": 2.5,
          "description": "MST on a 2D Plane (Manhattan Distance)",
          "practiceQuestions": [
            {
              "name": "Min Cost to Connect All Points",
              "slug": "min-cost-to-connect-all-points",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/"
            }
          ],
          "learningTip": [
            "**Dense Graph:** Every point connects to every other. `E = V^2`.",
            "**Choice:** Prim's (O(V^2)) is better than Kruskal's (O(E log E) = O(V^2 log V)).",
            "**Implicit:** Don't build adj list. Calculate weights on fly."
          ],
          "mustNotMiss": [
            "**Optimization:** Arrays `minDist[v]` similar to Dijkstra.",
            "**Loop:** Find closest unvisited node `u`. Update neighbors `minDist[v] = min(minDist[v], dist(u,v))`.",
            "**Sum:** Add `minDist[u]` to result."
          ],
          "interviewQuestions": [
            {
              "question": "Implicit Edges?",
              "answer": "**Space:** \n*   Building explicit edges O(V^2) might MLE. Compute distance `abs(x1-x2) + abs(y1-y2)` only when needed."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/min-cost-to-connect-all-points/"
          ]
        }
      ]
    },
    {
      "id": "tries",
      "name": "Tries",
      "tier": 1,
      "estimatedHours": 14,
      "topics": [
        {
          "id": "tries_introduction",
          "name": "Introduction to Tries",
          "estimatedHours": 2,
          "description": "Concept of Prefix Tree (Trie) optimized for String Operations.",
          "learningTip": [
            "Structure: Root node is empty. Edges are characters.",
            "Power: Searching for a key (or prefix) takes `O(L)` time, where `L` is key length.",
            "Independent of `N` (number of keys in DB). Faster than Hash Table for prefix search."
          ],
          "mustNotMiss": [
            "Node contains: 1. Links to children (Array/Map). 2. boolean `isEnd`.",
            "Space-Time Tradeoff: Fast lookup, but potentially high memory usage.",
            "Applications: Autocomplete, Spell Checker, IP Routing."
          ],
          "interviewQuestions": [
            {
              "question": "Trie vs Hash Table?",
              "answer": "**Prefix Search:** \n*   Trie can find all words starting with 'a' in O(L). Hash Table requires scanning all keys O(N*L)."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/trie/"
          ]
        },
        {
          "id": "trie_structure",
          "name": "Trie and TrieNode Structure",
          "estimatedHours": 2,
          "description": "Design the TrieNode class and the overall Trie structure",
          "practiceQuestions": [
            {
              "name": "Implement Trie (Prefix Tree)",
              "slug": "implement-trie-prefix-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
            }
          ],
          "learningTip": [
            "TrieNode: children (Map or Object), isEnd boolean",
            "Trie class: root = new TrieNode(), insert/search/startsWith methods",
            "Map is flexible (any alphabet), array[26] for lowercase English only",
            "Keep it simple: don't over-engineer for interviews"
          ],
          "mustNotMiss": [
            "class TrieNode { constructor() { this.children = new Map(); this.isEnd = false; } }",
            "class Trie { constructor() { this.root = new TrieNode(); } }",
            "For array approach: children = new Array(26).fill(null), index = char.charCodeAt(0) - 97"
          ],
          "interviewQuestions": [
            {
              "question": "Map vs Array for Children?",
              "answer": "**Trade-off:** \n*   Array[26] is faster and sorted but uses more space (sparse). \n*   Map is space-efficient for sparse data but slight overhead."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/implement-trie-prefix-tree/"
          ]
        },
        {
          "id": "trie_operations",
          "name": "Insert, Search, PrefixFind - Trie Code",
          "estimatedHours": 2.5,
          "description": "Implement the core operations: Insert, Search, and StartsWith",
          "practiceQuestions": [
            {
              "name": "Implement Trie (Prefix Tree)",
              "slug": "implement-trie-prefix-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
            },
            {
              "name": "Design Add and Search Words Data Structure",
              "slug": "design-add-and-search-words-data-structure",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
            }
          ],
          "learningTip": [
            "Insert: traverse/create nodes for each char, mark last as isEnd",
            "Search: traverse nodes, return isEnd of last node",
            "StartsWith: same as search but return true if path exists (ignore isEnd)",
            "All operations: O(m) time where m = word length"
          ],
          "mustNotMiss": [
            "insert(word): node = root; for char of word: if !node.children.has(char): node.children.set(char, new TrieNode()); node = node.children.get(char); node.isEnd = true;",
            "search(word): node = traverse(word); return node !== null && node.isEnd;",
            "startsWith(prefix): return traverse(prefix) !== null;",
            "Helper traverse(str): follows path, returns null if char not found"
          ],
          "interviewQuestions": [
            {
              "question": "How to delete?",
              "answer": "**Recursion:** \n*   Bottom-up. If node has no other children and not isEnd, delete it from parent map."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
          ]
        },
        {
          "id": "trie_complexity",
          "name": "Time & Space Complexity in Tries",
          "estimatedHours": 1.5,
          "description": "Analyze Time and Space efficiency of Trie.",
          "learningTip": [
            "Time: Insert/Search/StartsWith are all `O(L)` (Word Length). Very consistent.",
            "Space: `O(N * L * AlphabetSize)` in worst case (no shared prefixes).",
            "Comparison: Hash Table is `O(L)` average but usually suffers collisions and bad worst-case."
          ],
          "mustNotMiss": [
            "Tries are 'Prefix-Friendly'. Hash Tables are not.",
            "If Alphabet is large (Unicode), use `Map`. If small (a-z), use `Array[26]`.",
            "Memory can be optimized (Compressed Tries / Radix Trees)."
          ],
          "interviewQuestions": [
            {
              "question": "Worst Case Space?",
              "answer": "**Redundancy:** \n*   If no words share prefixes, we store every character as a node. O(N * L)."
            }
          ],
          "resources": [
            "https://leetcode.com/tag/trie/"
          ]
        },
        {
          "id": "design_add_search_words",
          "name": "Design Add and Search Words Data Structure",
          "estimatedHours": 2,
          "description": "Design a Trie that supports '.' wildcards.",
          "practiceQuestions": [
            {
              "name": "Design Add and Search Words Data Structure",
              "slug": "design-add-and-search-words-data-structure",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
            }
          ],
          "learningTip": [
            "**Wildcard:** If char is '.', iterate ALL children and recurse.",
            "**DFS:** Use helper `search(node, index)`."
          ],
          "mustNotMiss": [
            "**Complexity:** worst case checking all nodes."
          ]
        },
        {
          "id": "word_search_ii",
          "name": "Word Search II",
          "estimatedHours": 4,
          "description": "Find all words from dictionary in a grid.",
          "practiceQuestions": [
            {
              "name": "Word Search II",
              "slug": "word-search-ii",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/word-search-ii/"
            }
          ],
          "learningTip": [
            "**Trie:** Insert all dictionary words into a Trie.",
            "**DFS:** Iterate every cell `(r,c)` in grid. Start DFS traversal matching against Trie.",
            "**Pruning:** Remove word from Trie after finding it (to avoid finding duplicate instances)."
          ],
          "mustNotMiss": [
            "**Complexity:** O(M*N * 4^L) where L is max word length."
          ]
        }
      ]
    },
    {
      "id": "pattern_bit_manipulation",
      "name": "Pattern: Bit Manipulation",
      "tier": 2,
      "estimatedHours": 3.5,
      "topics": [
        {
          "id": "counting_bits",
          "name": "Counting Bits",
          "estimatedHours": 1,
          "description": "Count the number of 1s in the binary representation of every number from 0 to n",
          "practiceQuestions": [
            {
              "name": "Counting Bits",
              "slug": "counting-bits",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/counting-bits/"
            }
          ],
          "learningTip": [
            "**DP Pattern:** `bits[i] = bits[i >> 1] + (i & 1)`. The count of 1s in `i` equals count in `i/2` plus whether `i` is odd.",
            "**Bit Trick:** `i & 1` checks if the last bit is 1 (odd number).",
            "**Right Shift:** `i >> 1` is equivalent to `Math.floor(i / 2)`."
          ],
          "mustNotMiss": [
            "**O(n) Solution:** Don't count bits individually for each number. Use the DP relation.",
            "**Base Case:** `bits[0] = 0`."
          ],
          "interviewQuestions": [
            {
              "question": "Can you solve Counting Bits in O(n) time without using any built-in popcount?",
              "answer": "**DP Approach:** Use `bits[i] = bits[i >> 1] + (i & 1)`. Each number's bit count relates to the number with its last bit removed."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/counting-bits/"
          ]
        },
        {
          "id": "number_of_1_bits",
          "name": "Number of 1 Bits",
          "estimatedHours": 0.5,
          "description": "Count the number of set bits (1s) in the binary representation of an unsigned integer",
          "practiceQuestions": [
            {
              "name": "Number of 1 Bits",
              "slug": "number-of-1-bits",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/number-of-1-bits/"
            }
          ],
          "learningTip": [
            "**Brian Kernighan's Algorithm:** `n = n & (n - 1)` removes the lowest set bit. Count iterations until n becomes 0.",
            "**Why it works:** `n - 1` flips all bits from the rightmost set bit to the end. AND-ing with `n` clears that bit.",
            "**Alternative:** Use `n & 1` to check last bit and `n >>>= 1` (unsigned right shift) to process each bit."
          ],
          "mustNotMiss": [
            "**Unsigned Right Shift:** In JavaScript, use `>>>` not `>>` for unsigned integers to avoid sign extension.",
            "**Time:** O(number of set bits), not O(32). Brian Kernighan's is faster for sparse bits."
          ],
          "interviewQuestions": [
            {
              "question": "What is the difference between >> and >>> in JavaScript?",
              "answer": "**>> (Signed):** Preserves the sign bit. Negative numbers stay negative. \n**>>> (Unsigned):** Fills with 0s from the left. Converts to unsigned 32-bit integer."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/number-of-1-bits/"
          ]
        },
        {
          "id": "reverse_bits",
          "name": "Reverse Bits",
          "estimatedHours": 1,
          "description": "Reverse the bits of a given 32-bit unsigned integer",
          "practiceQuestions": [
            {
              "name": "Reverse Bits",
              "slug": "reverse-bits",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-bits/"
            }
          ],
          "learningTip": [
            "**Bit by Bit:** Extract last bit with `n & 1`, shift result left, OR the bit in. Repeat 32 times.",
            "**Pattern:** `result = (result << 1) | (n & 1); n >>>= 1;`",
            "**JavaScript Gotcha:** Use `>>> 0` to convert final result to unsigned 32-bit integer."
          ],
          "mustNotMiss": [
            "**Exactly 32 iterations:** Always loop 32 times, even if `n` becomes 0 early (leading zeros matter).",
            "**Unsigned conversion:** `result >>> 0` is essential in JS to handle the unsigned requirement."
          ],
          "interviewQuestions": [
            {
              "question": "How would you optimize Reverse Bits if it's called many times?",
              "answer": "**Cache/Lookup:** Reverse bytes (8-bit chunks) and store in a lookup table. Reverse 4 bytes and swap their order. Reduces repeated computation."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/reverse-bits/"
          ]
        },
        {
          "id": "sum_of_two_integers",
          "name": "Sum of Two Integers",
          "estimatedHours": 1,
          "description": "Calculate the sum of two integers without using + or - operators",
          "practiceQuestions": [
            {
              "name": "Sum of Two Integers",
              "slug": "sum-of-two-integers",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sum-of-two-integers/"
            }
          ],
          "learningTip": [
            "**XOR for Sum:** `a ^ b` gives the sum without carries.",
            "**AND + Shift for Carry:** `(a & b) << 1` gives the carry bits.",
            "**Loop:** Repeat until carry is 0: `sum = a ^ b; carry = (a & b) << 1; a = sum; b = carry;`"
          ],
          "mustNotMiss": [
            "**Negative Numbers:** Works correctly with two's complement representation.",
            "**JavaScript:** May need to handle 32-bit overflow. In interviews, discuss the approach clearly."
          ],
          "interviewQuestions": [
            {
              "question": "Why does XOR simulate addition without carry?",
              "answer": "**Binary Addition:** `0+0=0`, `0+1=1`, `1+0=1`, `1+1=0` (carry 1). XOR gives exactly these results for the non-carry part. AND finds where both bits are 1 (carry positions)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/sum-of-two-integers/"
          ]
        }
      ]
    },
    {
      "id": "math_geometry_matrix",
      "name": "Math & Geometry / Matrix",
      "tier": 2,
      "estimatedHours": 7,
      "topics": [
        {
          "id": "plus_one",
          "name": "Plus One",
          "estimatedHours": 0.5,
          "description": "Increment a large integer represented as an array of digits by one",
          "practiceQuestions": [
            {
              "name": "Plus One",
              "slug": "plus-one",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/plus-one/"
            }
          ],
          "learningTip": [
            "**Traverse Right to Left:** Start from the last digit. If it's < 9, just increment and return.",
            "**Carry Propagation:** If digit is 9, set it to 0 and continue left.",
            "**Edge Case:** All 9s (e.g., [9,9,9]) → need to prepend 1 → [1,0,0,0]."
          ],
          "mustNotMiss": [
            "**No conversion to number:** Large arrays overflow `Number.MAX_SAFE_INTEGER`.",
            "**Early return:** If any digit < 9, no need to process remaining digits."
          ],
          "interviewQuestions": [
            {
              "question": "Why can't you just convert the array to a number, add 1, and convert back?",
              "answer": "**Overflow:** Arrays can represent numbers larger than `Number.MAX_SAFE_INTEGER` (2^53). Converting would lose precision."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/plus-one/"
          ]
        },
        {
          "id": "set_matrix_zeroes",
          "name": "Set Matrix Zeroes",
          "estimatedHours": 1,
          "description": "If an element in an m×n matrix is 0, set its entire row and column to 0s",
          "practiceQuestions": [
            {
              "name": "Set Matrix Zeroes",
              "slug": "set-matrix-zeroes",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/set-matrix-zeroes/"
            }
          ],
          "learningTip": [
            "**O(1) Space Trick:** Use the first row and first column as markers instead of extra arrays.",
            "**Two Passes:** First pass marks which rows/cols need zeroing. Second pass applies the zeros.",
            "**Special handling:** Track `firstRowZero` and `firstColZero` separately before using them as markers."
          ],
          "mustNotMiss": [
            "**Order matters:** Zero out inner cells first, then handle first row/col last.",
            "**Don't modify markers prematurely:** If you zero the first row too early, you corrupt your markers."
          ],
          "interviewQuestions": [
            {
              "question": "Can you solve this in O(1) extra space?",
              "answer": "**Yes:** Use the matrix itself. First row marks which columns to zero, first column marks which rows. Track whether first row/col themselves need zeroing with boolean flags."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/set-matrix-zeroes/"
          ]
        },
        {
          "id": "spiral_matrix",
          "name": "Spiral Matrix",
          "estimatedHours": 1,
          "description": "Return all elements of a matrix in spiral order",
          "practiceQuestions": [
            {
              "name": "Spiral Matrix",
              "slug": "spiral-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/spiral-matrix/"
            }
          ],
          "learningTip": [
            "**Four Boundaries:** Maintain `top`, `bottom`, `left`, `right` pointers.",
            "**Shrink Borders:** After traversing right → shrink top. After down → shrink right. After left → shrink bottom. After up → shrink left.",
            "**Loop until:** `top <= bottom && left <= right`."
          ],
          "mustNotMiss": [
            "**Non-square matrices:** Handle rectangles (more rows than cols or vice versa).",
            "**Boundary checks:** After each direction change, re-check the loop condition to avoid duplicate traversal."
          ],
          "interviewQuestions": [
            {
              "question": "How do you handle a single-row or single-column matrix?",
              "answer": "**Boundary check:** After traversing right, if `top > bottom`, stop. After traversing down, if `left > right`, stop. This naturally handles edge cases."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/spiral-matrix/"
          ]
        },
        {
          "id": "rotate_image",
          "name": "Rotate Image",
          "estimatedHours": 1,
          "description": "Rotate an n×n 2D matrix by 90 degrees clockwise in-place",
          "practiceQuestions": [
            {
              "name": "Rotate Image",
              "slug": "rotate-image",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-image/"
            }
          ],
          "learningTip": [
            "**Two-Step Trick:** 1) Transpose the matrix (swap rows↔cols). 2) Reverse each row.",
            "**Transpose:** `matrix[i][j]` ↔ `matrix[j][i]` for `j > i`.",
            "**Why it works:** Transpose + Row Reverse = 90° clockwise rotation."
          ],
          "mustNotMiss": [
            "**In-place requirement:** You cannot use an extra matrix.",
            "**Transpose correctly:** Only swap upper triangle (`j > i`) to avoid double-swapping."
          ],
          "interviewQuestions": [
            {
              "question": "How would you rotate 90° counter-clockwise?",
              "answer": "**Reverse first, then transpose.** Or: transpose first, then reverse each column instead of each row."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/rotate-image/"
          ]
        },
        {
          "id": "valid_sudoku",
          "name": "Valid Sudoku",
          "estimatedHours": 1,
          "description": "Determine if a 9×9 Sudoku board is valid (no repeats in rows, columns, or 3×3 sub-boxes)",
          "practiceQuestions": [
            {
              "name": "Valid Sudoku",
              "slug": "valid-sudoku",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/valid-sudoku/"
            }
          ],
          "learningTip": [
            "**Three Sets:** Use Sets for each row (9), each column (9), and each 3×3 box (9).",
            "**Box Index:** `Math.floor(row / 3) * 3 + Math.floor(col / 3)` gives the box number (0–8).",
            "**Skip empty:** Only validate cells containing digits 1–9."
          ],
          "mustNotMiss": [
            "**Box formula:** The `floor(r/3)*3 + floor(c/3)` trick is the key insight.",
            "**Only check filled cells:** Empty cells (`.`) are valid."
          ],
          "interviewQuestions": [
            {
              "question": "What is the time and space complexity?",
              "answer": "**Time: O(81) = O(1)** since the board is always 9×9. **Space: O(81) = O(1)** for the 27 sets (9 rows + 9 cols + 9 boxes)."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/valid-sudoku/"
          ]
        },
        {
          "id": "pow_x_n",
          "name": "Pow(x, n)",
          "estimatedHours": 1,
          "description": "Implement pow(x, n) which calculates x raised to the power n",
          "practiceQuestions": [
            {
              "name": "Pow(x, n)",
              "slug": "powx-n",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/powx-n/"
            }
          ],
          "learningTip": [
            "**Binary Exponentiation:** If n is even: `x^n = (x^(n/2))^2`. If n is odd: `x^n = x * x^(n-1)`.",
            "**O(log n):** Each step halves the exponent. Much faster than naive O(n).",
            "**Negative n:** Compute `1 / pow(x, -n)`. Handle `n = -2^31` carefully (overflow when negating)."
          ],
          "mustNotMiss": [
            "**Overflow edge case:** `n = -2147483648`. Negating gives `2147483648` which overflows 32-bit int.",
            "**x = 0 and n < 0:** Undefined (division by zero)."
          ],
          "interviewQuestions": [
            {
              "question": "Why is binary exponentiation O(log n)?",
              "answer": "**Halving:** Each step reduces n by half (n/2). After log₂(n) steps, n reaches 0. This is the same principle as binary search."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/powx-n/"
          ]
        },
        {
          "id": "multiply_strings",
          "name": "Multiply Strings",
          "estimatedHours": 1.5,
          "description": "Multiply two non-negative integers represented as strings without using BigInt",
          "practiceQuestions": [
            {
              "name": "Multiply Strings",
              "slug": "multiply-strings",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/multiply-strings/"
            }
          ],
          "learningTip": [
            "**Grade School Multiplication:** Digit `i` of num1 × digit `j` of num2 contributes to position `i+j` and `i+j+1` in result.",
            "**Result Array:** Size is `m + n` (max digits of product of m-digit × n-digit numbers).",
            "**Process carries:** After all multiplications, process carries from right to left."
          ],
          "mustNotMiss": [
            "**Leading zeros:** Trim leading zeros from result. Handle `0 × anything = 0`.",
            "**No BigInt/parseInt:** Must simulate digit-by-digit multiplication."
          ],
          "interviewQuestions": [
            {
              "question": "What is the maximum length of the product of two numbers?",
              "answer": "**m + n digits.** A number with m digits has max value 10^m - 1. Product of 10^m × 10^n = 10^(m+n), which has m+n+1 digits. But (10^m-1) × (10^n-1) has at most m+n digits."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/multiply-strings/"
          ]
        }
      ]
    },
    {
      "id": "system_design_dsa",
      "name": "System Design Basics (DSA)",
      "tier": 3,
      "estimatedHours": 4.5,
      "topics": [
        {
          "id": "design_lru_cache",
          "name": "Design LRU Cache",
          "estimatedHours": 1.5,
          "description": "Design a data structure for Least Recently Used (LRU) cache with O(1) get and put",
          "practiceQuestions": [
            {
              "name": "LRU Cache",
              "slug": "lru-cache",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lru-cache/"
            }
          ],
          "learningTip": [
            "**Combo:** HashMap + Doubly Linked List. Map gives O(1) lookup. DLL gives O(1) insert/remove.",
            "**Operations:** `get` → move node to head (most recent). `put` → add to head, if over capacity remove tail (least recent).",
            "**Sentinel Nodes:** Use dummy `head` and `tail` nodes to simplify edge cases (empty list, single element)."
          ],
          "mustNotMiss": [
            "**Both O(1):** Both `get` and `put` must be O(1). Arrays alone can't achieve this.",
            "**Update existing:** If key already exists in `put`, update value AND move to head."
          ],
          "interviewQuestions": [
            {
              "question": "Why can't you use just a HashMap or just a LinkedList?",
              "answer": "**HashMap alone:** No ordering info (can't find least recently used in O(1)). \n**LinkedList alone:** No O(1) lookup by key. \n**Combined:** HashMap gives O(1) key→node lookup. DLL gives O(1) reordering."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/lru-cache/"
          ]
        },
        {
          "id": "insert_delete_getrandom",
          "name": "Insert Delete GetRandom O(1)",
          "estimatedHours": 1.5,
          "description": "Design a data structure that supports insert, delete, and getRandom in O(1) average time",
          "practiceQuestions": [
            {
              "name": "Insert Delete GetRandom O(1)",
              "slug": "insert-delete-getrandom-o1",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/insert-delete-getrandom-o1/"
            }
          ],
          "learningTip": [
            "**Combo:** HashMap + Array. Map stores `value → index`. Array enables O(1) random access.",
            "**Delete Trick:** Swap element to delete with last element, then pop. Updates map for swapped element.",
            "**GetRandom:** `arr[Math.floor(Math.random() * arr.length)]` — O(1) because array has no gaps."
          ],
          "mustNotMiss": [
            "**Swap-and-pop:** The key insight. Can't delete from middle of array in O(1) otherwise.",
            "**Map update:** After swapping, update the swapped element's index in the map."
          ],
          "interviewQuestions": [
            {
              "question": "Why can't a HashSet alone support getRandom in O(1)?",
              "answer": "**No indexing:** HashSets don't support random access by index. You'd need to convert to array first (O(n)). The array component provides the O(1) random access."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/insert-delete-getrandom-o1/"
          ]
        },
        {
          "id": "design_lfu_cache",
          "name": "Design LFU Cache",
          "estimatedHours": 1.5,
          "description": "Design a Least Frequently Used (LFU) cache with O(1) operations",
          "practiceQuestions": [
            {
              "name": "LFU Cache",
              "slug": "lfu-cache",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/lfu-cache/"
            }
          ],
          "learningTip": [
            "**Three Maps:** 1) key→value+freq, 2) freq→DLL of keys (ordered by recency), 3) key→node pointer.",
            "**Min Frequency:** Track `minFreq`. When evicting, remove from the DLL at `freqMap[minFreq]`.",
            "**On access:** Move key from freq `f` list to freq `f+1` list. If freq `f` list is now empty and `f === minFreq`, increment `minFreq`."
          ],
          "mustNotMiss": [
            "**Tie-breaking:** When multiple keys have same frequency, evict the least recently used one (LRU within same freq).",
            "**New inserts:** Always have `freq = 1`, so `minFreq` resets to 1 on every new insert."
          ],
          "interviewQuestions": [
            {
              "question": "How does LFU differ from LRU?",
              "answer": "**LRU:** Evicts the key not used for the longest time. \n**LFU:** Evicts the key used the fewest times. If tie, evicts the least recently used among those. LFU is harder because you need to track frequencies."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/lfu-cache/"
          ]
        }
      ]
    },
    {
      "id": "searching_sorting_advanced",
      "name": "Searching & Sorting - Advanced",
      "tier": 2,
      "estimatedHours": 11.5,
      "topics": [
        {
          "id": "quick_sort",
          "name": "Quick Sort",
          "estimatedHours": 2.5,
          "description": "Master Quick Sort, the industry-standard sorting algorithm.",
          "practiceQuestions": [
            {
              "name": "Sort an Array",
              "slug": "sort-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-an-array/"
            },
            {
              "name": "Kth Largest Element in an Array",
              "slug": "kth-largest-element-in-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
            }
          ],
          "learningTip": [
            "Why is it faster? Better Cache Locality than Merge Sort. It sorts in-place, accessing contiguous memory.",
            "Divide & Conquer: 1. Partition (place pivot). 2. Recursively sort Left. 3. Recursively sort Right.",
            "Tail Call Optimization hints: ALWAYS recurse on the smaller partition first to limit stack depth to O(log n)."
          ],
          "mustNotMiss": [
            "Lomuto Partition: Easier to implement, but does more swaps.",
            "Hoare Partition: Two pointers from ends, fewer swaps, harder to get right.",
            "Worst Case O(n²): Happens on sorted arrays if pivot is first/last element. FIX: Randomized Pivot.",
            "Quick Select Algorithm: Finds Kth largest in O(n) using the same partition logic."
          ]
        },
        {
          "id": "counting_sort",
          "name": "Counting Sort",
          "estimatedHours": 1.5,
          "description": "Learn Counting Sort for sorting integers with small ranges.",
          "practiceQuestions": [
            {
              "name": "Relative Sort Array",
              "slug": "relative-sort-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/relative-sort-array/"
            }
          ],
          "learningTip": [
            "It's an Integer Sorting algorithm. You CANNOT use it for floating point numbers or strings directly.",
            "Think of it as 'Binning': specific bin for each number value.",
            "Key constraint: Range (K) must not be huge (e.g., K=10^9 is bad, K=1000 is good)."
          ],
          "mustNotMiss": [
            "Time Complexity: O(N + K). If K is O(N), it's Linear Time O(N).",
            "Space Complexity: O(K) for the count array.",
            "Handling Negatives: Shift the range by adding abs(min_val) to indices."
          ]
        },
        {
          "id": "counting_sort_stable_logic",
          "name": "Counting Sort - Stable - Logic",
          "estimatedHours": 1,
          "description": "How to make Counting Sort stable (preserve order).",
          "practiceQuestions": [
            {
              "name": "Rank Transform of an Array",
              "slug": "rank-transform-of-an-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rank-transform-of-an-array/"
            }
          ],
          "learningTip": [
            "Stability is crucial when this is used as a step in Radix Sort.",
            "The magic happens by converting 'Counts' into 'Positions'.",
            "Prefix Sum Array: `count[i] += count[i-1]` tells you exactly where the LAST occurrence of `i` belongs."
          ],
          "mustNotMiss": [
            "Why iterate BACKWARDS? To place the 'last' appearing duplicate in the 'last' available spot for that value.",
            "Iterating forwards reverses the order of duplicates, breaking stability.",
            "Requires an extra Output Array (not fully in-place)."
          ]
        },
        {
          "id": "counting_sort_stable_code",
          "name": "Counting Sort - Stable - Code",
          "estimatedHours": 1.5,
          "description": "Implement the Stable Counting Sort algorithm.",
          "practiceQuestions": [
            {
              "name": "Height Checker",
              "slug": "height-checker",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/height-checker/"
            },
            {
              "name": "Sort Colors",
              "slug": "sort-colors",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-colors/"
            }
          ],
          "learningTip": [
            "Standard Template: 1. Find Max. 2. Fill Freq Array. 3. Prefix Sum. 4. Build Output Backwards.",
            "Sort Colors (0, 1, 2) is a specialized version called Dutch National Flag, but Counting Sort works too!",
            "Offset Indexing: Don't forget `output[count[val]-1] = val; count[val]--;`"
          ],
          "mustNotMiss": [
            "Handling 0-based index: Prefix sums usually give 1-based ranks, so subtract 1.",
            "Copy back: Don't forget to copy the Output array back to the Original array at the end."
          ]
        },
        {
          "id": "radix_sort",
          "name": "Radix Sort",
          "estimatedHours": 2.5,
          "description": "Sorting large numbers or strings digit-by-digit.",
          "practiceQuestions": [
            {
              "name": "Maximum Gap",
              "slug": "maximum-gap",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/maximum-gap/"
            },
            {
              "name": "Minimize Deviation in Array",
              "slug": "minimize-deviation-in-array",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimize-deviation-in-array/"
            }
          ],
          "learningTip": [
            "LSD (Least Significant Digit): Process Unit column -> Tens -> Hundreds...",
            "Why LSD? If you sort by units, then by tens STABLY, the order inside 'tens' buckets respects the 'units' order.",
            "It defeats the O(N log N) barrier because it doesn't compare elements directly."
          ],
          "mustNotMiss": [
            "Complexity: O(d * (N+b)) where d=digits, b=base (usually 10).",
            "If d is large (e.g. very long strings), it can be slower than QuickSort.",
            "Bitwise Radix Sort: Using base 2 or 16 is faster for computers (shifting instead of modulo)."
          ]
        },
        {
          "id": "bucket_sort",
          "name": "Bucket Sort",
          "estimatedHours": 1.5,
          "description": "Efficient sorting for uniformly distributed data.",
          "practiceQuestions": [
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            },
            {
              "name": "Sort Characters By Frequency",
              "slug": "sort-characters-by-frequency",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-characters-by-frequency/"
            }
          ],
          "learningTip": [
            "Scatter: Distribute N elements into M buckets based on value range.",
            "Sort: Sort each bucket individually (often using Insertion Sort).",
            "Gather: Concatenate sorted buckets.",
            "Crucial assumption: Data is Uniformly Distributed. If all go to 1 bucket -> O(N²)."
          ],
          "mustNotMiss": [
            "Bucket Index = floor(value * number_of_buckets).",
            "For Top K Elements: Use 'Frequency' as the bucket index. Bucket[5] = list of elements appearing 5 times.",
            "This 'Bucket Sort by Frequency' is O(N) and very common in interviews."
          ]
        },
        {
          "id": "interview_cheatsheet_sorting",
          "name": "Interview Cheatsheet",
          "estimatedHours": 1,
          "description": "Comparison and cheat codes for sorting in interviews.",
          "learningTip": [
            "Mention 'Stability' when sorting Objects (e.g. sorting Users by Age, then Name). Unstable sort ruins the Name order.",
            "Language Internals: Python/Java use TimSort (Merge + Insertion). C++ std::sort is Introsort (Quick + Heap + Insertion).",
            "Small Arrays (< 64 elements): Insertion Sort is faster than Quick Sort (less overhead)."
          ],
          "mustNotMiss": [
            "Most Robust: Merge Sort (Stable, guaranteed O(N log N)).",
            "Most Efficient: Quick Sort (Fastest in practice, cache friendly).",
            "Specific Constraints: Counting/Radix (Integers), Bucket (Uniform floats).",
            "Memory Constrained: Heap Sort (O(1) space, but unstable and slower than Quick)."
          ]
        }
      ]
    }
  ],
  "totalEstimatedHours": 571,
  "recommendedHoursPerWeek": 2
}
{
  "id": "dsa_by_namastedev",
  "name": "DSA by namastedev",
  "description": "Comprehensive Data Structures and Algorithms course by namastedev covering fundamentals to advanced topics with detailed explanations and practical implementations JavaScript-focused approach for DSA mastery.",
  "category": "Computer Science",
  "stages": [
    {
      "id": "foundation",
      "name": "Foundation Assessment",
      "totalMarks": 100,
      "duration": 180,
      "sections": [
        {
          "id": "programming_basics",
          "name": "Programming Fundamentals",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "problem_solving",
          "name": "Problem Solving & Logic",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "data_structures",
          "name": "Data Structures Fundamentals",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "algorithms",
          "name": "Algorithm Analysis",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "intermediate",
      "name": "Intermediate Skills Assessment",
      "totalMarks": 150,
      "duration": 270,
      "sections": [
        {
          "id": "advanced_ds",
          "name": "Advanced Data Structures",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "tree_graph",
          "name": "Trees and Graphs",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "dynamic_programming",
          "name": "Dynamic Programming & Greedy",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    }
  ],
  "defaultSyllabus": [
    {
      "id": "introduction",
      "name": "Introduction",
      "tier": 1,
      "estimatedHours": 1.5,
      "topics": [
        {
          "id": "course_introduction",
          "name": "Introduction",
          "estimatedHours": 1,
          "description": "Learn how to navigate the course and what you'll cover",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "language_choice",
          "name": "Which language?",
          "estimatedHours": 0.5,
          "description": "Learn how to choose your preferred programming language for the course",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        }
      ]
    },
    {
      "id": "warm_up",
      "name": "Warm Up",
      "tier": 1,
      "estimatedHours": 9.5,
      "topics": [
        {
          "id": "warm_up_introduction",
          "name": "Warm Up - Introduction",
          "estimatedHours": 0.5,
          "description": "Warm-up session for diving into DSA concepts",
          "learningTip": [
            "Quick JS refresher - you know this, let's move fast",
            "Functions, loops, conditionals should be automatic",
            "Arrow functions and array methods will be your tools",
            "Spend minimal time here, focus on DSA ahead"
          ],
          "mustNotMiss": [
            "let/const vs var - use let for loops, const for everything else",
            "Arrow functions: (a, b) => a + b for concise callbacks",
            "=== vs == - always use === to avoid type coercion bugs",
            "Destructuring: const [first, ...rest] = arr for clean code"
          ]
        },
        {
          "id": "programming_101",
          "name": "Programming 101",
          "estimatedHours": 1,
          "description": "Learn the basics of programming with simple concepts explained clearly",
          "learningTip": [
            "JS basics review - move through quickly",
            "Focus on parts relevant to DSA problems",
            "Number handling and string operations are key",
            "You know this - just refresh and proceed"
          ],
          "mustNotMiss": [
            "JavaScript numbers are 64-bit floats - no separate int type",
            "Safe integer range: -(2^53-1) to (2^53-1) use Number.MAX_SAFE_INTEGER",
            "BigInt for larger numbers: 123n or BigInt(123)",
            "Math.floor(), Math.ceil(), Math.trunc() for integer operations"
          ]
        },
        {
          "id": "function_if_else",
          "name": "Function, if-else",
          "estimatedHours": 0.5,
          "description": "Master functions and conditional logic with if-else statements",
          "learningTip": [
            "Functions are first-class in JavaScript",
            "Arrow functions are concise for DSA code",
            "Ternary operator makes conditional returns clean",
            "Know when to use if-else vs switch vs ternary"
          ],
          "mustNotMiss": [
            "Arrow function: const add = (a, b) => a + b",
            "Ternary: return condition ? valueIfTrue : valueIfFalse",
            "Short-circuit: node && node.val (safe property access)",
            "Nullish coalescing: value ?? defaultValue"
          ]
        },
        {
          "id": "loops_01",
          "name": "Loops 01",
          "estimatedHours": 1,
          "description": "Learn looping constructs to repeat code effectively",
          "learningTip": [
            "for loops for index-based iteration",
            "for...of for value iteration (arrays, strings)",
            "forEach, map, filter for functional style",
            "Choose based on what you need: index, value, or transformation"
          ],
          "mustNotMiss": [
            "Classic for: for (let i = 0; i < n; i++)",
            "for...of: for (const char of str) - iterates values",
            "for...in: iterates keys (use for objects, not arrays)",
            "Break and continue work in for loops but NOT in forEach"
          ]
        },
        {
          "id": "loops_02",
          "name": "Loops 02",
          "estimatedHours": 1.5,
          "description": "Deep dive into advanced loop techniques and nested loops",
          "learningTip": [
            "Nested loops = O(n²) - look for ways to avoid",
            "Two pointers or hashmaps often replace nested loops",
            "Matrix problems genuinely need nested loops",
            "Visualize as traversing a 2D grid"
          ],
          "mustNotMiss": [
            "Breaking nested loops: use labeled statements or early return",
            "outer: for (...) { for (...) { break outer; } }",
            "Or extract to function and use return",
            "forEach cannot break - use for...of or regular for"
          ]
        },
        {
          "id": "second_largest",
          "name": "Second Largest",
          "estimatedHours": 1,
          "description": "Find the second largest number in an array efficiently",
          "practiceQuestions": [
            {
              "name": "Second Largest Digit in a String",
              "slug": "second-largest-digit-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/second-largest-digit-in-a-string/"
            }
          ],
          "learningTip": [
            "Track two values in single pass",
            "Initialize with -Infinity for comparison safety",
            "Pattern applies to kth largest, running stats",
            "O(n) single pass is optimal"
          ],
          "mustNotMiss": [
            "let largest = -Infinity, second = -Infinity",
            "If num > largest: second = largest, largest = num",
            "Else if num > second && num !== largest: second = num",
            "Handle edge case: all same values → no valid second"
          ]
        },
        {
          "id": "loop_in_loop",
          "name": "Loop in Loop",
          "estimatedHours": 1,
          "description": "Learn how to implement nested loops for complex patterns",
          "learningTip": [
            "Visualize nested loops as traversing a 2D grid",
            "Outer loop controls rows, inner loop controls columns",
            "This mental model transfers directly to matrix problems",
            "Index relationship between loops defines the pattern"
          ],
          "mustNotMiss": [
            "Inner 0 to n: full matrix (n × n iterations)",
            "Inner i to n: upper triangle (avoid duplicates in pair enumeration)",
            "Inner 0 to i: lower triangle",
            "Draw small examples (3×3) and trace through manually before coding"
          ]
        },
        {
          "id": "star_pattern",
          "name": "Star Pattern",
          "estimatedHours": 1.5,
          "description": "Draw star patterns using nested loops for practice",
          "learningTip": [
            "Pattern problems train you to find mathematical relationships",
            "Skill transfers to: matrix problems, DP table filling, grid traversal",
            "Always find the formula before writing code",
            "Row number determines spaces and characters in each line"
          ],
          "mustNotMiss": [
            "Write out 4-5 rows manually before coding",
            "For each row, determine: spaces before content, number of characters",
            "Find the formula relating row number to these counts",
            "Right triangle: spaces = 0, stars = row number"
          ]
        },
        {
          "id": "count_digit",
          "name": "Count Digit",
          "estimatedHours": 0.5,
          "description": "Count the number of digits in an integer",
          "learningTip": [
            "Digit manipulation is fundamental for number problems",
            "Same technique applies to: reversing, palindrome check, digit sum",
            "Work with absolute value and handle sign separately",
            "The modulo and division operations are your core tools"
          ],
          "mustNotMiss": [
            "n % 10 → extracts the last digit",
            "n // 10 (or n / 10 in int context) → removes the last digit",
            "Build number digit by digit: result = result * 10 + digit",
            "These three operations solve 90% of digit problems"
          ]
        },
        {
          "id": "palindrome",
          "name": "Palindrome",
          "estimatedHours": 0.5,
          "description": "Check if a string or number is a palindrome",
          "practiceQuestions": [
            {
              "name": "Palindrome Number",
              "slug": "palindrome-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-number/"
            }
          ],
          "learningTip": [
            "Palindrome = reads same forwards and backwards",
            "This introduces the two-pointer technique: compare from both ends",
            "Pattern applies to: string problems, linked list problems",
            "For numbers, you can reverse and compare, or check digit by digit"
          ],
          "mustNotMiss": [
            "Negative numbers are NOT palindromes by convention",
            "Numbers ending in 0 (except 0 itself) are NOT palindromes",
            "For large numbers, reverse only HALF to avoid overflow",
            "String approach: skip non-alphanumeric, compare case-insensitively"
          ]
        },
        {
          "id": "reverse_integer",
          "name": "Reverse Integer",
          "estimatedHours": 0.5,
          "description": "Reverse the digits of an integer programmatically",
          "practiceQuestions": [
            {
              "name": "Reverse Integer",
              "slug": "reverse-integer",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-integer/"
            }
          ],
          "learningTip": [
            "Builds on digit manipulation: extract, process, build new number",
            "Pattern 'result = result * 10 + digit' constructs numbers digit by digit",
            "Same approach works for: string-to-int, parsing, number building",
            "Consider what happens at each step with negative numbers"
          ],
          "mustNotMiss": [
            "INTEGER OVERFLOW is the critical interview point",
            "32-bit signed range: -2,147,483,648 to 2,147,483,647",
            "Before result = result * 10 + digit, check if result > MAX/10",
            "Mention overflow handling proactively in interviews - it shows thoroughness"
          ]
        }
      ]
    },
    {
      "id": "time_space_complexity",
      "name": "Time/Space Complexity",
      "tier": 1,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "time_space_complexity_analysis",
          "name": "Time & Space Complexity",
          "estimatedHours": 2,
          "description": "Understand how to analyze code performance using time complexity",
          "learningTip": [
            "Every interview solution discussion ends with 'What's the complexity?'",
            "Think of Big O as describing how runtime grows with input size",
            "Space complexity counts extra memory, not including input",
            "Recursion uses O(depth) stack space - don't forget this"
          ],
          "mustNotMiss": [
            "O(1): constant - hashmap lookup, array access, arithmetic",
            "O(log n): logarithmic - binary search, balanced BST operations",
            "O(n): linear - single loop, hashmap construction",
            "O(n log n): efficient sorting (merge, quick, heap)",
            "O(n²): nested loops, comparing all pairs",
            "O(2ⁿ): subsets, backtracking without pruning"
          ]
        }
      ]
    },
    {
      "id": "arrays_easy_medium",
      "name": "Arrays - Easy/Medium",
      "tier": 2,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "remove_duplicates",
          "name": "Remove Duplicates",
          "estimatedHours": 2,
          "description": "Remove duplicate elements from a sorted array",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted Array",
              "slug": "remove-duplicates-from-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
            },
            {
              "name": "Remove Duplicates from Sorted Array II",
              "slug": "remove-duplicates-from-sorted-array-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/"
            }
          ],
          "learningTip": [
            "Two pointers: slow writes, fast scans",
            "In-place means modify array, return new length",
            "Pattern used in 30%+ of array problems",
            "Elements before slow pointer are the result"
          ],
          "mustNotMiss": [
            "let slow = 0 (write position)",
            "for (let fast = 1; fast < nums.length; fast++)",
            "If nums[fast] !== nums[slow]: slow++, nums[slow] = nums[fast]",
            "Return slow + 1 as new length"
          ]
        },
        {
          "id": "remove_element",
          "name": "Remove Element",
          "estimatedHours": 0.5,
          "description": "Remove specific elements from an array",
          "practiceQuestions": [
            {
              "name": "Remove Element",
              "slug": "remove-element",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-element/"
            }
          ],
          "learningTip": [
            "Similar to remove duplicates but even simpler",
            "Order doesn't matter - this allows swap-with-end strategy",
            "Two valid approaches: scan-and-shift or swap-with-end",
            "Always read problem constraints - they hint at the solution"
          ],
          "mustNotMiss": [
            "Approach 1: Two pointers from start, copy non-target values",
            "Approach 2: Swap with end when target found, shrink array",
            "Approach 2 is faster when removals are rare",
            "Both are O(n) time, O(1) space"
          ]
        },
        {
          "id": "reverse_string",
          "name": "Reverse String",
          "estimatedHours": 1,
          "description": "Reverse the characters of a string",
          "learningTip": [
            "Two pointers from ends, swap until they meet",
            "In JS, strings are immutable - convert to array first",
            "This is the foundational two-pointer pattern",
            "O(n) time, O(1) extra space (in-place)"
          ],
          "mustNotMiss": [
            "const chars = str.split('') - convert string to array",
            "Swap: [chars[l], chars[r]] = [chars[r], chars[l]]",
            "Move pointers: l++, r--",
            "Result: chars.join('')"
          ]
        },
        {
          "id": "best_time_buy_sell_stocks",
          "name": "Best Time to Buy and Sell Stocks",
          "estimatedHours": 1,
          "description": "Maximize profit from stock prices using smart strategy",
          "practiceQuestions": [
            {
              "name": "Best Time to Buy and Sell Stock",
              "slug": "best-time-to-buy-and-sell-stock",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
            }
          ],
          "learningTip": [
            "Track minimum price seen so far",
            "At each price, calculate potential profit",
            "This is Kadane's algorithm in disguise",
            "Single pass O(n), constant space O(1)"
          ],
          "mustNotMiss": [
            "let minPrice = Infinity, maxProfit = 0",
            "For each price: minPrice = Math.min(minPrice, price)",
            "maxProfit = Math.max(maxProfit, price - minPrice)",
            "Must buy before sell (time order matters)"
          ]
        },
        {
          "id": "merge_sorted_arrays",
          "name": "Merge Sorted Arrays",
          "estimatedHours": 1,
          "description": "Merge two sorted arrays into one sorted array",
          "practiceQuestions": [
            {
              "name": "Merge Sorted Array",
              "slug": "merge-sorted-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-sorted-array/"
            }
          ],
          "learningTip": [
            "Merging is fundamental - it's the heart of merge sort",
            "Key insight: merge from the BACK to avoid overwriting",
            "nums1 has extra space at the END, not the beginning",
            "Three pointers: end of nums1's elements, end of nums2, end of merged"
          ],
          "mustNotMiss": [
            "p1 = m-1, p2 = n-1, p = m+n-1",
            "Compare nums1[p1] and nums2[p2], place larger at nums1[p]",
            "Decrement the pointer of the placed element",
            "If p1 < 0, copy remaining nums2; if p2 < 0, nums1 is already in place"
          ]
        },
        {
          "id": "move_zeros",
          "name": "Move Zeros",
          "estimatedHours": 1,
          "description": "Move all zeros to the end of the array without changing order",
          "practiceQuestions": [
            {
              "name": "Move Zeroes",
              "slug": "move-zeroes",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/move-zeroes/"
            }
          ],
          "learningTip": [
            "Partition: non-zeros left, zeros right",
            "Two approaches: swap or overwrite-then-fill",
            "Same concept as QuickSort partition",
            "Maintain relative order of non-zeros"
          ],
          "mustNotMiss": [
            "let insertPos = 0 (next position for non-zero)",
            "for each num: if (num !== 0) nums[insertPos++] = num",
            "Fill remaining with zeros: while (insertPos < n) nums[insertPos++] = 0",
            "Or use swap approach for minimal writes"
          ]
        },
        {
          "id": "max_consecutive_ones",
          "name": "Max Consecutive Ones",
          "estimatedHours": 0.5,
          "description": "Find the maximum streak of 1s in a binary array",
          "practiceQuestions": [
            {
              "name": "Max Consecutive Ones",
              "slug": "max-consecutive-ones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/max-consecutive-ones/"
            }
          ],
          "learningTip": [
            "Introduction to streak counting pattern",
            "Track current streak and maximum streak separately",
            "Reset current streak when condition breaks",
            "Pattern applies to: longest streak of any value, consecutive sequences"
          ],
          "mustNotMiss": [
            "Initialize: currentStreak = 0, maxStreak = 0",
            "If 1: currentStreak++",
            "If 0: currentStreak = 0 (reset)",
            "Always: maxStreak = max(maxStreak, currentStreak)"
          ]
        },
        {
          "id": "missing_number",
          "name": "Missing Number",
          "estimatedHours": 0.5,
          "description": "Find the missing number in a sequence from 1 to N",
          "practiceQuestions": [
            {
              "name": "Missing Number",
              "slug": "missing-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/missing-number/"
            }
          ],
          "learningTip": [
            "Multiple elegant solutions exist",
            "Math formula, XOR, or sorting",
            "XOR solution is most interview-impressive",
            "Each approach teaches different technique"
          ],
          "mustNotMiss": [
            "Math: expected = n*(n+1)/2, actual = nums.reduce((a,b)=>a+b,0), missing = expected - actual",
            "XOR: result = n; for(i=0;i<n;i++) result ^= i ^ nums[i]",
            "XOR property: a^a=0, a^0=a",
            "Math is O(1) space but watch for overflow in other languages"
          ]
        },
        {
          "id": "single_number",
          "name": "Single Number",
          "estimatedHours": 0.5,
          "description": "Find the unique element in an array where all others are repeated",
          "practiceQuestions": [
            {
              "name": "Single Number",
              "slug": "single-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/single-number/"
            }
          ],
          "learningTip": [
            "XOR all elements - pairs cancel out",
            "Works because XOR is its own inverse",
            "Pure bit manipulation elegance",
            "Foundation for harder bit problems"
          ],
          "mustNotMiss": [
            "return nums.reduce((acc, num) => acc ^ num, 0)",
            "Every number XORed twice becomes 0",
            "Single number XORed once remains",
            "Only works when exactly one element appears once"
          ]
        }
      ]
    },
    {
      "id": "recursion_easy_medium",
      "name": "Recursion - Easy/Medium",
      "tier": 2,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "recursion_101",
          "name": "Recursion 101",
          "estimatedHours": 2.5,
          "description": "Understand the basics of recursion with clear explanations and examples",
          "practiceQuestions": [
            {
              "name": "Fibonacci Number",
              "slug": "fibonacci-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fibonacci-number/"
            }
          ],
          "learningTip": [
            "Recursion = function calling itself with smaller input",
            "Think of it as delegation: 'I handle this piece, delegate the rest'",
            "Every recursive function needs a base case and progress toward it",
            "Draw the recursion tree to visualize what's happening"
          ],
          "mustNotMiss": [
            "BASE CASE: when to stop (prevents infinite recursion)",
            "RECURSIVE CASE: the self-call with SMALLER input",
            "PROGRESS: each call must move toward the base case",
            "Space complexity of recursion = O(max_depth) due to call stack"
          ]
        },
        {
          "id": "sum_first_n_numbers",
          "name": "Sum of first n numbers",
          "estimatedHours": 1,
          "description": "Calculate the sum of the first n natural numbers using recursion",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "sum_array_numbers",
          "name": "Sum of all numbers in Array",
          "estimatedHours": 1,
          "description": "Find the sum of all elements in an array using simple logic",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "factorial_n",
          "name": "Factorial of n",
          "estimatedHours": 0.5,
          "description": "Learn how to calculate factorials using recursion",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "power_of_two",
          "name": "Power of Two",
          "estimatedHours": 0.5,
          "description": "Solve Power of Two problem with recursion and logic",
          "practiceQuestions": [
            {
              "name": "Power of Two",
              "slug": "power-of-two",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/power-of-two/"
            }
          ],
          "learningTip": [
            "Classic problem with multiple approaches",
            "Recursion: divide by 2 until you reach 1",
            "Bit manipulation: powers of 2 have exactly one bit set",
            "Choose approach based on interview context"
          ],
          "mustNotMiss": [
            "Recursion: isPowerOfTwo(n) = (n == 1) or (n > 0 and n % 2 == 0 and isPowerOfTwo(n/2))",
            "Bit trick: n & (n-1) == 0 for powers of 2",
            "Edge case: 0 is NOT a power of 2",
            "The bit trick is O(1) and most elegant"
          ]
        },
        {
          "id": "recursion_masterclass",
          "name": "Recursion Masterclass",
          "estimatedHours": 2,
          "description": "Master recursion with deep insights, patterns, and examples",
          "learningTip": [
            "Recursion is a method where the solution depends on solutions to smaller instances of the same problem. It requires visualizing the 'Call Stack'. Every recursive function has two parts:",
            "The Action (what logic happens now), and",
            "The Leap of Faith (trusting the recursive call returns the correct result)."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Base Case: This is non-negotiable. Without it, you get a StackOverflowError.",
            "Stack Overflow: Understand that deep recursion consumes memory.",
            "Pattern: Recursion is brilliant for Trees, Graphs, and Combinatorial problems (permutations/subsets), but risky for deep linear problems."
          ]
        }
      ]
    },
    {
      "id": "searching_sorting_easy_medium",
      "name": "Searching & Sorting - Easy/Medium",
      "tier": 2,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "linear_search",
          "name": "Linear Search",
          "estimatedHours": 0.5,
          "description": "Find an element in an array using linear search",
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "binary_search",
          "name": "Binary Search",
          "estimatedHours": 1,
          "description": "Find an element in a sorted array using binary search",
          "practiceQuestions": [
            {
              "name": "Binary Search",
              "slug": "binary-search",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-search/"
            },
            {
              "name": "Search Insert Position",
              "slug": "search-insert-position",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/search-insert-position/"
            }
          ],
          "learningTip": [
            "THE most important algorithm to master",
            "O(log n) search in sorted data",
            "Apply to any monotonic function",
            "Practice until you can write it perfectly every time"
          ],
          "mustNotMiss": [
            "let left = 0, right = arr.length - 1",
            "while (left <= right) - note the <=",
            "const mid = Math.floor((left + right) / 2) or left + Math.floor((right-left)/2)",
            "Update: left = mid + 1 or right = mid - 1"
          ]
        },
        {
          "id": "bubble_sort",
          "name": "Bubble Sort",
          "estimatedHours": 2,
          "description": "Sort an array using the bubble sort algorithm",
          "learningTip": [
            "Repeatedly swap adjacent elements if in wrong order",
            "Largest element 'bubbles' to end after each pass",
            "Rarely optimal but good for understanding",
            "Best case O(n) with early termination optimization"
          ],
          "mustNotMiss": [
            "Time: O(n²) worst/average, O(n) best with optimization",
            "Optimization: if no swaps in a pass, array is sorted - break early",
            "Stable sort (maintains relative order of equal elements)",
            "Space: O(1) in-place"
          ]
        },
        {
          "id": "selection_sort",
          "name": "Selection Sort",
          "estimatedHours": 0.5,
          "description": "Sort an array using the selection sort algorithm",
          "learningTip": [
            "Find minimum in unsorted portion, swap to front",
            "Simple mental model: 'select the smallest, put it next'",
            "Does exactly n swaps - good if swaps are expensive",
            "Not adaptive - always O(n²)"
          ],
          "mustNotMiss": [
            "Time: O(n²) always - no best case improvement",
            "Space: O(1) in-place",
            "NOT stable (swapping can change relative order)",
            "Does fewer swaps than bubble sort"
          ]
        },
        {
          "id": "insertion_sort",
          "name": "Insertion Sort",
          "estimatedHours": 1,
          "description": "Sort an array using the insertion sort algorithm",
          "learningTip": [
            "Build sorted array one element at a time",
            "Take next element, find its place, shift and insert",
            "Best for nearly-sorted data - O(n) in that case",
            "Used as base case in hybrid sorts like TimSort"
          ],
          "mustNotMiss": [
            "Time: O(n²) worst, O(n) best (nearly sorted)",
            "Online algorithm: can sort as elements arrive",
            "Stable sort",
            "Python and Java use TimSort (hybrid with insertion sort)"
          ]
        },
        {
          "id": "merge_sort",
          "name": "Merge Sort",
          "estimatedHours": 3,
          "description": "Learn how Merge Sort works using recursion and divide & conquer",
          "learningTip": [
            "Divide and conquer: split, sort halves, merge",
            "O(n log n) GUARANTEED - no bad cases",
            "Stable sort - maintains relative order",
            "The merge step is the key algorithm"
          ],
          "mustNotMiss": [
            "JS sort() is O(n log n) but this teaches the concept",
            "Split: const mid = Math.floor(arr.length/2)",
            "Merge: compare heads of sorted halves, take smaller",
            "Space: O(n) for temporary arrays"
          ]
        }
      ]
    },
    {
      "id": "linked_list_easy_medium",
      "name": "Linked List - Easy/Medium",
      "tier": 2,
      "estimatedHours": 17.5,
      "topics": [
        {
          "id": "introduction_linked_list",
          "name": "Introduction to Linked List",
          "estimatedHours": 1,
          "description": "Get started with the basics of Linked Lists",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "design_linked_list",
          "name": "Design Linked List",
          "estimatedHours": 0.5,
          "description": "Learn how to design and implement your own Linked List",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "adding_nodes_linked_list",
          "name": "Adding Nodes to Linked List",
          "estimatedHours": 2,
          "description": "Learn to insert nodes into a Linked List at various positions",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "deleting_nodes_linked_list",
          "name": "Deleting Nodes in Linked List",
          "estimatedHours": 0.5,
          "description": "Understand node deletion in a Linked List",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "middle_linked_list",
          "name": "Middle of Linked List",
          "estimatedHours": 0.5,
          "description": "Find the middle element in a Linked List efficiently",
          "practiceQuestions": [
            {
              "name": "Middle of the Linked List",
              "slug": "middle-of-the-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/middle-of-the-linked-list/"
            }
          ],
          "learningTip": [
            "Slow and fast pointer technique",
            "Fast moves 2 steps, slow moves 1",
            "When fast reaches end, slow is at middle",
            "Fundamental pattern for many problems"
          ],
          "mustNotMiss": [
            "let slow = head, fast = head",
            "while (fast && fast.next): slow = slow.next, fast = fast.next.next",
            "For even length, slow is second middle",
            "Used in: cycle detection, merge sort on lists"
          ]
        },
        {
          "id": "reverse_linked_list",
          "name": "Reverse Linked List",
          "estimatedHours": 0.5,
          "description": "Reverse a Linked List in-place using iteration",
          "practiceQuestions": [
            {
              "name": "Reverse Linked List",
              "slug": "reverse-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-linked-list/"
            },
            {
              "name": "Reverse Linked List II",
              "slug": "reverse-linked-list-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-linked-list-ii/"
            }
          ],
          "learningTip": [
            "THE most-asked linked list question",
            "Three pointers: prev, curr, next",
            "Know iterative and recursive",
            "Practice until automatic"
          ],
          "mustNotMiss": [
            "let prev = null, curr = head",
            "while (curr): next = curr.next, curr.next = prev, prev = curr, curr = next",
            "Return prev (new head)",
            "Recursive: reverse rest, then rewire"
          ]
        },
        {
          "id": "linked_list_cycle_hash_table",
          "name": "Linked List Cycle - Hash Table",
          "estimatedHours": 1,
          "description": "Detect cycles in a Linked List using extra space",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle",
              "slug": "linked-list-cycle",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/linked-list-cycle/"
            }
          ],
          "learningTip": [
            "Store visited nodes in a set. If you see a node again, there's a cycle. O(n) time and O(n) space."
          ],
          "mustNotMiss": [
            "Simple approach: HashSet<Node> visited. While traversing: if visited.contains(current), cycle found at 'current'. Else add to visited and continue. If you reach null, no cycle. This is the intuitive solution. Interview follow-up is ALWAYS: 'Can you do it without extra space?' Answer: Floyd's Cycle Detection Algorithm (next topic)."
          ]
        },
        {
          "id": "linked_list_cycle_floyd",
          "name": "Linked List Cycle - Floyd's Algorithm",
          "estimatedHours": 1,
          "description": "Detect cycles with Floyd's Tortoise & Hare algorithm",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle II",
              "slug": "linked-list-cycle-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/linked-list-cycle-ii/"
            }
          ],
          "learningTip": [
            "Floyd's Tortoise and Hare algorithm",
            "Slow moves 1, fast moves 2 - if they meet, cycle exists",
            "If fast reaches null, no cycle",
            "Finding cycle START is the clever part"
          ],
          "mustNotMiss": [
            "Detection: if slow == fast at any point, cycle exists",
            "Find cycle start: after detection, reset slow to head",
            "Move both by 1 - they meet at cycle start",
            "Know the math: the meeting point proof is sometimes asked"
          ]
        },
        {
          "id": "palindrome_linked_list",
          "name": "Palindrome Linked List",
          "estimatedHours": 2,
          "description": "Check if a Linked List is a palindrome",
          "practiceQuestions": [
            {
              "name": "Palindrome Linked List",
              "slug": "palindrome-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-linked-list/"
            }
          ],
          "learningTip": [
            "Combines three techniques in one problem",
            "Find middle → reverse second half → compare",
            "O(n) time, O(1) space solution",
            "Tests your mastery of previous linked list patterns"
          ],
          "mustNotMiss": [
            "Use slow/fast to find middle",
            "Reverse from middle to end",
            "Compare node by node from head and from reversed middle",
            "Follow-up: restore list by reversing second half again"
          ]
        },
        {
          "id": "intersection_two_linked_lists",
          "name": "Intersection of two Linked Lists",
          "estimatedHours": 0.5,
          "description": "Find the intersection node of two Linked Lists",
          "practiceQuestions": [
            {
              "name": "Intersection of Two Linked Lists",
              "slug": "intersection-of-two-linked-lists",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
            }
          ],
          "learningTip": [
            "Where two linked lists merge. Key insight: If you know the length difference, you can align and compare."
          ],
          "mustNotMiss": [
            "Approach 1: Get lengths, advance longer list by difference, then traverse together until match. O(n+m) time. Approach 2 (Elegant): Two pointers, each traverses both lists. When p1 reaches end of A, redirect to head of B. When p2 reaches end of B, redirect to head of A. They'll meet at intersection (or both reach null if no intersection). Why? Both travel distance (lenA + lenB), so they're aligned when they 'swap'. This is a beautiful insight."
          ]
        },
        {
          "id": "remove_linked_list_elements",
          "name": "Remove Linked List Elements",
          "estimatedHours": 0.5,
          "description": "Remove nodes with a specific value from a Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Linked List Elements",
              "slug": "remove-linked-list-elements",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-linked-list-elements/"
            }
          ],
          "learningTip": [
            "Remove all nodes with a given value. The DUMMY HEAD technique handles edge cases cleanly."
          ],
          "mustNotMiss": [
            "Create dummy with dummy.next = head. Use prev = dummy, curr = head. If curr.val == val, prev.next = curr.next (skip curr). Else, prev = curr. Always advance curr. Return dummy.next. Why dummy? If head itself needs removal, dummy handles it - no special case needed. This is cleaner than checking 'if head needs removal' separately."
          ]
        },
        {
          "id": "remove_nth_node_end_two_pass",
          "name": "Remove nth node from end of List - Two Pass",
          "estimatedHours": 0.5,
          "description": "Remove the nth node from the end using a two-pass method",
          "learningTip": [
            "First pass: count nodes. Second pass: remove the (length - n + 1)th node. Simple but requires two traversals."
          ],
          "mustNotMiss": [
            "Count nodes in first pass. In second pass, stop at position (length - n). That's the node BEFORE the one to remove. Do prev.next = prev.next.next. Edge case: removing head (n == length). Use dummy head OR special case it. Time O(n), Space O(1). This is straightforward; one-pass version is more elegant."
          ]
        },
        {
          "id": "remove_nth_node_end_one_pass",
          "name": "Remove nth Node from end - One Pass",
          "estimatedHours": 1,
          "description": "Remove the nth node from the end in one pass using two pointers",
          "practiceQuestions": [
            {
              "name": "Remove Nth Node From End of List",
              "slug": "remove-nth-node-from-end-of-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
            }
          ],
          "learningTip": [
            "Two pointers with a gap of n. When fast reaches end, slow is at the node BEFORE the one to remove."
          ],
          "mustNotMiss": [
            "Algorithm: Move fast n steps ahead. Then move both until fast reaches last node (or null depending on setup). Now slow.next is the node to remove. Do slow.next = slow.next.next. Use dummy head: If removing the head itself (fast ends up at null after n steps), dummy handles it. The 'gap technique' generalizes: To find kth from end, maintain k-gap between pointers."
          ]
        },
        {
          "id": "remove_duplicates_sorted_list",
          "name": "Remove Duplicates from Sorted List",
          "estimatedHours": 0.5,
          "description": "Remove consecutive duplicates from a sorted Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted List",
              "slug": "remove-duplicates-from-sorted-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
            }
          ],
          "learningTip": [
            "Compare current with next. If same value, skip next. If different, move forward. List is sorted, so duplicates are adjacent."
          ],
          "mustNotMiss": [
            "Algorithm: while(curr != null && curr.next != null) { if(curr.val == curr.next.val) curr.next = curr.next.next; else curr = curr.next; }. Note: When removing, DON'T advance curr - there might be more duplicates. Only advance when values differ. This is O(n) time, O(1) space. Compare with 'Remove Duplicates from Sorted List II' which removes ALL duplicates (need prev pointer)."
          ]
        },
        {
          "id": "odd_even_linked_list",
          "name": "Odd Even Linked List",
          "estimatedHours": 0.5,
          "description": "Rearrange nodes based on their position (odd/even index)",
          "practiceQuestions": [
            {
              "name": "Odd Even Linked List",
              "slug": "odd-even-linked-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/odd-even-linked-list/"
            }
          ],
          "learningTip": [
            "Separate into odd-indexed and even-indexed nodes, then concatenate. Indices are 1-based (first node is odd)."
          ],
          "mustNotMiss": [
            "Algorithm: odd = head, even = head.next, evenHead = even. While(even != null && even.next != null) { odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next; }. Then odd.next = evenHead (connect tails). Key: Save evenHead at start - you need it to connect after separation. Time O(n), Space O(1). The interlaced pointer updates can be confusing - trace through a 5-node example."
          ]
        },
        {
          "id": "add_two_numbers",
          "name": "Add Two Numbers",
          "estimatedHours": 1,
          "description": "Add two numbers represented as Linked Lists",
          "practiceQuestions": [
            {
              "name": "Add Two Numbers",
              "slug": "add-two-numbers",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/add-two-numbers/"
            }
          ],
          "learningTip": [
            "Digit-by-digit addition with carry",
            "Lists are in REVERSE order (units digit first)",
            "Reverse order actually makes addition easier",
            "Simulate elementary school addition"
          ],
          "mustNotMiss": [
            "digit = (val1 + val2 + carry) % 10",
            "carry = (val1 + val2 + carry) / 10",
            "Handle different lengths: treat missing as 0",
            "After loop: if carry > 0, add one more node"
          ]
        },
        {
          "id": "merge_two_sorted_lists",
          "name": "Merge Two Sorted Lists",
          "estimatedHours": 1,
          "description": "Merge two sorted Linked Lists into one",
          "practiceQuestions": [
            {
              "name": "Merge Two Sorted Lists",
              "slug": "merge-two-sorted-lists",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-two-sorted-lists/"
            }
          ],
          "learningTip": [
            "Compare heads, take smaller, advance that pointer",
            "Same logic used in merge sort's merge step",
            "Use dummy head to simplify code",
            "Both iterative and recursive solutions are clean"
          ],
          "mustNotMiss": [
            "Create dummy, current = dummy",
            "Compare l1.val and l2.val, attach smaller to current.next",
            "When one list exhausted, attach remaining of other",
            "Return dummy.next (the real head)"
          ]
        },
        {
          "id": "rotate_list",
          "name": "Rotate List",
          "estimatedHours": 1,
          "description": "Rotate a Linked List to the right by k places",
          "practiceQuestions": [
            {
              "name": "Rotate List",
              "slug": "rotate-list",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-list/"
            }
          ],
          "learningTip": [
            "Rotate right by k means: move last k nodes to front. Key: k can be larger than length, so use k % length."
          ],
          "mustNotMiss": [
            "Algorithm:",
            "Find length and tail.",
            "k = k % length. If k == 0, return head.",
            "Make circular: tail.next = head.",
            "Move (length - k) steps from tail to find new tail.",
            "New head = newTail.next.",
            "Break circle: newTail.next = null. The insight is making it circular first, then finding where to 'cut'. This avoids moving nodes - just pointer rewiring."
          ]
        },
        {
          "id": "swap_nodes_pairs_iterative",
          "name": "Swap Nodes in Pairs - Iterative Approach",
          "estimatedHours": 1,
          "description": "Swap every two adjacent nodes in a Linked List iteratively",
          "practiceQuestions": [
            {
              "name": "Swap Nodes in Pairs",
              "slug": "swap-nodes-in-pairs",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/swap-nodes-in-pairs/"
            }
          ],
          "learningTip": [
            "Swap every two adjacent nodes",
            "Use dummy head for clean code",
            "Track prev, first, second nodes",
            "Rewire pointers carefully"
          ],
          "mustNotMiss": [
            "const dummy = {next: head}; let prev = dummy;",
            "while(prev.next && prev.next.next) { const first = prev.next, second = first.next; first.next = second.next; second.next = first; prev.next = second; prev = first; }",
            "prev becomes first after swap (first is now second in pair)",
            "return dummy.next"
          ]
        },
        {
          "id": "swap_nodes_pairs_recursive",
          "name": "Swap Nodes in Pair - Recursive Approach",
          "estimatedHours": 1,
          "description": "Recursively swap every two adjacent nodes in a Linked List",
          "learningTip": [
            "Recursive approach: swap first pair, recurse on rest",
            "Base: 0 or 1 node - return as is",
            "Elegant but uses O(n) stack space",
            "Good for understanding recursion"
          ],
          "mustNotMiss": [
            "const swapPairs = head => { if(!head || !head.next) return head; const second = head.next; head.next = swapPairs(second.next); second.next = head; return second; }",
            "Recursion handles remaining pairs",
            "Return new head (second node)",
            "Stack space O(n/2)"
          ]
        }
      ]
    },
    {
      "id": "strings_easy_medium",
      "name": "Strings - Easy/Medium",
      "tier": 2,
      "estimatedHours": 13.5,
      "topics": [
        {
          "id": "length_last_word_two_loops",
          "name": "Length of Last Word - Approach 1 - Two Loops",
          "estimatedHours": 1,
          "description": "Find the length of the last word using a basic loop approach",
          "learningTip": [
            "Classic string traversal problem",
            "Two pass: first find end of last word, then count backwards",
            "Understanding string indexing and whitespace handling",
            "In JS: str.trim() removes leading/trailing spaces"
          ],
          "mustNotMiss": [
            "Handle trailing spaces: 'hello world   ' should return 5",
            "JS approach: str.trim().split(/\\s+/).pop().length",
            "Or iterate from end: skip spaces, then count until space or start",
            "Edge case: single word, all spaces, empty string"
          ]
        },
        {
          "id": "length_last_word_one_loop",
          "name": "Length of Last Word - Approach 2 - One Loop",
          "estimatedHours": 1,
          "description": "Optimized one-pass solution to find the last word's length",
          "practiceQuestions": [
            {
              "name": "Length of Last Word",
              "slug": "length-of-last-word",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/length-of-last-word/"
            }
          ],
          "learningTip": [
            "Optimized single pass from the end",
            "State machine: skip trailing spaces, then count word",
            "More efficient but slightly more complex logic",
            "Good for understanding index manipulation"
          ],
          "mustNotMiss": [
            "let i = str.length - 1; while(i >= 0 && str[i] === ' ') i--;",
            "let end = i; while(i >= 0 && str[i] !== ' ') i--;",
            "Length = end - i",
            "Time O(n), Space O(1) - no extra string creation"
          ]
        },
        {
          "id": "find_words_containing_character",
          "name": "Find Words Containing Character",
          "estimatedHours": 0.5,
          "description": "Find words from a list that contain a specific character",
          "practiceQuestions": [
            {
              "name": "Find Words Containing Character",
              "slug": "find-words-containing-character",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-words-containing-character/"
            }
          ],
          "learningTip": [
            "Array filtering with string search",
            "Use includes() for character presence check",
            "Return indices of matching words",
            "Classic filter + map pattern in JS"
          ],
          "mustNotMiss": [
            "words.map((w, i) => w.includes(char) ? i : -1).filter(i => i !== -1)",
            "Or: words.reduce((acc, w, i) => w.includes(char) ? [...acc, i] : acc, [])",
            "Or traditional loop for better performance on large arrays",
            "includes() is case-sensitive - convert if needed"
          ]
        },
        {
          "id": "jewels_stones",
          "name": "Jewels and Stones",
          "estimatedHours": 1,
          "description": "Count how many stones are also jewels",
          "practiceQuestions": [
            {
              "name": "Jewels and Stones",
              "slug": "jewels-and-stones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/jewels-and-stones/"
            }
          ],
          "learningTip": [
            "Set for O(1) lookup of jewel types",
            "Count stones that are jewels",
            "Hash set is perfect when checking membership",
            "Clean functional approach in JS"
          ],
          "mustNotMiss": [
            "const jewelSet = new Set(jewels)",
            "return stones.split('').filter(s => jewelSet.has(s)).length",
            "Or: [...stones].reduce((count, s) => count + (jewelSet.has(s) ? 1 : 0), 0)",
            "Time O(j + s), Space O(j) where j=jewels length, s=stones length"
          ]
        },
        {
          "id": "find_most_frequent_vowel_consonant",
          "name": "Find Most Frequent Vowel and Consonant",
          "estimatedHours": 2,
          "description": "Identify the most frequent vowel and consonant in a string",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "split_string_balanced",
          "name": "Split a String in Balanced Strings",
          "estimatedHours": 0.5,
          "description": "Split a string into maximum balanced substrings",
          "practiceQuestions": [
            {
              "name": "Split a String in Balanced Strings",
              "slug": "split-a-string-in-balanced-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/split-a-string-in-balanced-strings/"
            }
          ],
          "learningTip": [
            "Count balance: +1 for R, -1 for L (or vice versa)",
            "Substring is balanced when count returns to 0",
            "Greedy: split as soon as balanced",
            "Simple counter approach"
          ],
          "mustNotMiss": [
            "let count = 0, result = 0; for(const c of s) { count += c === 'R' ? 1 : -1; if(count === 0) result++; }",
            "Each time count hits 0, we found a balanced split",
            "Greedy gives maximum number of splits",
            "Time O(n), Space O(1)"
          ]
        },
        {
          "id": "reverse_string_ii",
          "name": "Reverse String II",
          "estimatedHours": 2,
          "description": "Reverse parts of a string based on a pattern",
          "practiceQuestions": [
            {
              "name": "Reverse String II",
              "slug": "reverse-string-ii",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-string-ii/"
            }
          ],
          "learningTip": [
            "Reverse first k chars of every 2k chunk",
            "Understanding chunk-based string processing",
            "Modulo arithmetic for determining action",
            "String manipulation with array conversion in JS"
          ],
          "mustNotMiss": [
            "Process in chunks of 2k, reverse first k of each",
            "const arr = s.split(''); for(let i = 0; i < arr.length; i += 2*k) { reverse(arr, i, Math.min(i+k-1, arr.length-1)); }",
            "Reverse helper: while(l < r) [arr[l], arr[r]] = [arr[r], arr[l]], l++, r--",
            "Handle remaining: if less than k left, reverse all; if k to 2k, reverse first k"
          ]
        },
        {
          "id": "valid_palindrome_extra_space",
          "name": "Valid Palindrome - Approach 1 - Extra Space",
          "estimatedHours": 0.5,
          "description": "Check palindrome by cleaning and reversing a string",
          "learningTip": [
            "Filter alphanumeric, convert to lowercase, check if equals its reverse. Clean but uses O(n) space."
          ],
          "mustNotMiss": [
            "Algorithm: newStr = ''.join(c.lower() for c in s if c.isalnum()). Return newStr == newStr[::-1]. Creates new filtered string and its reverse. Time O(n), Space O(n). This is acceptable for first solution, but interviewer will likely ask: 'Can you do it in O(1) space?' Answer: Two pointers (next topic)."
          ]
        },
        {
          "id": "valid_palindrome_two_pointers",
          "name": "Valid Palindrome - Approach 2 - Two Pointers",
          "estimatedHours": 0.5,
          "description": "Use two-pointer technique to validate palindrome",
          "practiceQuestions": [
            {
              "name": "Valid Palindrome",
              "slug": "valid-palindrome",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-palindrome/"
            }
          ],
          "learningTip": [
            "Skip non-alphanumeric from both ends, compare lowercase characters. O(1) space solution."
          ],
          "mustNotMiss": [
            "Algorithm: left = 0, right = len-",
            "While left < right: skip non-alnum characters from left and right; if left >= right, break (all processed); if lower(s[left]) != lower(s[right]), return false; left++; right--. Return true. Use Character.isLetterOrDigit() in Java, c.isalnum() in Python. Time O(n), Space O",
            "This is the expected solution."
          ]
        },
        {
          "id": "largest_odd_number_string",
          "name": "Largest Odd Number in a String",
          "estimatedHours": 0.5,
          "description": "Find the largest odd number that can be formed from a string",
          "practiceQuestions": [
            {
              "name": "Largest Odd Number in String",
              "slug": "largest-odd-number-in-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/largest-odd-number-in-string/"
            }
          ],
          "learningTip": [
            "A number is odd if its last digit is odd. Find the rightmost odd digit and return the substring up to it."
          ],
          "mustNotMiss": [
            "Algorithm: Scan from right. Find first odd digit (1,3,5,7,",
            "Return s[:index+1]. If no odd digit, return ''. Why does this work? Any prefix ending at an odd digit forms an odd number. The LARGEST such prefix ends at the rightmost odd digit. Time O(n), Space O",
            "No need to parse or convert the number - just character checking."
          ]
        },
        {
          "id": "longest_common_prefix",
          "name": "Longest Common Prefix",
          "estimatedHours": 0.5,
          "description": "Find the longest common starting substring among strings",
          "practiceQuestions": [
            {
              "name": "Longest Common Prefix",
              "slug": "longest-common-prefix",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/longest-common-prefix/"
            }
          ],
          "learningTip": [
            "Compare character by character across all strings. Stop when mismatch found or any string ends."
          ],
          "mustNotMiss": [
            "Approach 1 (Vertical): Compare first chars of all strings. If all match, move to second chars. Continue until mismatch or end. Time O(S) where S is sum of all characters. Approach 2 (Horizontal): LCP of first two, then LCP of that result with third, etc. Same complexity. Approach 3: Sort strings, LCP of first and last only (they're most different). Trade-offs: Sorting is O(n*m*log n) but then comparison is O(m)."
          ]
        },
        {
          "id": "valid_anagram",
          "name": "Valid Anagram",
          "estimatedHours": 1,
          "description": "Check if two strings are anagrams of each other",
          "practiceQuestions": [
            {
              "name": "Valid Anagram",
              "slug": "valid-anagram",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-anagram/"
            }
          ],
          "learningTip": [
            "Two strings are anagrams if they have same characters with same frequencies",
            "Compare sorted strings or character counts",
            "Sort is O(n log n), count is O(n)",
            "Count approach handles follow-up with Unicode"
          ],
          "mustNotMiss": [
            "Sort: s.split('').sort().join('') === t.split('').sort().join('')",
            "Count: if(s.length !== t.length) return false; const count = new Map(); for(const c of s) count.set(c, (count.get(c)||0)+1); for(const c of t) { if(!count.get(c)) return false; count.set(c, count.get(c)-1); }",
            "return true; // all counts should be zero",
            "Early return on length mismatch"
          ]
        },
        {
          "id": "isomorphic_strings",
          "name": "Isomorphic Strings",
          "estimatedHours": 1,
          "description": "Check if two strings have a one-to-one character mapping",
          "practiceQuestions": [
            {
              "name": "Isomorphic Strings",
              "slug": "isomorphic-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/isomorphic-strings/"
            }
          ],
          "learningTip": [
            "Each character in s maps to exactly one character in t AND vice versa. Two-way mapping required."
          ],
          "mustNotMiss": [
            "Use two maps: s_to_t and t_to_s. For each position: if mapping exists, verify consistency. If not, create new mapping in BOTH directions. If inconsistency found, return false. Example: 'egg' -> 'add' works (e->a, g->d). 'egg' -> 'acd' fails (g maps to c first, then d). 'ab' -> 'aa' fails (different chars mapping to same). Both directions matter!"
          ]
        },
        {
          "id": "group_anagrams_sorted_key",
          "name": "Group Anagrams - Approach 1 - Sorted Key",
          "estimatedHours": 0.5,
          "description": "Group words that are anagrams using sorted string keys",
          "learningTip": [
            "Sort each string to use as a dictionary key. All anagrams produce the same sorted key."
          ],
          "mustNotMiss": [
            "Algorithm: Create HashMap<String, List<String>>. For each word, key = sorted word. Append word to map[key]. Return map.values(). Time O(n * k log k) where k is max word length (sorting each word). Space O(n * k). This is the simple, intuitive approach. Sorting is the bottleneck."
          ]
        },
        {
          "id": "group_anagrams_hashed_key",
          "name": "Group Anagrams - Approach 2 - Hashed Key",
          "estimatedHours": 1,
          "description": "Group anagrams using character frequency hash as key",
          "practiceQuestions": [
            {
              "name": "Group Anagrams",
              "slug": "group-anagrams",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/group-anagrams/"
            }
          ],
          "learningTip": [
            "Use character counts as key instead of sorted string. Avoids sorting cost."
          ],
          "mustNotMiss": [
            "Algorithm: For each word, create count array of 26 zeros. Count characters. Convert to tuple or string as key. This is O(n * k) - no sorting. Key format example: '#1#0#0#...' (count of each letter). Or in Python, use tuple(counts). This is faster for longer strings where k log k > 26. Space is same. Know both approaches and when each is better."
          ]
        }
      ]
    },
    {
      "id": "stack_queues",
      "name": "Stack and Queues",
      "tier": 2,
      "estimatedHours": 16.5,
      "topics": [
        {
          "id": "introduction_stacks_queues",
          "name": "Introduction to Stacks & Queues",
          "estimatedHours": 1,
          "description": "Get introduced to the fundamentals of Stacks and Queues",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "playing_stacks_queues",
          "name": "Playing with Stacks & Queues",
          "estimatedHours": 0.5,
          "description": "Explore basic operations on stacks and queues hands-on",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "implement_stack_two_queues",
          "name": "Implement Stack using Two Queues",
          "estimatedHours": 2,
          "description": "Build a stack using two queues",
          "practiceQuestions": [
            {
              "name": "Implement Stack using Queues",
              "slug": "implement-stack-using-queues",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-stack-using-queues/"
            }
          ],
          "learningTip": [
            "One queue is main, other is helper. Make either push O(n) or pop O(n), not both."
          ],
          "mustNotMiss": [
            "Approach 1 (Push O(n)): To push, enqueue to q",
            "Dequeue all from q1 to q",
            "Swap q1/q",
            "Now q1 has elements in stack order. Pop/top from q1 front is O",
            "Approach 2 (Pop O(n)): Push to q1 is O",
            "To pop, dequeue all but last from q1 to q",
            "Return the last. Swap q1/q",
            "Know at least one approach well."
          ]
        },
        {
          "id": "implement_stack_one_queue",
          "name": "Implement Stack using One Queue",
          "estimatedHours": 0.5,
          "description": "Implement a stack using a single queue cleverly",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "implement_queue_stacks",
          "name": "Implement Queue using Stacks",
          "estimatedHours": 1,
          "description": "Simulate a queue using two stacks",
          "practiceQuestions": [
            {
              "name": "Implement Queue using Stacks",
              "slug": "implement-queue-using-stacks",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-queue-using-stacks/"
            }
          ],
          "learningTip": [
            "Two stacks: inbox for push, outbox for pop/peek",
            "Pour inbox into outbox when outbox empty",
            "Pouring reverses order - LIFO becomes FIFO",
            "Amortized O(1) for all operations"
          ],
          "mustNotMiss": [
            "this.inbox = []; this.outbox = [];",
            "push(x): this.inbox.push(x)",
            "pop/peek: if outbox empty, move all from inbox; while(inbox.length) outbox.push(inbox.pop())",
            "Each element moves at most twice - amortized O(1)"
          ]
        },
        {
          "id": "valid_parentheses",
          "name": "Valid Parentheses",
          "estimatedHours": 1,
          "description": "Check if a string of parentheses is valid",
          "practiceQuestions": [
            {
              "name": "Valid Parentheses",
              "slug": "valid-parentheses",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-parentheses/"
            }
          ],
          "learningTip": [
            "Stack is perfect for matching nested structures",
            "Push opening brackets, pop and check match for closing",
            "Empty stack + end of string = valid",
            "Template for all bracket/nesting problems"
          ],
          "mustNotMiss": [
            "const map = {')':'(', '}':'{', ']':'['}, stack = []",
            "for(const c of s) { if('({['.includes(c)) stack.push(c); else if(stack.pop() !== map[c]) return false; }",
            "return stack.length === 0",
            "Edge cases: empty string (valid), single bracket (invalid), only opens (invalid)"
          ]
        },
        {
          "id": "min_stack",
          "name": "Min Stack",
          "estimatedHours": 1,
          "description": "Design a stack that supports retrieving the minimum in O(1)",
          "practiceQuestions": [
            {
              "name": "Min Stack",
              "slug": "min-stack",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-stack/"
            }
          ],
          "learningTip": [
            "Design stack with O(1) getMin operation",
            "Key insight: track minimum at each level",
            "When we pop, we need previous minimum",
            "Two approaches: pairs or auxiliary stack"
          ],
          "mustNotMiss": [
            "Approach 1: Store [value, currentMin] pairs - stack.push([val, Math.min(val, this.getMin())])",
            "Approach 2: Separate minStack, push when new value ≤ current min",
            "getMin: return stack[stack.length-1][1] or minStack[minStack.length-1]",
            "All operations O(1) time, O(n) space"
          ]
        },
        {
          "id": "remove_outermost_parentheses_stack",
          "name": "Remove Outermost Parentheses - Using Stack",
          "estimatedHours": 1,
          "description": "Remove outermost parentheses using a stack-based approach",
          "practiceQuestions": [
            {
              "name": "Remove Outermost Parentheses",
              "slug": "remove-outermost-parentheses",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-outermost-parentheses/"
            }
          ],
          "learningTip": [
            "Stack approach: Push '(' but only add to result if stack was non-empty. Pop for ')' but only add if stack still non-empty after."
          ],
          "mustNotMiss": [
            "Algorithm: For '(': if stack non-empty, add to result. Push. For ')': Pop. If stack still non-empty, add to result. The outermost '(' and ')' are skipped because stack is empty at those points. Counter method is simpler for this problem, but stack generalizes to more complex scenarios."
          ]
        },
        {
          "id": "remove_outermost_parentheses_no_stack",
          "name": "Remove Outermost Parentheses - without Stack",
          "estimatedHours": 0.5,
          "description": "Remove outer parentheses without using a stack",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "evaluate_reverse_polish_notation",
          "name": "Evaluate Reverse Polish Notation",
          "estimatedHours": 2,
          "description": "Evaluate mathematical expressions in postfix notation",
          "practiceQuestions": [
            {
              "name": "Evaluate Reverse Polish Notation",
              "slug": "evaluate-reverse-polish-notation",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
            }
          ],
          "learningTip": [
            "Stack-based evaluation. Numbers push to stack. Operators pop two operands, compute result, push back."
          ],
          "mustNotMiss": [
            "Algorithm: For each token: if number, push. If operator, pop b, pop a (order matters!), compute a op b, push result. Final answer is stack top. ORDER IS CRITICAL: For '/' and '-', it's a/b and a-b where a was pushed before b. Common error: Reversing operand order. Integer division: In many languages, truncate toward zero (-7/2 = -3, not -4). Handle this per problem requirements."
          ]
        },
        {
          "id": "next_greater_element",
          "name": "Next Greater Element",
          "estimatedHours": 2,
          "description": "Find the next greater element for each number in an array",
          "practiceQuestions": [
            {
              "name": "Next Greater Element I",
              "slug": "next-greater-element-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/next-greater-element-i/"
            }
          ],
          "learningTip": [
            "Monotonic stack pattern",
            "Stack stores elements awaiting their next greater",
            "Pop smaller elements when larger found",
            "Each element pushed/popped at most once → O(n)"
          ],
          "mustNotMiss": [
            "const stack = [], result = new Array(n).fill(-1)",
            "For each element: pop all smaller, current is their answer",
            "Push current index to stack",
            "Stack maintains decreasing order"
          ]
        },
        {
          "id": "daily_temperatures",
          "name": "Daily Temperatures",
          "estimatedHours": 1,
          "description": "Find how many days until a warmer temperature",
          "practiceQuestions": [
            {
              "name": "Daily Temperatures",
              "slug": "daily-temperatures",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/daily-temperatures/"
            }
          ],
          "learningTip": [
            "Classic monotonic stack problem",
            "Stack stores indices of days waiting for warmer day",
            "Pop when current temp is warmer - calculate distance",
            "Answer is index difference"
          ],
          "mustNotMiss": [
            "const result = new Array(n).fill(0), stack = []",
            "for(let i = 0; i < n; i++) { while(stack.length && temps[stack.at(-1)] < temps[i]) { const j = stack.pop(); result[j] = i - j; } stack.push(i); }",
            "Remaining in stack have no warmer day (already 0)",
            "Time O(n) - each index pushed and popped at most once"
          ]
        },
        {
          "id": "next_greater_element_ii",
          "name": "Next Greater Element - II",
          "estimatedHours": 1,
          "description": "Solve the circular version of Next Greater Element",
          "practiceQuestions": [
            {
              "name": "Next Greater Element II",
              "slug": "next-greater-element-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/next-greater-element-ii/"
            }
          ],
          "learningTip": [
            "Circular array - iterate twice (or use modulo)",
            "Same monotonic stack concept",
            "Second pass finds answers for elements that wrap around",
            "Store indices not values in stack"
          ],
          "mustNotMiss": [
            "const result = new Array(n).fill(-1), stack = []",
            "for(let i = 0; i < 2*n; i++) { const idx = i % n; while(stack.length && nums[stack.at(-1)] < nums[idx]) result[stack.pop()] = nums[idx]; if(i < n) stack.push(idx); }",
            "Only push indices during first pass (i < n)",
            "Time O(n), Space O(n)"
          ]
        },
        {
          "id": "rotting_oranges",
          "name": "Rotting Oranges",
          "estimatedHours": 2,
          "description": "BFS algorithm to find time for all oranges to rot",
          "practiceQuestions": [
            {
              "name": "Rotting Oranges",
              "slug": "rotting-oranges",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotting-oranges/"
            }
          ],
          "learningTip": [
            "Multi-source BFS - all rotten oranges are sources",
            "Track time as levels of BFS",
            "At each minute, adjacent fresh oranges become rotten",
            "Check if any fresh remains at end"
          ],
          "mustNotMiss": [
            "Collect all initial rotten oranges in queue, count fresh",
            "const queue = []; let fresh = 0; // scan grid to populate",
            "BFS level by level: minutes = queue processing rounds (minus 1 if started non-empty)",
            "return fresh === 0 ? minutes : -1"
          ]
        }
      ]
    },
    {
      "id": "binary_search_algorithm",
      "name": "Binary Search Algorithm",
      "tier": 3,
      "estimatedHours": 29,
      "topics": [
        {
          "id": "square_root_x",
          "name": "Square Root of X",
          "estimatedHours": 2.5,
          "description": "Find the square root of a number using binary search",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "best_practice_finding_middle",
          "name": "Best Practice - Finding Middle Element",
          "estimatedHours": 1,
          "description": "Learn the safe and optimal way to find the middle index",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "guess_higher_lower",
          "name": "Guess Higher or Lower",
          "estimatedHours": 1,
          "description": "Use binary search to guess a hidden number",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "search_rotated_sorted_array",
          "name": "Search in Rotated Sorted Array",
          "estimatedHours": 4,
          "description": "Search an element in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Search in Rotated Sorted Array",
              "slug": "search-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
            }
          ],
          "learningTip": [
            "Two sorted halves - one around mid is always sorted",
            "Determine which half is sorted",
            "Check if target is in sorted half",
            "This is a favorite interview question"
          ],
          "mustNotMiss": [
            "If nums[left] <= nums[mid] → left half is sorted",
            "If target in [nums[left], nums[mid]], search left; else right",
            "If right half sorted: check if target in range",
            "Handle duplicates: skip with left++ or right--"
          ]
        },
        {
          "id": "first_bad_version",
          "name": "First Bad Version",
          "estimatedHours": 2.5,
          "description": "Identify the first bad version using binary search",
          "practiceQuestions": [
            {
              "name": "First Bad Version",
              "slug": "first-bad-version",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/first-bad-version/"
            }
          ],
          "learningTip": [
            "Binary search on a boolean predicate. Instead of searching for a value, you search for where the predicate changes from false to true."
          ],
          "mustNotMiss": [
            "This is the 'find first true' pattern. Template: while (left < right) { if (isBadVersion(mid)) right = mid; else left = mid + 1; } return left. Why 'left < right' and not 'left <= right'? Because we're converging to a point, not searching for a value. When loop ends, left == right, pointing to first bad version. This exact template solves many 'find first/last' problems."
          ]
        },
        {
          "id": "find_peak_element",
          "name": "Find Peak Element",
          "estimatedHours": 3,
          "description": "Locate a peak element using binary search",
          "practiceQuestions": [
            {
              "name": "Find Peak Element",
              "slug": "find-peak-element",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-peak-element/"
            }
          ],
          "learningTip": [
            "A peak is greater than neighbors. Key insight: If mid < mid+1, there MUST be a peak on the right (values go up). If mid >= mid+1, there MUST be a peak on left or at mid (values go down or peak)."
          ],
          "mustNotMiss": [
            "You're guaranteed to find A peak (any peak, not necessarily global max). Binary search works because you're always moving toward higher ground. Compare nums[mid] with nums[mid+1]: If nums[mid] < nums[mid+1], move right (left = mid + 1). Else move left (right = mid). Return left when done. Edge handling: Problem guarantees nums[-1] = nums[n] = -∞, so edges can be peaks. Time O(log n)."
          ]
        },
        {
          "id": "find_minimum_rotated_sorted_array",
          "name": "Find Minimum in Rotated Sorted Array",
          "estimatedHours": 3,
          "description": "Find the smallest element in a rotated sorted array",
          "practiceQuestions": [
            {
              "name": "Find Minimum in Rotated Sorted Array",
              "slug": "find-minimum-in-rotated-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
            }
          ],
          "learningTip": [
            "The minimum is the rotation pivot - where the sequence 'breaks'. It's the only element smaller than its predecessor."
          ],
          "mustNotMiss": [
            "Compare mid with RIGHT endpoint (not left). If nums[mid] > nums[right], minimum is in right half (left = mid + 1). If nums[mid] <= nums[right], minimum is in left half or at mid (right = mid). Why compare with right? Comparing with left fails for non-rotated arrays. This subtle choice matters. With duplicates: If nums[mid] == nums[right], you can't decide - shrink with right--. Worst case O(n)."
          ]
        },
        {
          "id": "find_first_last_position_sorted_array",
          "name": "Find First & Last Position in Sorted Array",
          "estimatedHours": 2.5,
          "description": "Find the first and last index of a target in a sorted array",
          "practiceQuestions": [
            {
              "name": "Find First and Last Position of Element in Sorted Array",
              "slug": "find-first-and-last-position-of-element-in-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
            }
          ],
          "learningTip": [
            "Run binary search TWICE: once to find left boundary, once for right boundary. This is faster than finding one and expanding."
          ],
          "mustNotMiss": [
            "For left boundary: When nums[mid] >= target, include mid in search (right = mid). When nums[mid] < target, exclude (left = mid +",
            "For right boundary: When nums[mid] <= target, include (left = mid +",
            "When nums[mid] > target, exclude (right = mid). Alternatively, right boundary = lower_bound(target+",
            "-",
            "If left boundary doesn't exist or nums[left] != target, return [-1, -1]. Clean code: Write searchLeft() and searchRight() as separate helper functions."
          ]
        },
        {
          "id": "find_first_last_position_approach_2",
          "name": "Find First & Last Position in Sorted Array - Approach 2",
          "estimatedHours": 1,
          "description": "Optimized approach for finding first and last index of target",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "find_peak_mountain_array",
          "name": "Find Peak in a Mountain Array",
          "estimatedHours": 2.5,
          "description": "Find the peak element in a mountain-shaped array",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "single_element_sorted_array",
          "name": "Single Element in a Sorted Array",
          "estimatedHours": 3,
          "description": "Find the single non-duplicate element in a sorted array",
          "practiceQuestions": [
            {
              "name": "Single Element in a Sorted Array",
              "slug": "single-element-in-a-sorted-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
            }
          ],
          "learningTip": [
            "In a sorted array of pairs, the single element breaks the pairing pattern. Before it, pairs are at (even, odd) indices. After it, pairs are at (odd, even) indices."
          ],
          "mustNotMiss": [
            "Use binary search on pairs. Check if mid is at even index. If nums[mid] == nums[mid+1] (or mid-1 for odd), the single element is on the right. Else it's on the left or at mid. Alternative: XOR adjacent pairs until you find the break. Key insight: You're searching for where the (even, odd) pattern breaks. Time O(log n). This is tricky - draw out the index positions for small examples."
          ]
        },
        {
          "id": "find_k_closest_elements",
          "name": "Find k Closest Elements",
          "estimatedHours": 3,
          "description": "Find the k elements closest to a target in a sorted array",
          "practiceQuestions": [
            {
              "name": "Find K Closest Elements",
              "slug": "find-k-closest-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-k-closest-elements/"
            }
          ],
          "learningTip": [
            "Binary search for the LEFT edge of the k-element window, then return that window. Don't binary search for x itself."
          ],
          "mustNotMiss": [
            "Binary search range is [0, n-k] (left edge of window). For each mid, compare distances: |arr[mid] - x| vs |arr[mid + k] - x|. If left element is farther, move right (left = mid + 1). Else, move left (right = mid). Why does this work? We're finding the optimal window start. Alternative approach: Binary search to find position of x, then use two pointers to expand outward k times. Both are O(log n + k)."
          ]
        }
      ]
    },
    {
      "id": "two_pointers_sliding_window",
      "name": "Two Pointers & Sliding Window",
      "tier": 3,
      "estimatedHours": 37.5,
      "topics": [
        {
          "id": "two_sum",
          "name": "Two Sum",
          "estimatedHours": 2.5,
          "description": "Find two numbers that add up to a target using hashing",
          "practiceQuestions": [
            {
              "name": "Two Sum",
              "slug": "two-sum",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/two-sum/"
            },
            {
              "name": "4Sum",
              "slug": "4sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/4sum/"
            }
          ],
          "learningTip": [
            "THE most famous LeetCode problem",
            "HashMap approach is O(n)",
            "Check if complement exists in map",
            "One-pass solution"
          ],
          "mustNotMiss": [
            "const map = new Map()",
            "For each num: if map.has(target - num), return indices",
            "Else: map.set(num, index)",
            "Check BEFORE adding to handle same-index case"
          ]
        },
        {
          "id": "two_sum_ii_sorted",
          "name": "Two Sum II - Input Array Is Sorted",
          "estimatedHours": 2.5,
          "description": "Solve Two Sum with a sorted array using two pointers",
          "practiceQuestions": [
            {
              "name": "Two Sum II - Input Array Is Sorted",
              "slug": "two-sum-ii-input-array-is-sorted",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
            }
          ],
          "learningTip": [
            "Sorted array enables two-pointer approach",
            "Sum too small: move left pointer right",
            "Sum too large: move right pointer left",
            "O(n) time, O(1) space - better than hashmap for sorted"
          ],
          "mustNotMiss": [
            "let l = 0, r = nums.length - 1",
            "while(l < r) { const sum = nums[l] + nums[r]; if(sum === target) return [l+1, r+1]; sum < target ? l++ : r--; }",
            "Note: problem uses 1-indexed output",
            "Foundation for 3Sum, 4Sum, etc."
          ]
        },
        {
          "id": "is_subsequence",
          "name": "Is Subsequence",
          "estimatedHours": 1,
          "description": "Check if one string is a subsequence of another",
          "practiceQuestions": [
            {
              "name": "Is Subsequence",
              "slug": "is-subsequence",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/is-subsequence/"
            }
          ],
          "learningTip": [
            "Two pointers: one for s, one for t. Move t pointer always, move s pointer only when characters match."
          ],
          "mustNotMiss": [
            "Algorithm: i = 0 (for s), j = 0 (for t). While i < len(s) and j < len(t): if s[i] == t[j], i++. Always j++. Return i == len(s). If we matched all characters of s, it's a subsequence. O(n) time, O(1) space. Follow-up: 'What if there are many s strings to check against t?' Answer: Pre-process t into char->positions map for binary search. This is a common follow-up."
          ]
        },
        {
          "id": "find_index_first_occurrence_string",
          "name": "Find Index of First Occurrence in String",
          "estimatedHours": 2.5,
          "description": "Locate the first occurrence of a substring in a string",
          "practiceQuestions": [
            {
              "name": "Find the Index of the First Occurrence in a String",
              "slug": "find-the-index-of-the-first-occurrence-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
            }
          ],
          "learningTip": [
            "Implement strstr/indexOf. Naive: Check each starting position. Advanced: KMP or Rabin-Karp for O(n+m)."
          ],
          "mustNotMiss": [
            "Naive algorithm: For each position i in haystack: check if haystack[i:i+len(needle)] == needle. O(n*m) worst case but often faster in practice. KMP (Knuth-Morris-Pratt): Precompute failure function to skip redundant comparisons. O(n+m). Rabin-Karp: Rolling hash for O(n+m) average. For interviews, know naive well. Mention KMP/Rabin-Karp exist as optimizations."
          ]
        },
        {
          "id": "kmp_algorithm",
          "name": "KMP (Knuth-Morris-Pratt) Algorithm",
          "estimatedHours": 4.5,
          "description": "Efficient substring search using the KMP algorithm",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "intersection_two_linked_lists_two_pointers",
          "name": "Intersection of Two Linked Lists - Two Pointers",
          "estimatedHours": 2.5,
          "description": "Find the intersection node of two linked lists using two pointers",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "container_most_water",
          "name": "Container with Most Water",
          "estimatedHours": 2.5,
          "description": "Maximize water between two lines using two pointers",
          "practiceQuestions": [
            {
              "name": "Container With Most Water",
              "slug": "container-with-most-water",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/container-with-most-water/"
            }
          ],
          "learningTip": [
            "Two pointers from both ends",
            "Always move the pointer with SMALLER height",
            "Moving shorter might find taller; moving taller can only hurt",
            "Greedy choice works because width is decreasing"
          ],
          "mustNotMiss": [
            "let l = 0, r = n-1, max = 0",
            "while(l < r) { max = Math.max(max, Math.min(height[l], height[r]) * (r - l)); height[l] < height[r] ? l++ : r--; }",
            "Area = min(left, right) × width",
            "Time O(n), single pass"
          ]
        },
        {
          "id": "three_sum",
          "name": "Three Sum",
          "estimatedHours": 2.5,
          "description": "Find all unique triplets that sum to zero",
          "practiceQuestions": [
            {
              "name": "3Sum",
              "slug": "3sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/3sum/"
            }
          ],
          "learningTip": [
            "Sort first, fix one element, two-sum on rest",
            "O(n²) total - n iterations with O(n) two-sum each",
            "Skipping duplicates is critical",
            "Very common interview question"
          ],
          "mustNotMiss": [
            "nums.sort((a,b) => a-b) - CRITICAL: default sort is lexicographic!",
            "for(let i = 0; i < n-2; i++) { if(i > 0 && nums[i] === nums[i-1]) continue; // skip duplicate",
            "Two pointer on remaining: l = i+1, r = n-1; skip duplicates after finding triplet",
            "Early termination: if(nums[i] > 0) break; // can't sum to 0 with all positives"
          ]
        },
        {
          "id": "trapping_rain_water",
          "name": "Trapping Rain Water",
          "estimatedHours": 3,
          "description": "Calculate how much water can be trapped after rain",
          "practiceQuestions": [
            {
              "name": "Trapping Rain Water",
              "slug": "trapping-rain-water",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/trapping-rain-water/"
            }
          ],
          "learningTip": [
            "Water at each position = min(maxLeft, maxRight) - height[i]",
            "Precompute maxLeft and maxRight arrays, or use two pointers",
            "Two pointer approach is O(1) space",
            "Classic hard problem - understand thoroughly"
          ],
          "mustNotMiss": [
            "Two arrays: leftMax[i] = max height to left, rightMax[i] = max height to right",
            "Water[i] = Math.max(0, Math.min(leftMax[i], rightMax[i]) - height[i])",
            "Two pointer O(1) space: move pointer from side with smaller max",
            "At each position, water trapped depends on the constraining (smaller) side"
          ]
        },
        {
          "id": "longest_substring_without_repeating",
          "name": "Longest Substring Without Repeating Characters",
          "estimatedHours": 4,
          "description": "Find the longest substring with all unique characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            }
          ],
          "learningTip": [
            "Sliding window with character tracking",
            "Expand right, shrink left when duplicate found",
            "Map stores char → last index",
            "Classic variable-size window problem"
          ],
          "mustNotMiss": [
            "const map = new Map(); let left = 0, max = 0;",
            "for(let right = 0; right < s.length; right++) { if(map.has(s[right]) && map.get(s[right]) >= left) left = map.get(s[right]) + 1; map.set(s[right], right); max = Math.max(max, right - left + 1); }",
            "Condition map.get(s[right]) >= left ensures we only consider current window",
            "Time O(n), Space O(min(n, charset))"
          ]
        },
        {
          "id": "longest_repeating_character_replacement",
          "name": "Longest Repeating Character Replacement",
          "estimatedHours": 4,
          "description": "Maximize the length of a repeating character substring",
          "practiceQuestions": [
            {
              "name": "Longest Repeating Character Replacement",
              "slug": "longest-repeating-character-replacement",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-repeating-character-replacement/"
            }
          ],
          "learningTip": [
            "Sliding window. Track max frequency character in window. Window is valid if length - maxFreq <= k (we can replace non-max chars)."
          ],
          "mustNotMiss": [
            "Algorithm: count = {}, left = 0, maxFreq = 0, maxLen =",
            "For right in range(n): count[s[right]]++. maxFreq = max(maxFreq, count[s[right]]). While (right - left +",
            "- maxFreq > k: count[s[left]]--; left++. maxLen = max(maxLen, right - left +",
            "Note: We don't need to decrease maxFreq when shrinking - it's okay to keep a 'high water mark'. Time O(n)."
          ]
        },
        {
          "id": "permutation_in_string",
          "name": "Permutation in String",
          "estimatedHours": 3,
          "description": "Check if one string contains a permutation of another",
          "practiceQuestions": [
            {
              "name": "Permutation in String",
              "slug": "permutation-in-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutation-in-string/"
            }
          ],
          "learningTip": [
            "Sliding window of size len(s",
            "over s",
            "Compare character counts with s",
            "Classic fixed-size sliding window."
          ],
          "mustNotMiss": [
            "Algorithm: Window of size len(s",
            "slides over s",
            "For each window position, check if char counts match s1's counts. Optimization: Don't recompute counts from scratch. When sliding: remove outgoing char (left), add incoming char (right), compare counts. Time O(26 * n) = O(n). The 26 comparison can be optimized to O",
            "by tracking 'matches' count. This is the template for fixed-size window problems."
          ]
        },
        {
          "id": "sliding_window_maximum",
          "name": "Sliding Window Maximum",
          "estimatedHours": 3,
          "description": "Find the max value in every window of size k",
          "practiceQuestions": [
            {
              "name": "Sliding Window Maximum",
              "slug": "sliding-window-maximum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-maximum/"
            }
          ],
          "learningTip": [
            "Hardest sliding window problem",
            "Use monotonic DEQUE (not stack)",
            "Deque stores indices of useful elements only",
            "Front of deque is always the maximum"
          ],
          "mustNotMiss": [
            "const deque = [], result = [];",
            "for(let i = 0; i < n; i++) { while(deque.length && deque[0] <= i - k) deque.shift(); // remove old",
            "while(deque.length && nums[deque.at(-1)] < nums[i]) deque.pop(); // remove smaller",
            "deque.push(i); if(i >= k-1) result.push(nums[deque[0]]);}",
            "Time O(n) - each index enters and exits deque once"
          ]
        }
      ]
    },
    {
      "id": "binary_tree",
      "name": "Binary Tree",
      "tier": 3,
      "estimatedHours": 53.5,
      "topics": [
        {
          "id": "introduction_trees",
          "name": "Introduction to Trees",
          "estimatedHours": 2.5,
          "description": "Understand what trees are and their core properties",
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "binary_tree_traversals_explained",
          "name": "Binary Tree - Traversals Explained",
          "estimatedHours": 2.5,
          "description": "Explore preorder, inorder, and postorder tree traversals",
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "preorder_traversal_recursive",
          "name": "Preorder Traversal - Recursive Approach",
          "estimatedHours": 3,
          "description": "Perform preorder traversal using recursion",
          "practiceQuestions": [
            {
              "name": "Binary Tree Preorder Traversal",
              "slug": "binary-tree-preorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-preorder-traversal/"
            }
          ],
          "learningTip": [
            "Root -> Left -> Right. Process node first, then children. Preorder 'visits' node before descending."
          ],
          "mustNotMiss": [
            "Algorithm: def preorder(node): if not node: return. process(node.val). preorder(node.left). preorder(node.right). Use cases:",
            "Copy a tree (process node, then build children).",
            "Serialize a tree.",
            "Prefix expression of expression tree. Returns nodes in order visible from top when doing DFS."
          ]
        },
        {
          "id": "inorder_postorder_recursive",
          "name": "Inorder & PostOrder - Recursive Approach",
          "estimatedHours": 1,
          "description": "Implement inorder and postorder recursively",
          "practiceQuestions": [
            {
              "name": "Binary Tree Inorder Traversal",
              "slug": "binary-tree-inorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
            },
            {
              "name": "Binary Tree Postorder Traversal",
              "slug": "binary-tree-postorder-traversal",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-tree-postorder-traversal/"
            }
          ],
          "learningTip": [
            "Inorder: Left -> Root -> Right (sorted for BST!). Postorder: Left -> Right -> Root (process children first)."
          ],
          "mustNotMiss": [
            "Inorder: def inorder(node): if not node: return. inorder(left). process(node). inorder(right). For BST, this gives sorted order - fundamental property. Postorder: def postorder(node): if not node: return. postorder(left). postorder(right). process(node). Use: Delete tree (delete children before parent), evaluate expression tree (evaluate operands before operator)."
          ]
        },
        {
          "id": "preorder_traversal_iterative",
          "name": "Preorder Traversal - Iterative Approach",
          "estimatedHours": 2.5,
          "description": "Use a stack to perform preorder traversal iteratively",
          "learningTip": [
            "Use stack. Push right child first, then left (so left is popped first). Process node when popped."
          ],
          "mustNotMiss": [
            "Algorithm: if not root: return []. stack = [root], result = []. While stack: node = stack.pop(). result.append(node.val). if node.right: stack.append(node.right). if node.left: stack.append(node.left). Return result. Push right before left so left is processed first (LIFO). This simulates recursion's call stack."
          ]
        },
        {
          "id": "inorder_traversal_iterative",
          "name": "Inorder Traversal - Iterative Approach",
          "estimatedHours": 2.5,
          "description": "Inorder traversal using a stack instead of recursion",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "postorder_iterative_two_stacks",
          "name": "Postorder - Iterative Approach - 2 Stacks",
          "estimatedHours": 2.5,
          "description": "Use two stacks for iterative postorder traversal",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "postorder_iterative_one_stack",
          "name": "Postorder - Iterative Approach - One Stack",
          "estimatedHours": 3,
          "description": "Efficient postorder traversal using just one stack",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "dfs_bfs_binary_tree",
          "name": "DFS and BFS in Binary Tree",
          "estimatedHours": 2.5,
          "description": "Understand DFS vs BFS in binary trees",
          "learningTip": [
            "Graphs model relationships. The two primary traversals are BFS (Queue, Shortest Path in unweighted) and DFS (Stack/Recursion, Exhaustive Search). Graph problems often boil down to: 'Is it connected?', 'What is the distance?', or 'Is there a cycle?'."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The `visited` set: Graphs contain cycles. If you don't track visited nodes, you will loop infinitely.",
            "Representation: Adjacency List (Map<Node, List<Node>>) is preferred over Adjacency Matrix for sparse graphs (most interview graphs).",
            "Connected Components: A single traversal only finds nodes connected to the start; iterate over all nodes to find disconnected parts."
          ]
        },
        {
          "id": "level_order_traversal_queue",
          "name": "Level Order Traversal - Queue - BFS",
          "estimatedHours": 2.5,
          "description": "Implement level order traversal using a queue",
          "practiceQuestions": [
            {
              "name": "Binary Tree Level Order Traversal",
              "slug": "binary-tree-level-order-traversal",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
            },
            {
              "name": "Average of Levels in Binary Tree",
              "slug": "average-of-levels-in-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/average-of-levels-in-binary-tree/"
            }
          ],
          "learningTip": [
            "BFS using queue",
            "Process level by level for grouped output",
            "Track level boundaries by recording queue size",
            "Foundation for many tree problems"
          ],
          "mustNotMiss": [
            "const result = [], queue = [root]; if(!root) return [];",
            "while(queue.length) { const level = [], size = queue.length; for(let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if(node.left) queue.push(node.left); if(node.right) queue.push(node.right); } result.push(level); }",
            "Size captures nodes at current level before adding children",
            "Time O(n), Space O(n) for queue"
          ]
        },
        {
          "id": "level_order_traversal_recursive",
          "name": "Level Order Traversal - Recursive Approach",
          "estimatedHours": 2.5,
          "description": "Perform level order traversal recursively",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "maximum_depth_binary_tree",
          "name": "Maximum Depth of Binary Tree",
          "estimatedHours": 3,
          "description": "Find the max depth of a binary tree",
          "practiceQuestions": [
            {
              "name": "Maximum Depth of Binary Tree",
              "slug": "maximum-depth-of-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
            }
          ],
          "learningTip": [
            "Classic recursive formula: depth = 1 + max(left, right)",
            "Base case: null node has depth 0",
            "Height 'bubbles up' from leaves to root",
            "This is often the first tree recursion problem"
          ],
          "mustNotMiss": [
            "const maxDepth = root => root ? 1 + Math.max(maxDepth(root.left), maxDepth(root.right)) : 0",
            "Iterative: level-order BFS, count levels",
            "Time O(n), Space O(h) for recursion stack where h is height",
            "Balanced tree: h = log n, skewed tree: h = n"
          ]
        },
        {
          "id": "path_sum",
          "name": "Path Sum",
          "estimatedHours": 2.5,
          "description": "Check if a path adds up to a target sum",
          "practiceQuestions": [
            {
              "name": "Path Sum",
              "slug": "path-sum",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/path-sum/"
            }
          ],
          "learningTip": [
            "Check if any root-to-leaf path sums to target",
            "Subtract current value, check if leaf with remaining = 0",
            "Leaf = node with no children",
            "Classic recursive descent with modified target"
          ],
          "mustNotMiss": [
            "const hasPathSum = (root, sum) => { if(!root) return false; if(!root.left && !root.right) return root.val === sum; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); }",
            "Base: empty tree has no path, leaf checks remaining sum",
            "Recursive: try left or right with reduced sum",
            "Time O(n), Space O(h)"
          ]
        },
        {
          "id": "symmetric_tree_recursive",
          "name": "Symmetric Tree - Recursive Approach",
          "estimatedHours": 1,
          "description": "Check if a binary tree is symmetric using recursion",
          "practiceQuestions": [
            {
              "name": "Symmetric Tree",
              "slug": "symmetric-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/symmetric-tree/"
            }
          ],
          "learningTip": [
            "A tree is symmetric if left subtree mirrors right subtree. Compare left.left with right.right, left.right with right.left."
          ],
          "mustNotMiss": [
            "Algorithm: def isMirror(t1, t",
            ": if not t1 and not t2: return True. If not t1 or not t2: return False. return t",
            "val == t",
            "val and isMirror(t",
            "left, t",
            "right) and isMirror(t",
            "right, t",
            "left). Call: isSymmetric(root) = isMirror(root.left, root.right). The key insight is comparing MIRRORED positions, not same positions."
          ]
        },
        {
          "id": "symmetric_tree_iterative",
          "name": "Symmetric Tree - Iterative Approach",
          "estimatedHours": 1,
          "description": "Check symmetry in a binary tree using BFS",
          "learningTip": [
            "Use queue/stack to compare pairs of nodes that should be mirror images of each other."
          ],
          "mustNotMiss": [
            "Algorithm: queue = [(root.left, root.right)]. While queue: (t1, t",
            "= queue.popleft(). If both null: continue. If one null or vals differ: return False. Queue.append((t",
            "left, t",
            "right)). Queue.append((t",
            "right, t",
            "left)). Return True. Process pairs that should match. This shows you can convert any tree recursion to iteration."
          ]
        },
        {
          "id": "invert_binary_tree",
          "name": "Invert a Binary Tree",
          "estimatedHours": 1,
          "description": "Flip a binary tree by swapping left and right nodes",
          "practiceQuestions": [
            {
              "name": "Invert Binary Tree",
              "slug": "invert-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/invert-binary-tree/"
            }
          ],
          "learningTip": [
            "Swap left and right children for every node",
            "The 'famous' interview question (Google rejection story)",
            "Simple but tests basic tree manipulation",
            "Can do DFS or BFS, swapping at each node"
          ],
          "mustNotMiss": [
            "const invertTree = root => { if(!root) return null; [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]; return root; }",
            "Or: [root.left, root.right] = [root.right, root.left]; invertTree(root.left); invertTree(root.right);",
            "Time O(n), Space O(h)",
            "BFS: swap children level by level using queue"
          ]
        },
        {
          "id": "same_tree",
          "name": "Same Tree",
          "estimatedHours": 1,
          "description": "Check if two binary trees are exactly the same",
          "practiceQuestions": [
            {
              "name": "Same Tree",
              "slug": "same-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/same-tree/"
            }
          ],
          "learningTip": [
            "Compare structure and values recursively",
            "Both null = same, one null = different",
            "Values must match, then recurse on children",
            "Clean recursive solution"
          ],
          "mustNotMiss": [
            "const isSameTree = (p, q) => { if(!p && !q) return true; if(!p || !q || p.val !== q.val) return false; return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); }",
            "Order matters: check nulls first, then values, then children",
            "Time O(min(n,m)), Space O(min(h1,h2))",
            "Iterative possible with two queues for BFS comparison"
          ]
        },
        {
          "id": "balanced_binary_tree",
          "name": "Balanced Binary Tree",
          "estimatedHours": 1,
          "description": "Check if a binary tree is height-balanced",
          "practiceQuestions": [
            {
              "name": "Balanced Binary Tree",
              "slug": "balanced-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/balanced-binary-tree/"
            }
          ],
          "learningTip": [
            "Balanced if left and right heights differ by at most 1, AND both subtrees are balanced. Check both conditions!"
          ],
          "mustNotMiss": [
            "Naive O(n²): For each node, calculate height and check balance. Height calculation itself is O(n). Better O(n): Return -1 upward if unbalanced, else return actual height. def checkHeight(node): if not node: return",
            "left = checkHeight(node.left). If left == -1: return -",
            "right = checkHeight(node.right). if right == -1: return -",
            "if abs(left - right) > 1: return -",
            "return 1 + max(left, right). -1 propagates up instantly."
          ]
        },
        {
          "id": "diameter_binary_tree",
          "name": "Diameter of a Binary Tree",
          "estimatedHours": 2.5,
          "description": "Find the longest path between any two nodes",
          "practiceQuestions": [
            {
              "name": "Diameter of Binary Tree",
              "slug": "diameter-of-binary-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/diameter-of-binary-tree/"
            }
          ],
          "learningTip": [
            "Diameter through a node = leftHeight + rightHeight. Track maxDiameter while computing heights. Diameter doesn't have to pass through root!"
          ],
          "mustNotMiss": [
            "Algorithm: Use a class variable or mutable container for maxDiameter. def height(node): if not node: return 0. left = height(node.left). right = height(node.right). maxDiameter = max(maxDiameter, left + right). // Diameter THROUGH this node. return 1 + max(left, right). The returned value is height, but we UPDATE maxDiameter as side effect."
          ]
        },
        {
          "id": "zigzag_level_order_traversal",
          "name": "Zigzag Level Order Traversal",
          "estimatedHours": 1,
          "description": "Traverse a binary tree in zigzag order",
          "practiceQuestions": [
            {
              "name": "Binary Tree Zigzag Level Order Traversal",
              "slug": "binary-tree-zigzag-level-order-traversal",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "subtree_another_tree",
          "name": "Subtree of another Tree",
          "estimatedHours": 3,
          "description": "Check if one binary tree is a subtree of another",
          "practiceQuestions": [
            {
              "name": "Subtree of Another Tree",
              "slug": "subtree-of-another-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/subtree-of-another-tree/"
            }
          ],
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "lowest_common_ancestor",
          "name": "Lowest Common Ancestor",
          "estimatedHours": 2.5,
          "description": "Find the lowest common ancestor of two nodes",
          "practiceQuestions": [
            {
              "name": "Lowest Common Ancestor of a Binary Tree",
              "slug": "lowest-common-ancestor-of-a-binary-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"
            }
          ],
          "learningTip": [
            "LCA = deepest node that has both p and q as descendants",
            "If p and q in different subtrees, current node is LCA",
            "If both in same subtree, recurse that direction",
            "Handle case where p or q IS the LCA"
          ],
          "mustNotMiss": [
            "const lca = (root, p, q) => { if(!root || root === p || root === q) return root; const left = lca(root.left, p, q), right = lca(root.right, p, q); if(left && right) return root; return left || right; }",
            "If both left and right return non-null, root is LCA (split here)",
            "If one is null, return the non-null one",
            "Time O(n), Space O(h)"
          ]
        },
        {
          "id": "binary_tree_right_side_view",
          "name": "Binary Tree Right Side View",
          "estimatedHours": 1,
          "description": "Print the nodes visible from the right side",
          "practiceQuestions": [
            {
              "name": "Binary Tree Right Side View",
              "slug": "binary-tree-right-side-view",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-right-side-view/"
            }
          ],
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "count_good_nodes_binary_tree",
          "name": "Count Good Nodes in Binary Tree",
          "estimatedHours": 2.5,
          "description": "Count nodes that are greater than all previous nodes on the path",
          "practiceQuestions": [
            {
              "name": "Count Good Nodes in Binary Tree",
              "slug": "count-good-nodes-in-binary-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/"
            }
          ],
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "populating_next_right_pointers",
          "name": "Populating Next Right Pointers in Each Node",
          "estimatedHours": 1,
          "description": "Connect each node to its next right node in the same level",
          "practiceQuestions": [
            {
              "name": "Populating Next Right Pointers in Each Node",
              "slug": "populating-next-right-pointers-in-each-node",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "binary_tree_maximum_path_sum",
          "name": "Binary Tree Maximum Path Sum",
          "estimatedHours": 2.5,
          "description": "Find the path in a tree with the maximum sum",
          "practiceQuestions": [
            {
              "name": "Binary Tree Maximum Path Sum",
              "slug": "binary-tree-maximum-path-sum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
            }
          ],
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        }
      ]
    },
    {
      "id": "binary_search_tree",
      "name": "Binary Search Tree",
      "tier": 3,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "binary_search_tree_introduction",
          "name": "Binary Search Tree - Introduction",
          "estimatedHours": 1,
          "description": "Learn the basics of Binary Search Trees",
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "valid_binary_search_tree",
          "name": "Valid Binary Search Tree",
          "estimatedHours": 2.5,
          "description": "Check if a tree is a valid BST",
          "practiceQuestions": [
            {
              "name": "Validate Binary Search Tree",
              "slug": "validate-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/validate-binary-search-tree/"
            }
          ],
          "learningTip": [
            "For Tree problems, always think recursively first. Ask: 'If I knew the answer for the left child and right child, how would I calculate the answer for the current root?' This 'Leap of Faith' simplifies 90% of tree questions. DFS explores deep, BFS explores wide."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Null Checks: Always handle `root == null` first.",
            "Traversal Types: Know Pre-order, In-order, and Post-order cold.",
            "Height vs Depth: Understand the difference.",
            "Space Complexity: Even recursive solutions use O(h) stack space, which is O(n) in worst-case skewed trees."
          ]
        },
        {
          "id": "search_in_bst",
          "name": "Search in a BST",
          "estimatedHours": 1,
          "description": "Search for a value in a Binary Search Tree",
          "practiceQuestions": [
            {
              "name": "Search in a Binary Search Tree",
              "slug": "search-in-a-binary-search-tree",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/search-in-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "insert_into_bst",
          "name": "Insert into a BST",
          "estimatedHours": 1,
          "description": "Insert a new node in a BST",
          "practiceQuestions": [
            {
              "name": "Insert into a Binary Search Tree",
              "slug": "insert-into-a-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/insert-into-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "kth_smallest_element",
          "name": "Kth Smallest Element",
          "estimatedHours": 1,
          "description": "Find the kth smallest element in BST",
          "practiceQuestions": [
            {
              "name": "Kth Smallest Element in a BST",
              "slug": "kth-smallest-element-in-a-bst",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "lowest_common_ancestor_bst",
          "name": "Lowest Common Ancestor of a BST",
          "estimatedHours": 1,
          "description": "Find the lowest common ancestor in a Binary Search Tree",
          "practiceQuestions": [
            {
              "name": "Lowest Common Ancestor of a Binary Search Tree",
              "slug": "lowest-common-ancestor-of-a-binary-search-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        }
      ]
    },
    {
      "id": "heap_priority_queue",
      "name": "Heap / Priority Queue",
      "tier": 3,
      "estimatedHours": 38,
      "topics": [
        {
          "id": "introduction_heaps",
          "name": "Introduction to Heaps",
          "estimatedHours": 2.5,
          "description": "Understand the fundamentals of Heaps",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "creating_heap",
          "name": "Creating a Heap",
          "estimatedHours": 3,
          "description": "Learn how to build a heap from an array",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "inserting_node_heap",
          "name": "Inserting a node in Heap",
          "estimatedHours": 3,
          "description": "Insert an element into a heap and maintain the heap property",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "extracting_values_heap_heapify_down",
          "name": "Extracting Values in Heap & HeapifyDown",
          "estimatedHours": 3,
          "description": "Remove the root and restore heap order",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "heap_sort_algorithm",
          "name": "Heap Sort Algorithm",
          "estimatedHours": 3,
          "description": "Understand the Heap Sort algorithm step-by-step",
          "practiceQuestions": [
            {
              "name": "Sort an Array",
              "slug": "sort-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-an-array/"
            }
          ],
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "heap_sort_code",
          "name": "Heap Sort Code",
          "estimatedHours": 2.5,
          "description": "Implement Heap Sort in code",
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "heap_sort_dive_deep",
          "name": "Heap Sort - Dive Deep",
          "estimatedHours": 2.5,
          "description": "Explore advanced insights into Heap Sort",
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "priority_queues_introduction",
          "name": "Priority Queues - Introduction",
          "estimatedHours": 3,
          "description": "Learn how priority queues work using heaps",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "priority_queue_code",
          "name": "Priority Queue Code",
          "estimatedHours": 2.5,
          "description": "Implement a priority queue in code",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "kth_largest_element_array",
          "name": "Kth Largest Element in an Array",
          "estimatedHours": 2.5,
          "description": "Find the kth largest element using a heap",
          "practiceQuestions": [
            {
              "name": "Kth Largest Element in an Array",
              "slug": "kth-largest-element-in-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
            }
          ],
          "learningTip": [
            "Min-heap of size k or QuickSelect",
            "Heap: O(n log k), QuickSelect: O(n) average",
            "In JS interviews, sorting is often acceptable",
            "Know both approaches for discussion"
          ],
          "mustNotMiss": [
            "Simple: nums.sort((a,b) => b-a)[k-1] - O(n log n)",
            "Min-heap approach: maintain k elements, top is kth largest",
            "QuickSelect: partition-based, O(n) average, O(n²) worst",
            "For interviews: mention heap approach, implement with sort if time-constrained"
          ]
        },
        {
          "id": "kth_largest_element_stream",
          "name": "Kth Largest Element in a Stream",
          "estimatedHours": 2.5,
          "description": "Maintain the kth largest value as numbers stream in",
          "practiceQuestions": [
            {
              "name": "Kth Largest Element in a Stream",
              "slug": "kth-largest-element-in-a-stream",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
            }
          ],
          "learningTip": [
            "Data structure design. Maintain min-heap of size k. Heap top is always current kth largest."
          ],
          "mustNotMiss": [
            "Init: Add initial elements with regular kth largest logic. Add: If val > heap top or heap size < k, potentially add. If size > k, pop. Return heap top. Each add is O(log k). Good for streaming data where you continuously need kth largest. This is a common system design building block."
          ]
        },
        {
          "id": "last_stone_weight",
          "name": "Last Stone Weight",
          "estimatedHours": 2.5,
          "description": "Simulate a stone smashing game using heaps",
          "practiceQuestions": [
            {
              "name": "Last Stone Weight",
              "slug": "last-stone-weight",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/last-stone-weight/"
            }
          ],
          "learningTip": [
            "Simulation with max-heap",
            "Extract two largest, smash, push difference back",
            "Continue until 0 or 1 stone left",
            "Good heap practice problem"
          ],
          "mustNotMiss": [
            "Without heap: sort, process, re-sort - O(n² log n)",
            "With heap: O(n log n) total",
            "In JS: use reverse sort and pop, or implement max-heap",
            "Simple approach: while(stones.length > 1) { stones.sort((a,b)=>b-a); const diff = stones[0] - stones[1]; stones.splice(0, 2); if(diff) stones.push(diff); }"
          ]
        },
        {
          "id": "top_k_frequent_elements",
          "name": "Top K Frequent Elements",
          "estimatedHours": 2.5,
          "description": "Find the k most frequent elements in an array",
          "practiceQuestions": [
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            }
          ],
          "learningTip": [
            "Count frequencies with Map",
            "Get top k by heap or bucket sort",
            "Bucket sort is O(n) - clever use of frequency as index",
            "Both approaches valid in interviews"
          ],
          "mustNotMiss": [
            "const freq = new Map(); for(const n of nums) freq.set(n, (freq.get(n) || 0) + 1);",
            "Bucket sort: const buckets = Array(nums.length + 1).fill().map(() => []); freq.forEach((f, n) => buckets[f].push(n));",
            "Iterate buckets from end, collect k elements",
            "Time O(n), Space O(n)"
          ]
        },
        {
          "id": "kth_smallest_element_sorted_matrix",
          "name": "Kth Smallest Element in a Sorted Matrix",
          "estimatedHours": 3,
          "description": "Find the kth smallest element in a sorted matrix",
          "practiceQuestions": [
            {
              "name": "Kth Smallest Element in a Sorted Matrix",
              "slug": "kth-smallest-element-in-a-sorted-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/"
            }
          ],
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        }
      ]
    },
    {
      "id": "hashing",
      "name": "Hashing",
      "tier": 3,
      "estimatedHours": 54,
      "topics": [
        {
          "id": "linked_list_cycle_hash_table_hashing",
          "name": "Linked List Cycle - Hash Table",
          "estimatedHours": 2.5,
          "description": "Detect cycles in a Linked List using extra space",
          "practiceQuestions": [
            {
              "name": "Linked List Cycle",
              "slug": "linked-list-cycle",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/linked-list-cycle/"
            }
          ],
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "palindrome_linked_list_hashing",
          "name": "Palindrome Linked List",
          "estimatedHours": 3,
          "description": "Check if a Linked List is a palindrome",
          "practiceQuestions": [
            {
              "name": "Palindrome Linked List",
              "slug": "palindrome-linked-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-linked-list/"
            }
          ],
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "intersection_two_linked_lists_two_pointers_hashing",
          "name": "Intersection of Two Linked Lists - Two Pointers",
          "estimatedHours": 2.5,
          "description": "Find the intersection node of two linked lists using two pointers",
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "remove_duplicates_sorted_list_hashing",
          "name": "Remove Duplicates from Sorted List",
          "estimatedHours": 1,
          "description": "Remove consecutive duplicates from a sorted Linked List",
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted List",
              "slug": "remove-duplicates-from-sorted-list",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
            }
          ],
          "learningTip": [
            "Linked Lists test your ability to manage pointers and manual memory references. The logic is usually simple, but the implementation is prone to infinite loops and null pointer exceptions. Always visualize or draw the pointers."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "The Dummy Head: Create a `new Node",
            "` before head to handle edge cases like deleting the head itself.",
            "The Runner Technique: Use Fast (2x) and Slow (1x) pointers for finding middle or cycles.",
            "Lost References: Never break a link before establishing the new one."
          ]
        },
        {
          "id": "find_words_containing_character_hashing",
          "name": "Find Words Containing Character",
          "estimatedHours": 2.5,
          "description": "Find words from a list that contain a specific character",
          "practiceQuestions": [
            {
              "name": "Find Words Containing Character",
              "slug": "find-words-containing-character",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-words-containing-character/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "jewels_stones_hashing",
          "name": "Jewels and Stones",
          "estimatedHours": 2.5,
          "description": "Count how many stones are also jewels",
          "practiceQuestions": [
            {
              "name": "Jewels and Stones",
              "slug": "jewels-and-stones",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/jewels-and-stones/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "find_most_frequent_vowel_consonant_hashing",
          "name": "Find Most Frequent Vowel and Consonant",
          "estimatedHours": 3,
          "description": "Identify the most frequent vowel and consonant in a string",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "valid_palindrome_extra_space_hashing",
          "name": "Valid Palindrome - Approach 1 - Extra Space",
          "estimatedHours": 2.5,
          "description": "Check palindrome by cleaning and reversing a string",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "valid_anagram_hashing",
          "name": "Valid Anagram",
          "estimatedHours": 3,
          "description": "Check if two strings are anagrams of each other",
          "practiceQuestions": [
            {
              "name": "Valid Anagram",
              "slug": "valid-anagram",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-anagram/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "isomorphic_strings_hashing",
          "name": "Isomorphic Strings",
          "estimatedHours": 3,
          "description": "Check if two strings have a one-to-one character mapping",
          "practiceQuestions": [
            {
              "name": "Isomorphic Strings",
              "slug": "isomorphic-strings",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/isomorphic-strings/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "group_anagrams_sorted_key_hashing",
          "name": "Group Anagrams - Approach 1 - Sorted Key",
          "estimatedHours": 2.5,
          "description": "Group words that are anagrams using sorted string keys",
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "group_anagrams_hashed_key_hashing",
          "name": "Group Anagrams - Approach 2 - Hashed Key",
          "estimatedHours": 2.5,
          "description": "Group anagrams using character frequency hash as key",
          "practiceQuestions": [
            {
              "name": "Group Anagrams",
              "slug": "group-anagrams",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/group-anagrams/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "next_greater_element_hashing",
          "name": "Next Greater Element",
          "estimatedHours": 4,
          "description": "Find the next greater element for each number in an array",
          "practiceQuestions": [
            {
              "name": "Next Greater Element I",
              "slug": "next-greater-element-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/next-greater-element-i/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "two_sum_ii_sorted_hashing",
          "name": "Two Sum II - Input Array Is Sorted",
          "estimatedHours": 2.5,
          "description": "Solve Two Sum with a sorted array using two pointers",
          "practiceQuestions": [
            {
              "name": "Two Sum II - Input Array Is Sorted",
              "slug": "two-sum-ii-input-array-is-sorted",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
            }
          ],
          "learningTip": [
            "Sorting and Searching are fundamental. Sorting is generally O(n log n). Searching is O(log n) if sorted, O(n) if not. In interviews, often the 'Brute Force' is O(n²), and you are expected to optimize it using Sorting or Hashing."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Stability: Does the sort preserve order of equal elements? (Merge Sort does, Quick Sort typically doesn't).",
            "Divide and Conquer: The principle behind Merge and Quick sort.",
            "Custom Comparators: Know how to sort objects/arrays based on specific fields."
          ]
        },
        {
          "id": "find_index_first_occurrence_string_hashing",
          "name": "Find Index of First Occurrence in String",
          "estimatedHours": 2.5,
          "description": "Locate the first occurrence of a substring in a string",
          "practiceQuestions": [
            {
              "name": "Find the Index of the First Occurrence in a String",
              "slug": "find-the-index-of-the-first-occurrence-in-a-string",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "kmp_algorithm_hashing",
          "name": "KMP (Knuth-Morris-Pratt) Algorithm",
          "estimatedHours": 4.5,
          "description": "Efficient substring search using the KMP algorithm",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "permutation_in_string_hashing",
          "name": "Permutation in String",
          "estimatedHours": 3,
          "description": "Check if one string contains a permutation of another",
          "practiceQuestions": [
            {
              "name": "Permutation in String",
              "slug": "permutation-in-string",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutation-in-string/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "longest_substring_without_repeating_hashing",
          "name": "Longest Substring Without Repeating Characters",
          "estimatedHours": 4,
          "description": "Find the longest substring with all unique characters",
          "practiceQuestions": [
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "sliding_window_maximum_hashing",
          "name": "Sliding Window Maximum",
          "estimatedHours": 3,
          "description": "Find the max value in every window of size k",
          "practiceQuestions": [
            {
              "name": "Sliding Window Maximum",
              "slug": "sliding-window-maximum",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-maximum/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        }
      ]
    },
    {
      "id": "backtracking",
      "name": "Backtracking",
      "tier": 4,
      "estimatedHours": 49,
      "topics": [
        {
          "id": "introduction_backtracking",
          "name": "Introduction to Backtracking",
          "estimatedHours": 5.5,
          "description": "Understand the core concept of backtracking",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "subsets_power_set",
          "name": "Subsets - The Power Set",
          "estimatedHours": 3.5,
          "description": "Generate all subsets of a set",
          "practiceQuestions": [
            {
              "name": "Subsets",
              "slug": "subsets",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subsets/"
            }
          ],
          "learningTip": [
            "For each element: include it or don't",
            "2^n total subsets",
            "Fundamental backtracking problem",
            "Iterative approach also works"
          ],
          "mustNotMiss": [
            "const result = []; const backtrack = (start, path) => { result.push([...path]); for(let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }",
            "backtrack(0, []); return result;",
            "Start from index to avoid duplicates (each element considered once)",
            "Time O(2^n × n) for generating and copying subsets"
          ]
        },
        {
          "id": "combinations",
          "name": "Combinations",
          "estimatedHours": 3.5,
          "description": "Find all combinations of numbers",
          "practiceQuestions": [
            {
              "name": "Combinations",
              "slug": "combinations",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combinations/"
            }
          ],
          "learningTip": [
            "Like subsets but stop when size reaches k. Prune: don't explore if remaining elements can't fill needed slots."
          ],
          "mustNotMiss": [
            "Algorithm: def backtrack(start, path): if len(path) == k: result.append(path.copy()), return. for i in range(start, n): path.append(nums[i]). backtrack(i+1, path). path.pop(). Pruning: if n - start < k - len(path), return early (not enough elements left). This optimization significantly speeds up for large n, small k."
          ]
        },
        {
          "id": "permutations",
          "name": "Permutations",
          "estimatedHours": 2.5,
          "description": "Generate all permutations of a list",
          "practiceQuestions": [
            {
              "name": "Permutations",
              "slug": "permutations",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutations/"
            }
          ],
          "learningTip": [
            "Use each element exactly once per permutation",
            "n! total permutations",
            "Track which elements are used",
            "When path length equals n, we have one permutation"
          ],
          "mustNotMiss": [
            "const used = new Array(n).fill(false); const result = [];",
            "const backtrack = (path) => { if(path.length === n) { result.push([...path]); return; } for(let i = 0; i < n; i++) { if(used[i]) continue; used[i] = true; path.push(nums[i]); backtrack(path); path.pop(); used[i] = false; } }",
            "Mark used before recursing, unmark after (backtrack)",
            "Time O(n! × n)"
          ]
        },
        {
          "id": "subset_ii",
          "name": "Subset - II",
          "estimatedHours": 2.5,
          "description": "Subsets with duplicate elements",
          "practiceQuestions": [
            {
              "name": "Subsets II",
              "slug": "subsets-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/subsets-ii/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "combination_sum",
          "name": "Combination Sum",
          "estimatedHours": 3.5,
          "description": "Find all combinations that sum to a target",
          "practiceQuestions": [
            {
              "name": "Combination Sum",
              "slug": "combination-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combination-sum/"
            }
          ],
          "learningTip": [
            "Find combinations that sum to target",
            "Each number can be used multiple times (unlimited)",
            "Similar to subsets but with sum constraint",
            "Pass remaining target through recursion"
          ],
          "mustNotMiss": [
            "const backtrack = (start, path, remain) => { if(remain === 0) { result.push([...path]); return; } if(remain < 0) return; for(let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, path, remain - candidates[i]); path.pop(); } }",
            "backtrack(i, ...) not backtrack(i+1, ...) - allows reusing same element",
            "remain < 0 is pruning - stop if we've exceeded target",
            "Sort candidates and add early exit: if(candidates[i] > remain) break;"
          ]
        },
        {
          "id": "combination_sum_ii",
          "name": "Combination Sum - II",
          "estimatedHours": 2.5,
          "description": "Combination sum with single-use elements",
          "practiceQuestions": [
            {
              "name": "Combination Sum II",
              "slug": "combination-sum-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combination-sum-ii/"
            }
          ],
          "learningTip": [
            "Each number used at most once",
            "Handle duplicates in array",
            "Sort first, skip same values at same level",
            "Combines Subsets II and Combination Sum patterns"
          ],
          "mustNotMiss": [
            "candidates.sort((a,b) => a-b);",
            "backtrack(i+1, ...) not backtrack(i, ...) - each element used once",
            "Skip duplicates: if(i > start && candidates[i] === candidates[i-1]) continue;",
            "Pruning: if(candidates[i] > remain) break; // sorted, so all remaining are larger"
          ]
        },
        {
          "id": "combination_sum_iii",
          "name": "Combination Sum - III",
          "estimatedHours": 2.5,
          "description": "Find k numbers that sum to n",
          "practiceQuestions": [
            {
              "name": "Combination Sum III",
              "slug": "combination-sum-iii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/combination-sum-iii/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "letter_combinations_phone_number",
          "name": "Letter Combinations of a Phone Number",
          "estimatedHours": 2.5,
          "description": "Generate letter combinations from digits",
          "practiceQuestions": [
            {
              "name": "Letter Combinations of a Phone Number",
              "slug": "letter-combinations-of-a-phone-number",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "permutations_ii",
          "name": "Permutations - II",
          "estimatedHours": 3.5,
          "description": "Unique permutations with duplicates",
          "practiceQuestions": [
            {
              "name": "Permutations II",
              "slug": "permutations-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutations-ii/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "palindrome_partitioning",
          "name": "Palindrome Partitioning",
          "estimatedHours": 3.5,
          "description": "Partition a string into palindromes",
          "practiceQuestions": [
            {
              "name": "Palindrome Partitioning",
              "slug": "palindrome-partitioning",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/palindrome-partitioning/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "word_search",
          "name": "Word Search",
          "estimatedHours": 5.5,
          "description": "Search a word in a grid",
          "practiceQuestions": [
            {
              "name": "Word Search",
              "slug": "word-search",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/word-search/"
            }
          ],
          "learningTip": [
            "Search for word in 2D grid",
            "DFS/backtracking from each cell",
            "Mark visited cells to avoid reuse, unmark when backtracking",
            "4-directional exploration"
          ],
          "mustNotMiss": [
            "const search = (r, c, i) => { if(i === word.length) return true; if(r < 0 || c < 0 || r >= rows || c >= cols || board[r][c] !== word[i]) return false; const temp = board[r][c]; board[r][c] = '#'; // mark visited",
            "if(search(r+1,c,i+1) || search(r-1,c,i+1) || search(r,c+1,i+1) || search(r,c-1,i+1)) return true;",
            "board[r][c] = temp; return false; } // restore (backtrack)",
            "Try each cell as starting point"
          ]
        },
        {
          "id": "n_queens",
          "name": "N Queens",
          "estimatedHours": 8,
          "description": "Place queens safely on a chessboard",
          "practiceQuestions": [
            {
              "name": "N-Queens",
              "slug": "n-queens",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/n-queens/"
            }
          ],
          "learningTip": [
            "Place n queens on n×n board, none attacking each other",
            "Place row by row, try each column",
            "Track attacked columns and diagonals",
            "Classic constraint satisfaction problem"
          ],
          "mustNotMiss": [
            "Track: const cols = new Set(), diag1 = new Set(), diag2 = new Set();",
            "Diagonal formula: diag1 stores (r-c), diag2 stores (r+c)",
            "If column or diagonal is blocked, skip that position",
            "Build board string when solution found"
          ]
        }
      ]
    },
    {
      "id": "greedy_algorithm",
      "name": "Greedy Algorithm",
      "tier": 4,
      "estimatedHours": 35.5,
      "topics": [
        {
          "id": "introduction_greedy_algorithm",
          "name": "Introduction to Greedy Algorithm",
          "estimatedHours": 3.5,
          "description": "Learn the basics of the Greedy Algorithm technique with simple examples",
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "two_city_scheduling",
          "name": "Two City Scheduling",
          "estimatedHours": 2.5,
          "description": "Minimize total costs to fly 2N people to two cities by analyzing cost differences.",
          "practiceQuestions": [
            {
              "name": "Two City Scheduling",
              "slug": "two-city-scheduling",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/two-city-scheduling/"
            }
          ],
          "learningTip": [
            "Greedy Strategy: Sort by the difference `costA - costB`.",
            "Logic: Sending a person to City A with the smallest difference (most negative) saves the most compared to sending them to B.",
            "Send the first N people (smallest diffs) to A, the rest to B."
          ],
          "mustNotMiss": [
            "Sort: `people.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]))`.",
            "First half `0 to N-1`: Add `costs[i][0]` (City A).",
            "Second half `N to 2N-1`: Add `costs[i][1]` (City B).",
            "Time Complexity: O(N log N) due to sorting."
          ]
        },
        {
          "id": "assign_cookies",
          "name": "Assign Cookies",
          "estimatedHours": 2,
          "description": "Understand how to maximize content children by assigning cookies efficiently",
          "practiceQuestions": [
            {
              "name": "Assign Cookies",
              "slug": "assign-cookies",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/assign-cookies/"
            }
          ],
          "learningTip": [
            "Sort both arrays. Match smallest cookie with smallest satisfiable child. Classic greedy matching."
          ],
          "mustNotMiss": [
            "Algorithm: Sort children and cookies. i = 0 (child), j = 0 (cookie). While both in bounds: if cookie[j] >= child[i], this cookie satisfies this child. i++, j++. else cookie is too small, try next cookie. j++. Return i (number of satisfied children). Greedy works because using a bigger cookie when smaller works is wasteful."
          ]
        },
        {
          "id": "lemonade_change",
          "name": "Lemonade Change",
          "estimatedHours": 2.5,
          "description": "Learn how to apply greedy techniques to manage change in the Lemonade Stand problem",
          "practiceQuestions": [
            {
              "name": "Lemonade Change",
              "slug": "lemonade-change",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/lemonade-change/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "best_time_buy_sell_stock_ii",
          "name": "Best Time to Buy and Sell Stock - II",
          "estimatedHours": 2,
          "description": "Master stock trading with multiple transactions using greedy techniques",
          "practiceQuestions": [
            {
              "name": "Best Time to Buy and Sell Stock II",
              "slug": "best-time-to-buy-and-sell-stock-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
            }
          ],
          "learningTip": [
            "Focus on the underlying pattern. Most problems fall into buckets: Sliding Window, Two Pointers, DFS/BFS, or DP. Once you identify the pattern, the code follows a template. Don't memorize code; memorize the recognition signals."
          ],
          "mustNotMiss": [
            "DO NOT MISS:",
            "Constraints: Always look at input size (N). If N=100, O(n³) is fine. If N=10^5, you need O(n) or O(n log n).",
            "Edge Cases: Empty inputs, single elements, negative numbers, overflow.",
            "Dry Run: Always manually trace your code with a simple example before saying 'I'm done'."
          ]
        },
        {
          "id": "insert_interval",
          "name": "Insert Interval",
          "estimatedHours": 2.5,
          "description": "Master the three-phase logic for inserting and merging intervals in a sorted list.",
          "practiceQuestions": [
            {
              "name": "Insert Interval",
              "slug": "insert-interval",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/insert-interval/"
            }
          ],
          "learningTip": [
            "Phase 1 (Pre-overlap): Add all intervals that end before the new interval starts.",
            "Phase 2 (Merge): While intervals overlap, merge them by updating start/end of the new interval.",
            "Phase 3 (Post-overlap): Add the remaining intervals that start after the new interval ends."
          ],
          "mustNotMiss": [
            "Invariant: Intervals are sorted by start time.",
            "Merge Condition: `max(curr.start, new.start) <= min(curr.end, new.end)`.",
            "Logic: `newInterval = [min(starts), max(ends)]`.",
            "Edge Case: No overlaps (insert at start/end).",
            "Time: O(N), Space: O(1) auxiliary (excluding result)."
          ]
        },
        {
          "id": "merge_intervals",
          "name": "Merge Intervals",
          "estimatedHours": 2.5,
          "description": "Learn to consolidate overlapping intervals into a minimum number of non-overlapping ranges.",
          "practiceQuestions": [
            {
              "name": "Merge Intervals",
              "slug": "merge-intervals",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/merge-intervals/"
            }
          ],
          "learningTip": [
            "Crucial 1st Step: Sort intervals by start time. This brings potential overlaps next to each other.",
            "Iterate and maintain a `lastMerged` interval.",
            "If `current` overlaps `lastMerged`, extend `lastMerged.end`.",
            "If not, push `lastMerged` to result and start a new merge."
          ],
          "mustNotMiss": [
            "Sort: `intervals.sort((a,b) => a[0] - b[0])`.",
            "Overlap Condition: `current.start <= lastMerged.end`.",
            "Merge Logic: `lastMerged.end = Math.max(lastMerged.end, current.end)`.",
            "Time: O(N log N) dominated by sorting."
          ]
        },
        {
          "id": "partition_labels",
          "name": "Partition Labels",
          "estimatedHours": 2.5,
          "description": "Greedily partition a string so that each letter appears in at most one part.",
          "practiceQuestions": [
            {
              "name": "Partition Labels",
              "slug": "partition-labels",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/partition-labels/"
            }
          ],
          "learningTip": [
            "Two-pass approach: 1. Record last index of each char. 2. Scan and extend partition.",
            "The partition must extend to the rightmost occurrence of ANY character inside it.",
            "When current index reaches the `partitionEnd`, the partition is complete."
          ],
          "mustNotMiss": [
            "Map Last Occurrence: `last[char] = index`.",
            "Scan: `end = max(end, last[s[i]])`.",
            "Cut: If `i == end`, push size `end - start + 1` and reset `start`.",
            "Time: O(N), Space: O(1) (limited to 26 chars)."
          ]
        },
        {
          "id": "non_overlapping_intervals",
          "name": "Non Overlapping Intervals",
          "estimatedHours": 2.5,
          "description": "Find the minimum number of intervals to remove to avoid overlaps (Activity Selection Problem).",
          "practiceQuestions": [
            {
              "name": "Non-overlapping Intervals",
              "slug": "non-overlapping-intervals",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/non-overlapping-intervals/"
            }
          ],
          "learningTip": [
            "Greedy Choice: Always keep the interval that ends earliest.",
            "Why? Ending early leaves more room (time) for subsequent intervals.",
            "Crucial: Sort by END time, not start time."
          ],
          "mustNotMiss": [
            "Sort: `intervals.sort((a,b) => a[1] - b[1])` (by end time).",
            "Iterate: If `curr.start < prev.end` -> Overlap! Remove current (greedy choice).",
            "Else: `prev = curr` (update end time, keep interval).",
            "Return total removals count."
          ]
        },
        {
          "id": "task_scheduler",
          "name": "Task Scheduler",
          "estimatedHours": 3,
          "description": "Schedule tasks with cooling periods using formula or simulation.",
          "practiceQuestions": [
            {
              "name": "Task Scheduler",
              "slug": "task-scheduler",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/task-scheduler/"
            }
          ],
          "learningTip": [
            "Key constraint: Identical tasks must be `n` units apart.",
            "The most frequent task sets the lower bound ('skeleton') of the schedule.",
            "Think of filling a frame with `rows = maxFreq - 1` and `cols = n + 1`."
          ],
          "mustNotMiss": [
            "Formula: `(maxFreq - 1) * (n + 1) + countOfMaxFreqTasks`.",
            "Result: `max(formula, tasks.length)`.",
            "Why max? If we have many non-frequent tasks, we might need more size than the minimum skeleton.",
            "Time: O(N) to count freqs."
          ]
        },
        {
          "id": "gas_station",
          "name": "Gas Station",
          "estimatedHours": 2.5,
          "description": "Determine the starting station to travel around a circular route using greedy accumulation.",
          "practiceQuestions": [
            {
              "name": "Gas Station",
              "slug": "gas-station",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/gas-station/"
            }
          ],
          "learningTip": [
            "Global Check: If `sum(gas) < sum(cost)`, impossible.",
            "Local Check: While traversing, subtract cost from gas. If `tank < 0`, current start is invalid.",
            "Greedy Insight: If you fail at `i`, no station from `start` to `i` can work. Skip to `i+1`."
          ],
          "mustNotMiss": [
            "Track `totalSurplus` and `currentSurplus`.",
            "If `currentSurplus < 0`: `start = i + 1`, `currentSurplus = 0`.",
            "Final Answer: `totalSurplus >= 0 ? start : -1`.",
            "Time: O(N) one pass."
          ]
        },
        {
          "id": "car_pooling",
          "name": "Car Pooling",
          "estimatedHours": 2,
          "description": "Verify if a vehicle with fixed capacity can service all trips (timestamps) efficiently.",
          "practiceQuestions": [
            {
              "name": "Car Pooling",
              "slug": "car-pooling",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/car-pooling/"
            }
          ],
          "learningTip": [
            "Decompose trips into two events: Pickup (+people) and Dropoff (-people).",
            "Process events in sorted order of location.",
            "Maintain `currentLoad`. If `currentLoad > capacity` at any point -> False."
          ],
          "mustNotMiss": [
            "Events: `[start, +num]` and `[end, -num]`.",
            "Sort: By location. Tie-break: Process drop-offs (`end`) before pick-ups (`start`).",
            "Optimization: Use `diff` array (Bucket Sort) since locations are limited (0-1000).",
            "Time: O(N log N) with sort, O(M) with buckets."
          ]
        },
        {
          "id": "candy_two_pass",
          "name": "Candy - Two Pass - O(n) Space",
          "estimatedHours": 2.5,
          "description": "Distribute minimum candies satisfying neighbor constraints using two passes.",
          "practiceQuestions": [
            {
              "name": "Candy",
              "slug": "candy",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/candy/"
            }
          ],
          "learningTip": [
            "Decompose into two simple rules: 1. Higher than left. 2. Higher than right.",
            "Solve independently with two passes, then combine.",
            "Initial state: Give everyone 1 candy."
          ],
          "mustNotMiss": [
            "Left Pass (0 to N-1): `if rate[i] > rate[i-1] candies[i] = candies[i-1] + 1`.",
            "Right Pass (N-2 to 0): `if rate[i] > rate[i+1] candies[i] = max(candies[i], candies[i+1] + 1)`.",
            "Result: Sum of `candies` array.",
            "Time: O(N), Space: O(N)."
          ]
        },
        {
          "id": "candy_one_pass",
          "name": "Candy - One Pass - O(1) Space",
          "estimatedHours": 3,
          "description": "Optimize Candy distribution to O(1) space by analyzing slope transitions (peaks and valleys).",
          "practiceQuestions": [
            {
              "name": "Candy",
              "slug": "candy",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/candy/"
            }
          ],
          "learningTip": [
            "Visualize ratings as a mountain range.",
            "Count length of increasing (up) and decreasing (down) slopes.",
            "The Peak contributes to both slopes; it needs `max(up, down) + 1`.",
            "Sum slope lengths on the fly."
          ],
          "mustNotMiss": [
            "Track: `up`, `down`, `peak`.",
            "If climbing: `up++`, `peak = up`, `candy += up + 1`.",
            "If falling: `down++`, `candy += down`.",
            "Correction: If `down > peak`, `candy++` (extend peak height because down slope is longer).",
            "Time: O(N), Space: O(1)."
          ]
        }
      ]
    },
    {
      "id": "dynamic_programming",
      "name": "Dynamic Programming",
      "tier": 1,
      "estimatedHours": 45.5,
      "topics": [
        {
          "id": "dp_introduction",
          "name": "Introduction to Dynamic Programming",
          "estimatedHours": 2,
          "description": "Master the art of solving complex optimization problems by breaking them down into simpler, overlapping subproblems.",
          "learningTip": [
            "Core Pattern: Identify if the problem asks for a maximum, minimum, or count of ways (Optimization/Counting).",
            "Properties: 1. Optimal Substructure (solution constructed from sub-solutions). 2. Overlapping Subproblems (sub-problems repeated).",
            "Strategy: First write the recursive solution (Brute Force), then add Memoization (Top-Down), then convert to Tabulation (Bottom-Up)."
          ],
          "mustNotMiss": [
            "Framework: 1. Define the 'State' (variables). 2. Formulate Recurrence Relation. 3. Identify Base Cases.",
            "Top-Down: Recursion + Cache. Easy to implement, handles sparse states well.",
            "Bottom-Up: Iteration + Table. explicit ordering, better memory locality, no recursion limit.",
            "Complexity: States x Transitions per state."
          ]
        },
        {
          "id": "fibonacci_dp",
          "name": "Fibonacci Numbers using DP",
          "estimatedHours": 1.5,
          "description": "The 'Hello World' of DP: Learn Memoization vs Tabulation using the Fibonacci sequence.",
          "practiceQuestions": [
            {
              "name": "Fibonacci Number",
              "slug": "fibonacci-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fibonacci-number/"
            }
          ],
          "learningTip": [
            "Compare approaches: Naive Recursion O(2^n) vs DP O(n).",
            "Memoization: Store `fib(n)` in a map/array to avoid re-calculating.",
            "Space Optimization: Notice you only need `F(n-1)` and `F(n-2)` to compute `F(n)`. Reducing space from O(n) to O(1)."
          ],
          "mustNotMiss": [
            "Recurrence: `F(n) = F(n-1) + F(n-2)`.",
            "Base Cases: `F(0)=0`, `F(1)=1`.",
            "Swapping Logic (O(1) space): `curr = prev1 + prev2`, then `prev2 = prev1`, `prev1 = curr`."
          ]
        },
        {
          "id": "top_down_bottom_up",
          "name": "Top Down & Bottom Up - DP approach",
          "estimatedHours": 2,
          "description": "Understand the trade-offs: Recursion depth vs Iterative control.",
          "learningTip": [
            "Top-Down (Memoization): 'Lazy' evaluation. Only computes states required to reach the answer. Good when many states are unreachable.",
            "Bottom-Up (Tabulation): 'Eager' evaluation. Computes all subproblems in order. Easier to analyze space complexity and optimize."
          ],
          "mustNotMiss": [
            "Top-Down Skeleton: `if (memo[key]) return memo[key]; ans = solve(); memo[key] = ans; return ans`.",
            "Bottom-Up Skeleton: `dp = array; for i from base to target: dp[i] = ...`.",
            "Advice: Start with Top-Down in interviews (more intuitive), then convert to Bottom-Up if asked or for space optimization."
          ]
        },
        {
          "id": "climbing_stairs",
          "name": "Climbing Stairs",
          "estimatedHours": 1.5,
          "description": "Count distinct ways to reach the top: The foundation of counting DP.",
          "practiceQuestions": [
            {
              "name": "Climbing Stairs",
              "slug": "climbing-stairs",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/climbing-stairs/"
            }
          ],
          "learningTip": [
            "Problem Type: Counting distinct ways.",
            "Decision tree: From step `i`, I can jump to `i+1` or `i+2`. Conversely, to reach `i`, I must have come from `i-1` or `i-2`.",
            "This implies `ways(i) = ways(i-1) + ways(i-2)`. It's exactly Fibonacci!"
          ],
          "mustNotMiss": [
            "State: `dp[i]` = Ways to reach step `i`.",
            "Transition: `dp[i] = dp[i-1] + dp[i-2]`.",
            "Base Cases: `dp[0]=1` (ground), `dp[1]=1` (first step).",
            "Space Optimization: Use two variables `one` and `two`."
          ]
        },
        {
          "id": "min_cost_climbing_stairs",
          "name": "Minimum Cost Climbing Stairs",
          "estimatedHours": 2,
          "description": "Find the cheapest path to the top: Intro to minimization problems.",
          "practiceQuestions": [
            {
              "name": "Min Cost Climbing Stairs",
              "slug": "min-cost-climbing-stairs",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/min-cost-climbing-stairs/"
            }
          ],
          "learningTip": [
            "Problem Type: Minimization.",
            "At each step `i`, you pay `cost[i]` and can go to `i+1` or `i+2`.",
            "Goal: Reach index `n` (top floor) with minimum total cost."
          ],
          "mustNotMiss": [
            "State: `dp[i]` = Minimum cost to reach step `i`.",
            "Recurrence: `dp[i] = cost[i] + min(dp[i-1], dp[i-2])` (if arriving at `i` then paying).",
            "Alternative view: `dp[i]` = min cost to reach top STARTING from `i`.",
            "Final Answer: `min(dp[n-1], dp[n-2])` because we can step onto the top from either of the last two steps."
          ]
        },
        {
          "id": "house_robber",
          "name": "House Robber",
          "estimatedHours": 2.5,
          "description": "Maximize profit with adjacency constraints (1D DP).",
          "practiceQuestions": [
            {
              "name": "House Robber",
              "slug": "house-robber",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/house-robber/"
            }
          ],
          "learningTip": [
            "Classic 'Take or Skip' decision pattern.",
            "For house `i`: You can Rob it (add `nums[i]`, cannot rob `i-1`) OR Skip it (take max profit of `i-1`).",
            "You cannot rob adjacent houses."
          ],
          "mustNotMiss": [
            "State: `dp[i]` is max money robbable from houses `0` to `i`.",
            "Recurrence: `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`.",
            "Base Cases: `dp[0]=nums[0]`, `dp[1]=max(nums[0], nums[1])`.",
            "Optimization: `rob = max(arr[i] + rob2, rob1)`."
          ]
        },
        {
          "id": "house_robber_ii",
          "name": "House Robber II",
          "estimatedHours": 2.5,
          "description": "Solve optimization on circular arrays by breaking the cycle.",
          "practiceQuestions": [
            {
              "name": "House Robber II",
              "slug": "house-robber-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/house-robber-ii/"
            }
          ],
          "learningTip": [
            "Circular Constraint: First and Last houses are neighbors.",
            "Strategy: Break the circle into two linear problems.",
            "Case 1: Rob houses `0` to `n-2` (Include First, Exclude Last).",
            "Case 2: Rob houses `1` to `n-1` (Exclude First, Include Last)."
          ],
          "mustNotMiss": [
            "Result is `max(HouseRobber1(nums[0...n-2]), HouseRobber1(nums[1...n-1]))`.",
            "Edge Case: If only 1 house, return `nums[0]` immediately.",
            "Reuse the `rob` function helper from House Robber I."
          ]
        },
        {
          "id": "coin_change_top_down",
          "name": "Coin Change - Top Down - Recursive",
          "estimatedHours": 2.5,
          "description": "Find minimum coins using Depth First Search with Memoization.",
          "practiceQuestions": [
            {
              "name": "Coin Change",
              "slug": "coin-change",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change/"
            }
          ],
          "learningTip": [
            "Problem: Find MIN coins to equate to Amount.",
            "Try every coin `c` for current `amount`: `result = 1 + minCoins(amount - c)`.",
            "Memoize based on `amount` to prune the tree."
          ],
          "mustNotMiss": [
            "State: `memo[amount]` stores min coins for that amount.",
            "Recurrence: `f(n) = 1 + min(f(n-c1), f(n-c2), ...)`.",
            "Base Cases: `amount=0 -> 0`, `amount<0 -> Infinity`.",
            "If final answer is Infinity, return -1."
          ]
        },
        {
          "id": "coin_change_bottom_up",
          "name": "Coin Change - Bottom Up - Iterative",
          "estimatedHours": 2.5,
          "description": "Solve the Unbounded Knapsack problem iteratively.",
          "practiceQuestions": [
            {
              "name": "Coin Change",
              "slug": "coin-change",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change/"
            }
          ],
          "learningTip": [
            "Iterative approach: Build the solution from amount `0` up to `target`.",
            "Logic: For every amount `i`, try to subtract each coin `c`. The best way to make `i` is `1 + dp[i-c]`.",
            "Unbounded Knapsack: You can use the same coin multiple times."
          ],
          "mustNotMiss": [
            "Initialize `dp` array of size `amount + 1` with `Infinity`, `dp[0] = 0`.",
            "Loops: `for i from 1 to amount`, inner `for coin of coins`.",
            "Update: `if (i >= coin) dp[i] = min(dp[i], dp[i-coin] + 1)`.",
            "Time: O(Amount * Coins), Space: O(Amount)."
          ]
        },
        {
          "id": "palindromic_substrings",
          "name": "Palindromic Substrings",
          "estimatedHours": 2.5,
          "description": "Count all palindromic substrings (contiguous) in a string.",
          "practiceQuestions": [
            {
              "name": "Palindromic Substrings",
              "slug": "palindromic-substrings",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/palindromic-substrings/"
            }
          ],
          "learningTip": [
            "Expand Around Center Approach: Efficient O(N^2) solution compared to brute force O(N^3).",
            "Centers: A palindrome mirrors around a center. Center can be a character (odd length) or a space (even length).",
            "Total centers = 2N - 1."
          ],
          "mustNotMiss": [
            "Algorithm: Iterate `center` from 0 to `2N-1`.",
            "Helper `expand(l, r)`: `while(l>=0 && r<n && s[l]==s[r]) count++, l--, r++`.",
            "DP Alternative: `dp[i][j]` is palindrome if `s[i]==s[j]` and `dp[i+1][j-1]`.",
            "Time: O(N^2), Space: O(1) (Expand method)."
          ]
        },
        {
          "id": "longest_palindromic_substring",
          "name": "Longest Palindromic Substring",
          "estimatedHours": 2.5,
          "description": "Find the maximum length contiguous palindrome substring.",
          "practiceQuestions": [
            {
              "name": "Longest Palindromic Substring",
              "slug": "longest-palindromic-substring",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-substring/"
            }
          ],
          "learningTip": [
            "Uses the same 'Expand Around Center' logic as counting palindromes.",
            "Instead of 'count', track `maxLen` and `startIdx` of the best palindrome found so far.",
            "Avoid full DP table O(N^2) space unless necessary."
          ],
          "mustNotMiss": [
            "Loop centers. `len1 = expand(i, i)`, `len2 = expand(i, i+1)`.",
            "Update: `len = max(len1, len2)`. If `len > maxLen`: update bounds.",
            "Bounds map: `start = i - (len-1)/2`, `end = i + len/2`.",
            "Manacher's Algo exists (O(n)) but usually overkill for interviews."
          ]
        },
        {
          "id": "decode_ways",
          "name": "Decode Ways",
          "estimatedHours": 2.5,
          "description": "Count valid decodings of a digit string where 'A'=1 ... 'Z'=26.",
          "practiceQuestions": [
            {
              "name": "Decode Ways",
              "slug": "decode-ways",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/decode-ways/"
            }
          ],
          "learningTip": [
            "Constraint: '0' must be paired (e.g., '10', '20') to be valid. '06' is invalid.",
            "Relation: `ways(i)` depends on checking 1 digit back (`s[i-1]`) and 2 digits back (`s[i-2...i-1]`).",
            "Like Climbing Stairs with validity checks."
          ],
          "mustNotMiss": [
            "State: `dp[i]` = ways to decode prefix of length `i`.",
            "Recurrence: `if (1-digit valid) dp[i] += dp[i-1]`. `if (2-digit valid) dp[i] += dp[i-2]`.",
            "Base Case: `dp[0]=1` (empty string), `dp[1]=1 (if s[0]!='0') else 0`.",
            "Edge Case: Leading zero returns 0."
          ]
        },
        {
          "id": "max_subarray_kadane",
          "name": "Maximum Subarray - Kadane's Algorithm",
          "estimatedHours": 2,
          "description": "Find the contiguous subarray with the largest sum (O(N)).",
          "practiceQuestions": [
            {
              "name": "Maximum Subarray",
              "slug": "maximum-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-subarray/"
            }
          ],
          "learningTip": [
            "Intuition: A negative prefix is a burden. If your running sum drops below 0, discard it and start fresh.",
            "This is because any subarray starting with a negative sum would be smaller than one without it.",
            "Greedy/DP hybrid."
          ],
          "mustNotMiss": [
            "Local Max: `curr = max(num, curr + num)` (Start new or Extend).",
            "Global Max: `ans = max(ans, curr)`.",
            "Important: Initialize `ans` with `nums[0]`, not 0 (to handle all-negative arrays).",
            "Time: O(N), Space: O(1)."
          ]
        },
        {
          "id": "max_product_subarray_1",
          "name": "Maximum Product Subarray - Approach 1",
          "estimatedHours": 2.5,
          "description": "Solve Maximum Product Subarray by tracking min and max (to handle negatives).",
          "practiceQuestions": [
            {
              "name": "Maximum Product Subarray",
              "slug": "maximum-product-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-product-subarray/"
            }
          ],
          "learningTip": [
            "Problem: A negative number flips the sign. A large negative `min` times a negative number becomes a large positive `max`.",
            "Solution: Track both `maxProduct` and `minProduct` ending at current index.",
            "At each step: Potential candidates are `n`, `n*prevMax`, `n*prevMin`."
          ],
          "mustNotMiss": [
            "Optimization: `if (n < 0) swap(curMax, curMin)`.",
            "Recurrence: `curMax = max(n, n*curMax)`, `curMin = min(n, n*curMin)`.",
            "Global Max: Update at every step.",
            "Time: O(N)."
          ]
        },
        {
          "id": "max_product_subarray_2",
          "name": "Maximum Product Subarray - Approach 2",
          "estimatedHours": 2,
          "description": "Solve Maximum Product Subarray using Prefix/Suffix products.",
          "practiceQuestions": [
            {
              "name": "Maximum Product Subarray",
              "slug": "maximum-product-subarray",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-product-subarray/"
            }
          ],
          "learningTip": [
            "Observation: The max product subarray must start from index 0 OR end at index N-1 (separated by 0s).",
            "Why? If there are even negatives, the whole array (excluding 0s) is max. If odd negatives, we must exclude one negative (either the first or last).",
            "Implementation: Two passes."
          ],
          "mustNotMiss": [
            "P1 (L->R): Multiply accumulator. Update max. If `acc==0`, reset `acc=1`.",
            "P2 (R->L): Multiply accumulator. Update max. If `acc==0`, reset `acc=1`.",
            "Result: Max found in either pass.",
            "Time: O(N)."
          ]
        },
        {
          "id": "word_break",
          "name": "Word Break",
          "estimatedHours": 2.5,
          "description": "Determine if a string can be segmented into a sequence of dictionary words.",
          "practiceQuestions": [
            {
              "name": "Word Break",
              "slug": "word-break",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/word-break/"
            }
          ],
          "learningTip": [
            "DP State: `dp[i]` = true if `s[0...i-1]` is a valid segmentation.",
            "Transition: `dp[i]` is true if exists `j < i` such that `dp[j]` is true AND `s[j...i]` is in dictionary.",
            "Use a Hash Set for O(1) word lookup."
          ],
          "mustNotMiss": [
            "Outer loop `i` from 1 to N. Inner loop `j` from 0 to i.",
            "Check: `if dp[j] and dict.has(s.substring(j, i)) -> dp[i] = true; break`.",
            "Base Case: `dp[0] = true`.",
            "Complexity: O(N^2 * AvgWordLen) or O(N^3) depending on substring implementation."
          ]
        },
        {
          "id": "longest_increasing_subsequence",
          "name": "Longest Increasing Subsequence",
          "estimatedHours": 3,
          "description": "Find the length of the longest strictly increasing subsequence (O(N log N)).",
          "practiceQuestions": [
            {
              "name": "Longest Increasing Subsequence",
              "slug": "longest-increasing-subsequence",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-increasing-subsequence/"
            }
          ],
          "learningTip": [
            "Standard DP (O(N^2)): `dp[i] = 1 + max(dp[j])` for `j < i` and `nums[j] < nums[i]`.",
            "Optimal Patience Sorting (O(N log N)): Maintain a list of piles (tails).",
            "Greedy Logic: Always extend a subsequence with the smallest possible tail value."
          ],
          "mustNotMiss": [
            "Tails Array: `tails[i]` stores the smallest ending element of an increasing subseq of length `i+1`.",
            "Binary Search: For each num, find first element in `tails` >= num.",
            "If found: Replace it (getting a smaller tail for same length).",
            "If not found: Append num (extending the max length)."
          ]
        },
        {
          "id": "partition_equal_subset_sum",
          "name": "Partition Equal Subset Sum",
          "estimatedHours": 2.5,
          "description": "Check if an array can be partitioned into two subsets with equal sum (0/1 Knapsack).",
          "practiceQuestions": [
            {
              "name": "Partition Equal Subset Sum",
              "slug": "partition-equal-subset-sum",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/partition-equal-subset-sum/"
            }
          ],
          "learningTip": [
            "Reduction: Problem is equivalent to finding a subset with sum `TotalSum / 2`.",
            "Prerequisite: If `TotalSum` is odd, return False immediately.",
            "This is the 0/1 Knapsack problem where item weights equal their values."
          ],
          "mustNotMiss": [
            "State: `dp[target]` = true if `target` sum is achievable.",
            "Recurrence: `dp[s] = dp[s] || dp[s - num]`.",
            "Implementation Warning: When optimizing to 1D array, iterate backwards (`target` down to `num`) to avoid using the same item twice."
          ]
        },
        {
          "id": "coin_change_ii",
          "name": "Coin Change II",
          "estimatedHours": 2.5,
          "description": "Find the number of ways to make an amount using unlimited coins (Combinations).",
          "practiceQuestions": [
            {
              "name": "Coin Change II",
              "slug": "coin-change-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change-ii/"
            }
          ],
          "learningTip": [
            "Difference vs Coin Change 1: Asking for count of ways, not min coins.",
            "Difference vs Climbing Stairs: Order doesn't matter (Combinations). `{1,2}` is same as `{2,1}`.",
            "Crucial: Outer loop must be Coins, Inner loop Amount."
          ],
          "mustNotMiss": [
            "Loops: `for coin in coins: for i in coin..amount`.",
            "Recurrence: `dp[i] += dp[i - coin]`.",
            "Why Coin outer? It ensures we process all combinations of using 'coin 1' before we start adding 'coin 2', forcing a sorted order."
          ]
        },
        {
          "id": "unique_paths",
          "name": "Unique Paths",
          "estimatedHours": 2,
          "description": "Count paths from top-left to bottom-right in a grid (Standard 2D DP).",
          "practiceQuestions": [
            {
              "name": "Unique Paths",
              "slug": "unique-paths",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/unique-paths/"
            }
          ],
          "learningTip": [
            "Movement restricted to Right and Down.",
            "Cell `(i, j)` is reachable only from `(i-1, j)` (Top) or `(i, j-1)` (Left).",
            "Math approach: It's a permutation of `m-1` Down moves and `n-1` Right moves: `(m+n-2) Choose (m-1)`."
          ],
          "mustNotMiss": [
            "Recurrence: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.",
            "Boundary: First row and First column are all `1`.",
            "Optimization: Use a 1D array row. `row[j] += row[j-1]` accumulates paths from left (new value) and top (old value).",
            "Time: O(M*N)."
          ]
        }
      ]
    },
    {
      "id": "graphs",
      "name": "Graphs",
      "tier": 1,
      "estimatedHours": 74,
      "topics": [
        {
          "id": "graphs_introduction",
          "name": "Introduction to Graphs",
          "estimatedHours": 2,
          "description": "Understand the fundamental Graph data structure: Vertices (V) and Edges (E).",
          "learningTip": [
            "Representation: Adjacency List (Map<Node, List>) vs Adjacency Matrix (V*V array).",
            "Choice: Use List for sparse graphs (most problems), Matrix for dense graphs.",
            "Terminology: Path, Cycle, Connected Component, Degree."
          ],
          "mustNotMiss": [
            "Adjacency List: `graph[u] = [v1, v2]`.",
            "Space: List O(V+E), Matrix O(V^2).",
            "Undirected: Edge `(u, v)` implies `(v, u)` (add both ways).",
            "Weighted: `graph[u] = [[v1, w1], ...]`."
          ]
        },
        {
          "id": "bfs_graph",
          "name": "Breadth First Search (BFS)",
          "estimatedHours": 2.5,
          "description": "Traverse graph layer-by-layer (Level Order) using a Queue.",
          "learningTip": [
            "Core Data Structure: Queue (FIFO).",
            "Logic: Explores neighbors before neighbors' neighbors.",
            "Application: Finding Shortest Path in Unweighted Graphs."
          ],
          "mustNotMiss": [
            "Pattern: `Queue.push(start)`; `Visited.add(start)`.",
            "Loop: `while(!q.empty) { curr = q.pop(); for(nei : adj[curr]) if(!visited(nei)) ... }`.",
            "Crucial: Mark visited *when adding to queue*, not when popping, to avoid duplicates.",
            "Time: O(V+E)."
          ]
        },
        {
          "id": "dfs_graph",
          "name": "Depth First Search (DFS)",
          "estimatedHours": 2.5,
          "description": "Traverse graph deep-path first using Recursion (System Stack) or an explicit Stack.",
          "learningTip": [
            "Core Data Structure: Stack (LIFO).",
            "Logic: Go deep to the leaf, then backtrack.",
            "Applications: Cycle Detection, Topological Sort, Path Finding, Maze solving."
          ],
          "mustNotMiss": [
            "Recursive Skeleton: `dfs(node, visited)`.",
            "Check `if visited[node] return`.",
            "Process node.",
            "Recurse: `for(nei : adj[node]) dfs(nei)`.",
            "Time: O(V+E)."
          ]
        },
        {
          "id": "find_path_exists_bfs",
          "name": "Find if Path Exists - BFS",
          "estimatedHours": 2,
          "description": "Check connectivity between `source` and `destination` nodes.",
          "practiceQuestions": [
            {
              "name": "Find if Path Exists in Graph",
              "slug": "find-if-path-exists-in-graph",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-if-path-exists-in-graph/"
            }
          ],
          "learningTip": [
            "Can use either BFS or DFS.",
            "BFS is preferred if you want to find the shortest path (implicitly).",
            "Optimization: Bidirectional BFS (meet in the middle) not usually required but good to know."
          ],
          "mustNotMiss": [
            "Return `true` immediately if `current_node === destination`.",
            "Use a `Set` for visited nodes to handle cycles.",
            "If Queue/Stack empties without reaching target -> return `false`."
          ]
        },
        {
          "id": "dfs_recursive",
          "name": "DFS Recursive",
          "estimatedHours": 2,
          "description": "Implement Depth First Search utilizing the system logic (Stack Frame).",
          "learningTip": [
            "Cleaner code than iterative usually.",
            "Remember: Visited set must be passed by reference (or global/closure scope)."
          ],
          "mustNotMiss": [
            "Code: `function dfs(u) { visited.add(u); for(v of graph[u]) if(!visited.has(v)) dfs(v); }`.",
            "Stack Overflow risk on very deep graphs (Recursion limit)."
          ]
        },
        {
          "id": "all_paths_source_target",
          "name": "All Paths from Source to Target",
          "estimatedHours": 2.5,
          "description": "Use Backtracking DFS to enumerate every valid path from Source to Target.",
          "practiceQuestions": [
            {
              "name": "All Paths From Source to Target",
              "slug": "all-paths-from-source-to-target",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/all-paths-from-source-to-target/"
            }
          ],
          "learningTip": [
            "Backtracking Concept: `Push` node to path -> Recurse -> `Pop` node from path.",
            "Since input is a DAG (Directed Acyclic Graph), we don't need a heavy visited set check for cycles, but we still backtrack the path."
          ],
          "mustNotMiss": [
            "Skeleton: `dfs(curr, path)`.",
            "Base Case: `if (curr == target) result.add(copy(path))`.",
            "Recursive Step: `path.push(curr); for(nei:adj) dfs(nei); path.pop()`.",
            "Complexity: O(2^N) in worst case (exponential number of paths)."
          ]
        },
        {
          "id": "reconstruct_itinerary",
          "name": "Reconstruct Itinerary",
          "estimatedHours": 3,
          "description": "Find an Eulerian Path (visit every edge exactly once) using Hierholzer's Algorithm.",
          "practiceQuestions": [
            {
              "name": "Reconstruct Itinerary",
              "slug": "reconstruct-itinerary",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/reconstruct-itinerary/"
            }
          ],
          "learningTip": [
            "Requirement: Visit every edge once. Smallest lexical order.",
            "Algorithm: DFS. Visit neighbors (greedy lexical), remove edge, recursion.",
            "Key: Add node to `result` ONLY after visiting all neighbors (Post-order)."
          ],
          "mustNotMiss": [
            "Sort destination lists in reverse (to pop efficiently) or use PriorityQueue.",
            "DFS logic: `while(adj[u].length) dfs(adj[u].pop())`.",
            "Push `u` to result stack after loop.",
            "Final Answer: Reverse of the result stack."
          ]
        },
        {
          "id": "detect_cycle_undirected",
          "name": "Detect Cycle in Undirected Connected Graph",
          "estimatedHours": 2.5,
          "description": "Detect if a cycle exists by finding a back-edge to an already visited non-parent node.",
          "practiceQuestions": [
            {
              "name": "Redundant Connection",
              "slug": "redundant-connection",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/redundant-connection/"
            }
          ],
          "learningTip": [
            "DFS State: `(node, parent)`.",
            "If `neighbor` is already visited:",
            "  Case A: `neighbor == parent` -> Trivial (just came from there). Ignore.",
            "  Case B: `neighbor != parent` -> Cycle detected! (Back edge)."
          ],
          "mustNotMiss": [
            "DFS: `if(visited[v] && v != p) return true`.",
            "Union-Find: Iterate edges. `if find(u) == find(v)` cycle found. Else `union(u, v)`.",
            "Union-Find is often faster to implement for 'Redundant Connection' style problems."
          ]
        },
        {
          "id": "topological_sort_dfs",
          "name": "Topological Sort - DFS",
          "estimatedHours": 3,
          "description": "Linear ordering of vertices where `u` comes before `v` for every edge `u->v`.",
          "practiceQuestions": [
            {
              "name": "Course Schedule II",
              "slug": "course-schedule-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule-ii/"
            }
          ],
          "learningTip": [
            "Condition: Graph must be a DAG (Directed Acyclic Graph).",
            "Concept: A node is 'done' only after all its dependencies (children) are 'done'.",
            "DFS Order: The Topological Order is the REVERSE of the Post-Order Traversal."
          ],
          "mustNotMiss": [
            "Detect Cycle: Use 3 states (Unvisited, Visiting, Visited). If `Visiting` encountered -> Cycle.",
            "Stack: Push node to stack *after* recursing on neighbors.",
            "Result: Pop from stack (or reverse array)."
          ]
        },
        {
          "id": "kahns_algorithm_bfs",
          "name": "Kahn's Algorithm - Topological Sort - BFS",
          "estimatedHours": 3,
          "description": "Implement Topological Sort using BFS and Indegrees (Dependencies).",
          "practiceQuestions": [
            {
              "name": "Course Schedule",
              "slug": "course-schedule",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule/"
            }
          ],
          "learningTip": [
            "Intuitive: Tasks with 0 dependencies can be done immediately.",
            "Process: Doing a task reduces the dependency count (indegree) of its neighbors.",
            "Neighbors whose indegree becomes 0 are added to the queue."
          ],
          "mustNotMiss": [
            "1. Calculate Indegrees: `Map<Node, Int>`.",
            "2. Queue: Init with all nodes where `indegree == 0`.",
            "3. Process: `count++`, `indegree[nei]--`. If 0, push `nei`.",
            "4. Cycle: If `count < totalNodes`, cycle exists."
          ]
        },
        {
          "id": "shortest_path_overview",
          "name": "Shortest Path Algorithms in Graphs",
          "estimatedHours": 2,
          "description": "Survey the landscape of Shortest Path algorithms.",
          "learningTip": [
            "Unweighted: BFS (O(V+E)).",
            "Weighted (Positive): Dijkstra (O(E log V)).",
            "Weighted (Negative edges): Bellman-Ford (O(VE)).",
            "All-Pairs: Floyd-Warshall (O(V^3))."
          ],
          "mustNotMiss": [
            "Interview Check: Are weights negative? Is graph dense/sparse? Need single or all pairs?",
            "Most Common: BFS and Dijkstra.",
            "Rare but check constraints: Bellman-Ford (Detect negative cycle)."
          ]
        },
        {
          "id": "shortest_path_bfs",
          "name": "Shortest Path in Unweighted Graph - BFS",
          "estimatedHours": 2,
          "description": "Find shortest distance in an Unweighted Graph using Level Order Traversal.",
          "practiceQuestions": [
            {
              "name": "Shortest Path in Binary Matrix",
              "slug": "shortest-path-in-binary-matrix",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/shortest-path-in-binary-matrix/"
            }
          ],
          "learningTip": [
            "In unweighted graphs, the first time you reach a node via BFS, it is via the shortest path.",
            "Why? Because BFS expands in concentric circles of distance 1, 2, 3...",
            "Track `dist[v] = dist[u] + 1`."
          ],
          "mustNotMiss": [
            "Init `dist` map with Infinity, set source to 0.",
            "Mark visited upon pushing to queue.",
            "For Grid problems: 8-direction vs 4-direction neighbors."
          ]
        },
        {
          "id": "dijkstra_explanation",
          "name": "Dijkstra's Algorithm - Shortest Path Weighted Graph",
          "estimatedHours": 3,
          "description": "Find shortest paths from a source to all other vertices in a Weighted Graph (Non-Negative).",
          "learningTip": [
            "Greedy Strategy: Always process the closest unvisited node.",
            "Visual: Like water flowing through pipes; it reaches closer nodes first.",
            "Requirement: No negative edge weights (Greedy assumption fails)."
          ],
          "mustNotMiss": [
            "Data Structure: Priority Queue (Min-Heap) is essential for O(E log V).",
            "Logic: `if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pq.push(v); }`.",
            "Distance Array: Initialize with Infinity, source = 0."
          ]
        },
        {
          "id": "dijkstra_code",
          "name": "Dijkstra's Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Implement Dijkstra's Algorithm in code",
          "practiceQuestions": [
            {
              "name": "Network Delay Time",
              "slug": "network-delay-time",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/network-delay-time/"
            }
          ],
          "learningTip": [
            "Use MinPriorityQueue or implement with array (O(V²) simpler version)",
            "JavaScript: can use sorted array or external library",
            "Process each node at most once (skip if dist[node] > popped distance)"
          ],
          "mustNotMiss": [
            "const pq = new MinPriorityQueue(); pq.enqueue([0, source])",
            "while (!pq.isEmpty()): [d, node] = pq.dequeue(); if (d > dist[node]) continue;",
            "for [neighbor, weight] of graph[node]: if dist[node] + weight < dist[neighbor]: update, enqueue"
          ]
        },
        {
          "id": "bellman_ford_explanation",
          "name": "Bellman Ford Algorithm - Shortest Path with Negative Weights",
          "estimatedHours": 3,
          "description": "Shortest Path algorithm capable of handling Negative Weights (Single Source).",
          "learningTip": [
            "Principle: Relaxation. 'Relax' every edge `V-1` times.",
            "Why V-1? A simple path in a graph of V nodes has at most V-1 edges.",
            "Trade-off: Slower than Dijkstra (O(VE)) but more robust."
          ],
          "mustNotMiss": [
            "Negative Cycle Detection: Run 1 more iteration (the V-th time).",
            "If any distance reduces in the V-th step, a Negative Cycle exists.",
            "Algorithm: `for i: 1 to V-1: for (u, v, w) in edges: minimize dist[v]`."
          ]
        },
        {
          "id": "bellman_ford_code",
          "name": "Bellman Ford Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Code the Bellman-Ford Algorithm step by step",
          "practiceQuestions": [
            {
              "name": "Cheapest Flights Within K Stops",
              "slug": "cheapest-flights-within-k-stops",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/"
            }
          ],
          "learningTip": [
            "Loop V-1 times over all edges",
            "For K stops limit: modify to loop K+1 times",
            "Use copy of distances to avoid intermediate updates affecting current round"
          ],
          "mustNotMiss": [
            "for (let i = 0; i < V - 1; i++) { for (const [u, v, w] of edges) { if (dist[u] + w < dist[v]) dist[v] = dist[u] + w; } }",
            "For K stops: copy dist each iteration to prevent using current round's updates"
          ]
        },
        {
          "id": "floyd_warshall_explanation",
          "name": "Floyd Warshall Algorithm - All Pairs Shortest Path",
          "estimatedHours": 3,
          "description": "Compute All-Pairs Shortest Paths (APSP) for dense graphs (O(V^3)).",
          "learningTip": [
            "Dynamic Programming: `dist[i][j]` using optimal path through intermediates `0..k`.",
            "No recursion needed: simple triple nested loop.",
            "Detects negative cycles if `dist[i][i] < 0`."
          ],
          "mustNotMiss": [
            "CRITICAL: The intermediate node `k` must be the OUTERMOST loop.",
            "Order: `for k`, `for i`, `for j`: `d[i][j] = min(d[i][j], d[i][k] + d[k][j])`.",
            "Initialization: Adjacency Matrix. `d[i][i]=0`, `d[i][j]=Infinity` (if no edge)."
          ]
        },
        {
          "id": "floyd_warshall_code",
          "name": "Floyd Warshall - Code",
          "estimatedHours": 2.5,
          "description": "Implement the Floyd-Warshall Algorithm step by step in code",
          "practiceQuestions": [
            {
              "name": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
              "slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/"
            }
          ],
          "learningTip": [
            "Simple triple nested loop",
            "k (intermediate) must be outermost loop",
            "After algorithm: dist[i][j] is shortest path from i to j"
          ],
          "mustNotMiss": [
            "for (let k = 0; k < V; k++) { for (let i = 0; i < V; i++) { for (let j = 0; j < V; j++) { dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]); } } }",
            "Negative cycle exists if any dist[i][i] < 0"
          ]
        },
        {
          "id": "comparing_shortest_path_algorithms",
          "name": "Comparing all Shortest Path Graph Algorithms",
          "estimatedHours": 1.5,
          "description": "Decision Framework: How to choose the right algorithm for the job.",
          "learningTip": [
            "1. Unweighted? -> BFS (Fastest, O(V+E)).",
            "2. Weighted & Positive? -> Dijkstra (Standard, O(E log V)).",
            "3. Negative Weights? -> Bellman-Ford (Necessary).",
            "4. All-Pairs or Very Dense? -> Floyd-Warshall (Simple to code)."
          ],
          "mustNotMiss": [
            "Cheat Sheet:",
            "- BFS: Level Order.",
            "- Dijkstra: Greedy + Heap.",
            "- Bellman: Relax V-1 times.",
            "- Floyd: Triple Loop (k, i, j)."
          ]
        },
        {
          "id": "mst_introduction",
          "name": "Minimum Spanning Tree",
          "estimatedHours": 2,
          "description": "Understand the concept of a Minimum Spanning Tree (MST)",
          "learningTip": [
            "Spanning Tree: connects all vertices with V-1 edges, no cycles",
            "MST: spanning tree with minimum total edge weight",
            "Two main algorithms: Prim's (vertex-based) and Kruskal's (edge-based)",
            "Applications: network design, clustering, approximation algorithms"
          ],
          "mustNotMiss": [
            "MST has exactly V-1 edges for V vertices",
            "All vertices connected, no cycles, minimum weight",
            "For connected graph, MST always exists",
            "Multiple MSTs possible if edges have same weights"
          ]
        },
        {
          "id": "prims_algorithm",
          "name": "Prim's Algorithm",
          "estimatedHours": 2.5,
          "description": "Algorithm to build MST using Vertex-based Greedy Strategy.",
          "learningTip": [
            "Concept: Grow a single tree from a start node.",
            "Greedy Choice: Always add the cheapest edge connecting a 'Visited' node to an 'Unvisited' node.",
            "Similar to Dijkstra (but stores edge weight, not path sum)."
          ],
          "mustNotMiss": [
            "Min-Heap stores: `[weight, node]` (represents edge to `node`).",
            "Maintain `visited` set.",
            "Loop: Pop min `(w, u)`. If `u` visited, skip. Else mark visited, add `w` to cost, push new edges.",
            "Time: O(E log V)."
          ]
        },
        {
          "id": "prims_code",
          "name": "Prim's Algorithm - Code",
          "estimatedHours": 2.5,
          "description": "Implement Prim's Algorithm in code",
          "practiceQuestions": [
            {
              "name": "Min Cost to Connect All Points",
              "slug": "min-cost-to-connect-all-points",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/"
            }
          ],
          "learningTip": [
            "Min-heap stores [weight, node]",
            "Start with arbitrary node, add all its edges",
            "Pop minimum, if node not visited, add to MST, add its edges"
          ],
          "mustNotMiss": [
            "visited = new Set(); totalWeight = 0; pq = [[0, startNode]];",
            "while (visited.size < V): [weight, node] = pq.pop(); if visited: skip; add to visited, totalWeight += weight; add edges to pq",
            "Time: O(E log V) with heap"
          ]
        },
        {
          "id": "disjoint_set_union_find",
          "name": "Disjoint Set - Union Find",
          "estimatedHours": 3,
          "practiceQuestions": [
            {
              "name": "Number of Provinces",
              "slug": "number-of-provinces",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-provinces/"
            }
          ],
          "description": "Data Structure to manage disjoint sets and merge them efficiently.",
          "learningTip": [
            "Two Operations: `Find` (which set implies 'representative') and `Union` (merge two sets).",
            "Key Optimization 1: Path Compression. Make tree flat during Find.",
            "Key Optimization 2: Union by Rank/Size. Attach smaller tree to root of larger tree."
          ],
          "mustNotMiss": [
            "Path Compression: `find(x) { if(parent[x] != x) parent[x] = find(parent[x]); return parent[x]; }`.",
            "Amortized Time: Inverse Ackermann Function/O(alpha(N)) -> Effectively O(1).",
            "Vital for Kruskal's, Cycle Detection, Dynamic Connectivity."
          ]
        },
        {
          "id": "kruskals_algorithm",
          "name": "Kruskal's Algorithm",
          "estimatedHours": 2.5,
          "description": "Algorithm to build MST using Edge-based Greedy Strategy.",
          "learningTip": [
            "Concept: Select edges globally from smallest to largest.",
            "Condition: Add edge only if it connects two previously disconnected components.",
            "Cycle Check: Use Union-Find."
          ],
          "mustNotMiss": [
            "1. Sort all edges by weight (Ascending).",
            "2. Iterate: `for(u, v, w) in sortedEdges`.",
            "3. Check: `if(find(u) != find(v)) { union(u,v); total += w; }`.",
            "Time: O(E log E) due to sort."
          ]
        },
        {
          "id": "kruskal_union_find_code",
          "name": "Kruskal + Union Find - Code",
          "estimatedHours": 2.5,
          "description": "Implement Kruskal's Algorithm using Union-Find",
          "learningTip": [
            "Sort edges, iterate through, use union-find for cycle detection"
          ],
          "mustNotMiss": [
            "edges.sort((a, b) => a[2] - b[2]); // sort by weight",
            "for (const [u, v, w] of edges) { if (find(u) !== find(v)) { mst.push([u, v, w]); union(u, v); } }",
            "Stop when mst.length === V - 1"
          ]
        },
        {
          "id": "prims_vs_kruskal",
          "name": "Comparison - Prim's vs Kruskal Algorithm",
          "estimatedHours": 1.5,
          "description": "Comparison of two MST giants: Vertex-growth vs Edge-selection.",
          "learningTip": [
            "Prim's: Better for Dense Graphs (E ~ V^2). Works locally from a node.",
            "Kruskal's: Better for Sparse Graphs (E ~ V) or pre-sorted edges. Simple logic with DSU.",
            "Cut Property: Prim's uses this (Lightest crossing edge is in MST)."
          ],
          "mustNotMiss": [
            "Prim's with Array: O(V^2). Prim's with Heap: O(E log V).",
            "Kruskal's: O(E log E) (Edge sorting dominates).",
            "Interview Rule of Thumb: Kruskal's is easier to code if you know DSU."
          ]
        },
        {
          "id": "network_connected_operations",
          "name": "Number of Operations to Make Network Connected",
          "estimatedHours": 2.5,
          "description": "Find minimum operations (edge moves) to connect a network.",
          "practiceQuestions": [
            {
              "name": "Number of Operations to Make Network Connected",
              "slug": "number-of-operations-to-make-network-connected",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-operations-to-make-network-connected/"
            }
          ],
          "learningTip": [
            "To connect `N` nodes, you need at least `N-1` edges.",
            "Step 1: If `totalEdges < N-1`, impossible (return -1).",
            "Step 2: Find number of Connected Components `k`.",
            "Step 3: You need `k-1` cables to merge `k` components."
          ],
          "mustNotMiss": [
            "Count components using DFS or Union-Find.",
            "If Union-Find: Start with `count = N`. Decr every successful `union`.",
            "Or Iterate nodes: `if !visited dfs(node); components++`.",
            "Result: `components - 1`."
          ]
        },
        {
          "id": "cheapest_flights_k_stops",
          "name": "Cheapest Flight with K Stops",
          "estimatedHours": 3,
          "description": "Shortest Path with a constraint on number of edges (hops) used.",
          "practiceQuestions": [
            {
              "name": "Cheapest Flights Within K Stops",
              "slug": "cheapest-flights-within-k-stops",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/"
            }
          ],
          "learningTip": [
            "Plain Dijkstra fails because a 'cheaper' path might use too many stops.",
            "Method 1: Bellman-Ford run for exactly `K+1` iterations.",
            "Method 2: BFS/Dijkstra storing `(cost, node, stops)` state."
          ],
          "mustNotMiss": [
            "Bellman-Ford variant is easiest: `tempDist` array needed to ensure we only use data from previous iteration.",
            "Loop `K+1` times. Relax all edges.",
            "Copy `tempDist` back to `dist` after each full iteration."
          ]
        },
        {
          "id": "ways_to_arrive_destination",
          "name": "Number of Ways to Arrive at Destination",
          "estimatedHours": 2.5,
          "description": "Count the number of distinct shortest paths using Modified Dijkstra.",
          "practiceQuestions": [
            {
              "name": "Number of Ways to Arrive at Destination",
              "slug": "number-of-ways-to-arrive-at-destination",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/"
            }
          ],
          "learningTip": [
            "Track `ways[u]` = count of shortest paths to `u`.",
            "Relax Logic:",
            "  1. If `newDist < dist[v]`: Found strictly better path. `dist[v]=newDist`, `ways[v]=ways[u]`.",
            "  2. If `newDist == dist[v]`: Found alternative path. `ways[v] = (ways[v] + ways[u]) % MOD`."
          ],
          "mustNotMiss": [
            "Initialize `ways[src] = 1`, `ways[others] = 0`.",
            "Use Priority Queue.",
            "Use Modulo (`1e9 + 7`) at each addition to prevent overflow."
          ]
        },
        {
          "id": "min_cost_connect_points",
          "name": "Min Cost to Connect All Points",
          "estimatedHours": 2.5,
          "description": "Minimum Spanning Tree Problem on a 2D Plane.",
          "practiceQuestions": [
            {
              "name": "Min Cost to Connect All Points",
              "slug": "min-cost-to-connect-all-points",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/"
            }
          ],
          "learningTip": [
            "Points are nodes. 'Manhattan Distance' `|x1-x2| + |y1-y2|` is edge weight.",
            "Dense Graph: Every point connects to every other (Complete Graph). `E = V^2`.",
            "Prim's Algorithm (O(V^2)) is efficient here (avoid building explicit edges)."
          ],
          "mustNotMiss": [
            "Implicit Graph: Don't store adjacency list.",
            "Prim's Loop: Find closest unvisited node `v` to the current tree.",
            "Update distances of neighbors of `v`.",
            "Sum weights."
          ]
        }
      ]
    },
    {
      "id": "tries",
      "name": "Tries",
      "tier": 1,
      "estimatedHours": 8,
      "topics": [
        {
          "id": "tries_introduction",
          "name": "Introduction to Tries",
          "estimatedHours": 2,
          "description": "Concept of Prefix Tree (Trie) optimized for String Operations.",
          "learningTip": [
            "Structure: Root node is empty. Edges are characters.",
            "Power: Searching for a key (or prefix) takes `O(L)` time, where `L` is key length.",
            "Independent of `N` (number of keys in DB). Faster than Hash Table for prefix search."
          ],
          "mustNotMiss": [
            "Node contains: 1. Links to children (Array/Map). 2. boolean `isEnd`.",
            "Space-Time Tradeoff: Fast lookup, but potentially high memory usage.",
            "Applications: Autocomplete, Spell Checker, IP Routing."
          ]
        },
        {
          "id": "trie_structure",
          "name": "Trie and TrieNode Structure",
          "estimatedHours": 2,
          "description": "Design the TrieNode class and the overall Trie structure",
          "practiceQuestions": [
            {
              "name": "Implement Trie (Prefix Tree)",
              "slug": "implement-trie-prefix-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
            }
          ],
          "learningTip": [
            "TrieNode: children (Map or Object), isEnd boolean",
            "Trie class: root = new TrieNode(), insert/search/startsWith methods",
            "Map is flexible (any alphabet), array[26] for lowercase English only",
            "Keep it simple: don't over-engineer for interviews"
          ],
          "mustNotMiss": [
            "class TrieNode { constructor() { this.children = new Map(); this.isEnd = false; } }",
            "class Trie { constructor() { this.root = new TrieNode(); } }",
            "For array approach: children = new Array(26).fill(null), index = char.charCodeAt(0) - 97"
          ]
        },
        {
          "id": "trie_operations",
          "name": "Insert, Search, PrefixFind - Trie Code",
          "estimatedHours": 2.5,
          "description": "Implement the core operations: Insert, Search, and StartsWith",
          "practiceQuestions": [
            {
              "name": "Implement Trie (Prefix Tree)",
              "slug": "implement-trie-prefix-tree",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
            },
            {
              "name": "Design Add and Search Words Data Structure",
              "slug": "design-add-and-search-words-data-structure",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
            }
          ],
          "learningTip": [
            "Insert: traverse/create nodes for each char, mark last as isEnd",
            "Search: traverse nodes, return isEnd of last node",
            "StartsWith: same as search but return true if path exists (ignore isEnd)",
            "All operations: O(m) time where m = word length"
          ],
          "mustNotMiss": [
            "insert(word): node = root; for char of word: if !node.children.has(char): node.children.set(char, new TrieNode()); node = node.children.get(char); node.isEnd = true;",
            "search(word): node = traverse(word); return node !== null && node.isEnd;",
            "startsWith(prefix): return traverse(prefix) !== null;",
            "Helper traverse(str): follows path, returns null if char not found"
          ]
        },
        {
          "id": "trie_complexity",
          "name": "Time & Space Complexity in Tries",
          "estimatedHours": 1.5,
          "description": "Analyze Time and Space efficiency of Trie.",
          "learningTip": [
            "Time: Insert/Search/StartsWith are all `O(L)` (Word Length). Very consistent.",
            "Space: `O(N * L * AlphabetSize)` in worst case (no shared prefixes).",
            "Comparison: Hash Table is `O(L)` average but usually suffers collisions and bad worst-case."
          ],
          "mustNotMiss": [
            "Tries are 'Prefix-Friendly'. Hash Tables are not.",
            "If Alphabet is large (Unicode), use `Map`. If small (a-z), use `Array[26]`.",
            "Memory can be optimized (Compressed Tries / Radix Trees)."
          ]
        }
      ]
    },
    {
      "id": "searching_sorting_advanced",
      "name": "Searching & Sorting - Advanced",
      "tier": 2,
      "estimatedHours": 11.5,
      "topics": [
        {
          "id": "quick_sort",
          "name": "Quick Sort",
          "estimatedHours": 2.5,
          "description": "Master Quick Sort, the industry-standard sorting algorithm.",
          "practiceQuestions": [
            {
              "name": "Sort an Array",
              "slug": "sort-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-an-array/"
            },
            {
              "name": "Kth Largest Element in an Array",
              "slug": "kth-largest-element-in-an-array",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
            }
          ],
          "learningTip": [
            "Why is it faster? Better Cache Locality than Merge Sort. It sorts in-place, accessing contiguous memory.",
            "Divide & Conquer: 1. Partition (place pivot). 2. Recursively sort Left. 3. Recursively sort Right.",
            "Tail Call Optimization hints: ALWAYS recurse on the smaller partition first to limit stack depth to O(log n)."
          ],
          "mustNotMiss": [
            "Lomuto Partition: Easier to implement, but does more swaps.",
            "Hoare Partition: Two pointers from ends, fewer swaps, harder to get right.",
            "Worst Case O(n²): Happens on sorted arrays if pivot is first/last element. FIX: Randomized Pivot.",
            "Quick Select Algorithm: Finds Kth largest in O(n) using the same partition logic."
          ]
        },
        {
          "id": "counting_sort",
          "name": "Counting Sort",
          "estimatedHours": 1.5,
          "description": "Learn Counting Sort for sorting integers with small ranges.",
          "practiceQuestions": [
            {
              "name": "Relative Sort Array",
              "slug": "relative-sort-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/relative-sort-array/"
            }
          ],
          "learningTip": [
            "It's an Integer Sorting algorithm. You CANNOT use it for floating point numbers or strings directly.",
            "Think of it as 'Binning': specific bin for each number value.",
            "Key constraint: Range (K) must not be huge (e.g., K=10^9 is bad, K=1000 is good)."
          ],
          "mustNotMiss": [
            "Time Complexity: O(N + K). If K is O(N), it's Linear Time O(N).",
            "Space Complexity: O(K) for the count array.",
            "Handling Negatives: Shift the range by adding abs(min_val) to indices."
          ]
        },
        {
          "id": "counting_sort_stable_logic",
          "name": "Counting Sort - Stable - Logic",
          "estimatedHours": 1,
          "description": "How to make Counting Sort stable (preserve order).",
          "practiceQuestions": [
            {
              "name": "Rank Transform of an Array",
              "slug": "rank-transform-of-an-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rank-transform-of-an-array/"
            }
          ],
          "learningTip": [
            "Stability is crucial when this is used as a step in Radix Sort.",
            "The magic happens by converting 'Counts' into 'Positions'.",
            "Prefix Sum Array: `count[i] += count[i-1]` tells you exactly where the LAST occurrence of `i` belongs."
          ],
          "mustNotMiss": [
            "Why iterate BACKWARDS? To place the 'last' appearing duplicate in the 'last' available spot for that value.",
            "Iterating forwards reverses the order of duplicates, breaking stability.",
            "Requires an extra Output Array (not fully in-place)."
          ]
        },
        {
          "id": "counting_sort_stable_code",
          "name": "Counting Sort - Stable - Code",
          "estimatedHours": 1.5,
          "description": "Implement the Stable Counting Sort algorithm.",
          "practiceQuestions": [
            {
              "name": "Sort Colors",
              "slug": "sort-colors",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-colors/"
            },
            {
              "name": "Height Checker",
              "slug": "height-checker",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/height-checker/"
            }
          ],
          "learningTip": [
            "Standard Template: 1. Find Max. 2. Fill Freq Array. 3. Prefix Sum. 4. Build Output Backwards.",
            "Sort Colors (0, 1, 2) is a specialized version called Dutch National Flag, but Counting Sort works too!",
            "Offset Indexing: Don't forget `output[count[val]-1] = val; count[val]--;`"
          ],
          "mustNotMiss": [
            "Handling 0-based index: Prefix sums usually give 1-based ranks, so subtract 1.",
            "Copy back: Don't forget to copy the Output array back to the Original array at the end."
          ]
        },
        {
          "id": "radix_sort",
          "name": "Radix Sort",
          "estimatedHours": 2.5,
          "description": "Sorting large numbers or strings digit-by-digit.",
          "practiceQuestions": [
            {
              "name": "Maximum Gap",
              "slug": "maximum-gap",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/maximum-gap/"
            },
            {
              "name": "Minimize Deviation in Array",
              "slug": "minimize-deviation-in-array",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimize-deviation-in-array/"
            }
          ],
          "learningTip": [
            "LSD (Least Significant Digit): Process Unit column -> Tens -> Hundreds...",
            "Why LSD? If you sort by units, then by tens STABLY, the order inside 'tens' buckets respects the 'units' order.",
            "It defeats the O(N log N) barrier because it doesn't compare elements directly."
          ],
          "mustNotMiss": [
            "Complexity: O(d * (N+b)) where d=digits, b=base (usually 10).",
            "If d is large (e.g. very long strings), it can be slower than QuickSort.",
            "Bitwise Radix Sort: Using base 2 or 16 is faster for computers (shifting instead of modulo)."
          ]
        },
        {
          "id": "bucket_sort",
          "name": "Bucket Sort",
          "estimatedHours": 1.5,
          "description": "Efficient sorting for uniformly distributed data.",
          "practiceQuestions": [
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            },
            {
              "name": "Sort Characters By Frequency",
              "slug": "sort-characters-by-frequency",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sort-characters-by-frequency/"
            }
          ],
          "learningTip": [
            "Scatter: Distribute N elements into M buckets based on value range.",
            "Sort: Sort each bucket individually (often using Insertion Sort).",
            "Gather: Concatenate sorted buckets.",
            "Crucial assumption: Data is Uniformly Distributed. If all go to 1 bucket -> O(N²)."
          ],
          "mustNotMiss": [
            "Bucket Index = floor(value * number_of_buckets).",
            "For Top K Elements: Use 'Frequency' as the bucket index. Bucket[5] = list of elements appearing 5 times.",
            "This 'Bucket Sort by Frequency' is O(N) and very common in interviews."
          ]
        },
        {
          "id": "interview_cheatsheet_sorting",
          "name": "Interview Cheatsheet",
          "estimatedHours": 1,
          "description": "Comparison and cheat codes for sorting in interviews.",
          "learningTip": [
            "Mention 'Stability' when sorting Objects (e.g. sorting Users by Age, then Name). Unstable sort ruins the Name order.",
            "Language Internals: Python/Java use TimSort (Merge + Insertion). C++ std::sort is Introsort (Quick + Heap + Insertion).",
            "Small Arrays (< 64 elements): Insertion Sort is faster than Quick Sort (less overhead)."
          ],
          "mustNotMiss": [
            "Most Robust: Merge Sort (Stable, guaranteed O(N log N)).",
            "Most Efficient: Quick Sort (Fastest in practice, cache friendly).",
            "Specific Constraints: Counting/Radix (Integers), Bucket (Uniform floats).",
            "Memory Constrained: Heap Sort (O(1) space, but unstable and slower than Quick)."
          ]
        }
      ]
    }
  ],
  "totalEstimatedHours": 527
}
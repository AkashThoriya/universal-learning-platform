{
  "id": "systems_dsa_c_foundation",
  "name": "Systems DSA (The C Foundation)",
  "expectedDuration": "7 Months (28 Weeks @ 21 Hours/Week)",
  "description": "Intensive Systems DSA bootcamp focused on C language for semiconductor/embedded systems interviews at Nvidia, Qualcomm, NXP, and Google Silicon. Covers pointers, memory, bit manipulation, data structures with hardware context including registers, UART, SPI, and RTOS concepts. Theme: 'Memory is a Flat Line' - understanding that variables are physical addresses in SRAM.",
  "category": "Computer Science",
  "totalEstimatedHours": 702,
  "recommendedHoursPerWeek": 21,
  "stages": [
    {
      "id": "foundation",
      "name": "C Foundation Assessment",
      "totalMarks": 100,
      "duration": 180,
      "sections": [
        {
          "id": "pointers_memory",
          "name": "Pointers & Memory Management",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "arrays_matrices",
          "name": "Arrays & 2D Matrices",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "bit_manipulation",
          "name": "Bit Manipulation & Registers",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "math_number_theory",
          "name": "Math & Number Theory",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "intermediate",
      "name": "Intermediate Systems Assessment",
      "totalMarks": 150,
      "duration": 270,
      "sections": [
        {
          "id": "string_parsing",
          "name": "String Parsing & UART Context",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "sliding_windows",
          "name": "Sliding Windows & Buffers",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "linked_lists_stacks",
          "name": "Linked Lists & Stacks",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "advanced",
      "name": "Advanced Systems Assessment",
      "totalMarks": 200,
      "duration": 360,
      "sections": [
        {
          "id": "queues_heaps",
          "name": "Circular Queues & Heaps",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "trees_graphs",
          "name": "Trees & Graphs",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "dynamic_programming",
          "name": "Dynamic Programming",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "hard_problems",
          "name": "Hard Problems & Capstone",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    }
  ],
  "defaultSyllabus": [
    {
      "id": "month_1_pointers_arrays_memory",
      "name": "Pointers, Arrays & Memory",
      "tier": 1,
      "estimatedHours": 64,
      "topics": [
        {
          "id": "week_0_toolchain_standards",
          "name": "Week 0: The Embedded Toolchain & Standards",
          "estimatedHours": 6,
          "description": "Before writing code, understand how it runs. Cross-compilation, Manual Memory Layout, and Safety Standards (MISRA).",
          "learningTip": [
            "**Cross-Compilation:** Host (x86) builds for Target (ARM). You need `arm-none-eabi-gcc`.",
            "**Build System:** `Make` is standard. Understand `TARGET`, `CC`, `CFLAGS`, `LDFLAGS`.",
            "**MISRA C:** Golden standard for safety. Often forbids dynamic memory (`malloc`) and recursion in safety-critical code."
          ],
          "mustNotMiss": [
            "**stdint.h:** Always use `uint32_t`, `int8_t`. Never use `int` or `long` (size varies by arch).",
            "**volatile:** Tells compiler \"Do not optimize this, hardware changes it\".",
            "**static:** Local persistent scope OR File-private scope. Know the difference.",
            "**const:** Read-only. `const int *p` (ptr to const) vs `int * const p` (const ptr)."
          ],
          "interviewQuestions": [
            {
              "question": "What is the difference between `gcc` and `arm-none-eabi-gcc`?",
              "answer": "**Target Architecture.** `gcc` builds for the host (your laptop). `arm-none-eabi-gcc` builds for Bare Metal ARM (EABI = Embedded Application Binary Interface)."
            },
            {
              "question": "What is `startup.s`?",
              "answer": "The Assembly file that runs before `main()`. It initializes the stack pointer (SP), copies .data from Flash to RAM, zeroes .bss, and calls system init."
            },
            {
              "question": "Explain a standard Makefile build flow.",
              "answer": "1. **Pre-process (`-E`):** Expand macros/includes. \n2. **Compile (`-c`):** C -> ASM -> Object (.o). \n3. **Link (`-o`):** Combine .o + Libs -> Executable (.elf/.bin) using Linker Script (.ld)."
            }
          ],
          "resources": [
            "https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html",
            "https://www.misra.org.uk/"
          ],
          "practiceQuestions": [
            {
              "name": "Running Sum of 1d Array",
              "slug": "running-sum-of-1d-array",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/running-sum-of-1d-array/"
            },
            {
              "name": "Richest Customer Wealth",
              "slug": "richest-customer-wealth",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/richest-customer-wealth/"
            }
          ]
        },
        {
          "id": "week_1_physics_of_c",
          "name": "Week 1: The Physics of C (Pointers & Memory)",
          "estimatedHours": 15.5,
          "description": "Master & (Address of) and * (Value at). Understand that arr[i] is syntax sugar for *(arr + i). Semiconductor context: Sensors dump data into linear buffers that cannot be resized. Passing a 1MB image buffer by pointer takes 4 bytes instead of copying. **New:** Memory Mapped I/O (MMIO) and Cache Coherency basics.",
          "learningTip": [
            "**Memory as a Flat Line:** RAM is just a giant array of bytes. `0x2000` is just an index in that array.",
            "**Pointer Arithmetic:** `ptr + 1` increases address by `sizeof(*ptr)` bytes. For `int *p`, `p+1` adds 4 bytes. This is crucial for iterating hardware buffers.",
            "**Data Bus Width:** Why `memcpy` is faster than a loop? It moves data in 32-bit or 64-bit chunks (word-aligned) rather than byte-by-byte.",
            "**Stack vs Heap:** Embedded systems often ban `malloc` (Heap) due to fragmentation. Master `Stack` allocation and `Static` buffers.",
            "**Structure Padding:** logical `struct {char a; int b;}` is 8 bytes, not 5, due to alignment. Hardware often crashes on unaligned access.",
            "**Memory Mapped I/O (MMIO):** Hardware registers are mapped to specific memory addresses. Reading `0x40021000` might read a button state, not RAM. ALWAYS use `volatile`.",
            "**Cache Coherency (DMA):** The CPU has a cache, but DMA writes directly to RAM. You must `invalidate` cache before reading DMA data, or you'll read stale cache values."
          ],
          "mustNotMiss": [
            "**& (Address-Of):** Returns the memory address. `int *p = &x;`",
            "**ptr[i] == *(ptr + i):** The most important equivalence in C.",
            "**Null Pointer Checks:** ALWAYS check `if (!ptr) return;` before dereferencing. Segfaults in firmware halt the device.",
            "**Volatile keyword:** Essential for hardware registers. Tells compiler: 'Do not optimize this read, hardware might change it'.",
            "**Void Pointers:** `void *` is a generic handle. You CANNOT dereference it or do arithmetic on it (standard C) without casting.",
            "**Cache Maintenance:** `Invalidate` (Rx) and `Clean/Flush` (Tx) when using DMA."
          ],
          "interviewQuestions": [
            {
              "question": "What is the size of `void *`?",
              "answer": "**Architecture Dependent.** 4 bytes on 32-bit systems, 8 bytes on 64-bit systems. It holds a memory address."
            },
            {
              "question": "Explain Little Endian vs Big Endian.",
              "answer": "**Byte Order.** Little Endian stores LSB at lowest address (Intel/ARM). Big Endian stores MSB at lowest address (Network protocols). Vital for parsing binary sensor data."
            },
            {
              "question": "Implement `aligned_malloc(size_t size, size_t alignment)`.",
              "answer": "**Memory Management.** Allocates `size` bytes with address multiple of `alignment`. Strategy: Allocate `size + alignment + overhead`, shift pointer, store offset."
            },
            {
              "question": "Why do we need `volatile` for MMIO?",
              "answer": "**Prevent Optimization.** Compiler assumes variables only change by code. Hardware registers change externally (e.g., status bit). Without `volatile`, compiler might cache the value in a register and never read the real hardware address."
            },
            {
              "question": "What is Cache Coherency in the context of DMA?",
              "answer": "**Stale Data.** DMA writes directly to RAM, bypassing CPU cache. If CPU reads the buffer addresses, it might get old data from its cache. You must **Invalidate** the cache range before reading to force a reload from RAM."
            }
          ],
          "resources": [
            "https://godbolt.org/ - Compiler Explorer (See assembly output)",
            "http://c-faq.com/ - The C Programming Language FAQ",
            "https://visualgo.net/en - Visualizing Data Structures"
          ],
          "practiceQuestions": [
            {
              "name": "Concatenation of Array",
              "slug": "concatenation-of-array",
              "number": 1929,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/concatenation-of-array/"
            },
            {
              "name": "Shuffle the Array",
              "slug": "shuffle-the-array",
              "number": 1470,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/shuffle-the-array/"
            },
            {
              "name": "Fizz Buzz",
              "slug": "fizz-buzz",
              "number": 412,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fizz-buzz/"
            },
            {
              "name": "Defanging an IP Address",
              "slug": "defanging-an-ip-address",
              "number": 1108,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/defanging-an-ip-address/"
            },
            {
              "name": "Score of a String",
              "slug": "score-of-a-string",
              "number": 3110,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/score-of-a-string/"
            },
            {
              "name": "Permutation Difference between Two Strings",
              "slug": "permutation-difference-between-two-strings",
              "number": 3146,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/permutation-difference-between-two-strings/"
            },
            {
              "name": "Find the Integer Added to Array",
              "slug": "find-the-integer-added-to-array",
              "number": 3131,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-integer-added-to-array/"
            },
            {
              "name": "Convert the Temperature",
              "slug": "convert-the-temperature",
              "number": 2469,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/convert-the-temperature/"
            },
            {
              "name": "Rotate Array",
              "slug": "rotate-array",
              "number": 189,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rotate-array/"
            }
          ]
        },
        {
          "id": "week_2_prefix_sums",
          "name": "Week 2: Prefix Sums (Time vs. Space)",
          "estimatedHours": 13.5,
          "description": "Pre-calculating running totals for O(1) range queries. Semiconductor context: Telemetry & Battery - calculate total energy consumed between t=100ms and t=500ms without iterating the loop every time.",
          "learningTip": [
            "**Telemetry & Sensors:** 'What was the avg CPU temp between 10:00 and 10:05?'. Prefix Sums answer this in O(1) time.",
            "**Space-Time Tradeoff:** You spend O(N) memory (the prefix array) to get O(1) query speed. In embedded, RAM is scarce, so only do this if queries are frequent.",
            "**Integral Images:** In Image Processing (ISP), 2D prefix sums allow calculating the brightness of any rectangular area in O(1) - crucial for auto-exposure algorithms.",
            "**Rolling Hash:** Prefix sums of character codes are the basis of the Rabin-Karp string matching algorithm (used in packet filtering)."
          ],
          "mustNotMiss": [
            "**Formula:** `prefix[i] = prefix[i-1] + arr[i]` (Handle i=0).",
            "**Range Query:** `sum(L, R) = prefix[R] - prefix[L-1]` (If L=0, result is prefix[R]).",
            "**Overflow:** Cumulative sums grow fast. If `arr[i]` is `int32`, `prefix[i]` might need `int64_t` or `long long`.",
            "**Difference Array:** To ADD `k` to range `[L, R]` efficiently, use `diff[L] += k` and `diff[R+1] -= k`, then take prefix sum."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle updates in a Prefix Sum array?",
              "answer": "**Poorly.** Updating `arr[i]` requires rebuilding `prefix[i...n]` in O(N). If updates are frequent, use a Fenwick Tree (Binary Indexed Tree) for O(log N) updates."
            },
            {
              "question": "Find the max average subarray of length K.",
              "answer": "**Sliding Window.** While Prefix Sums work, Sliding Window is O(1) space if we just need the *current* sum. Prefix Sum is for *random access* queries."
            }
          ],
          "resources": [
            "https://cp-algorithms.com/data_structures/fenwick.html - For when Prefix Sums aren't enough (updates)",
            "https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/ - Integral Images in Computer Vision"
          ],
          "practiceQuestions": [
            {
              "name": "Running Sum of 1d Array",
              "slug": "running-sum-of-1d-array",
              "number": 1480,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/running-sum-of-1d-array/"
            },
            {
              "name": "Find Pivot Index",
              "slug": "find-pivot-index",
              "number": 724,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-pivot-index/"
            },
            {
              "name": "Range Sum Query",
              "slug": "range-sum-query",
              "number": 303,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/range-sum-query/"
            },
            {
              "name": "Product of Array Except Self",
              "slug": "product-of-array-except-self",
              "number": 238,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/product-of-array-except-self/"
            },
            {
              "name": "Subarray Sum Equals K",
              "slug": "subarray-sum-equals-k",
              "number": 560,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/subarray-sum-equals-k/"
            },
            {
              "name": "Find the Highest Altitude",
              "slug": "find-the-highest-altitude",
              "number": 1732,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-highest-altitude/"
            },
            {
              "name": "Contiguous Array",
              "slug": "contiguous-array",
              "number": 525,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/contiguous-array/"
            },
            {
              "name": "Maximum Population Year",
              "slug": "maximum-population-year",
              "number": 1854,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-population-year/"
            },
            {
              "name": "Left and Right Sum Differences",
              "slug": "left-and-right-sum-differences",
              "number": 2574,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/left-and-right-sum-differences/"
            }
          ]
        },
        {
          "id": "week_3_two_pointer",
          "name": "Week 3: The Two-Pointer Technique (Static)",
          "estimatedHours": 15.5,
          "description": "Using left and right indices to scan buffers from both ends in O(n) instead of O(n²). Semiconductor context: Buffer Compaction - remove dead bytes (zeros) without creating new array (In-Place algorithm).",
          "learningTip": [
            "**In-Place Algorithms:** Embedded systems have limited RAM. Two pointers allow modifying data *without* allocating a new array (O(1) space).",
            "**Partitioning:** This logic is the core of QuickSort. Moving elements < P to left and > P to right is a fundamental memory operation.",
            "**Data Validation:** Checking for palindrome packets or symmetric signals often uses two pointers meeting in the middle.",
            "**Sorted Arrays:** If input is sorted, Two Pointers is almost always the answer (vs Binary Search)."
          ],
          "mustNotMiss": [
            "**Read/Write Pointers:** Common pattern: `read_ptr` scans forward, `write_ptr` only moves when we keep an element (e.g., Remove Duplicates).",
            "**Direction:** `left ->  <- right`: specific sum, palindrome. `slow -> fast ->`: cycle detection (Linked List context).",
            "**Code Pattern:** `while (L < R) { if (check) L++; else R--; }`",
            "**Constraint:** Only works on linear data structures (Arrays, Linked Lists) where index access or traversal is efficient."
          ],
          "interviewQuestions": [
            {
              "question": "Merge two sorted arrays without extra space.",
              "answer": "**Gap Method or Shell Sort logic.** Start comparing elements with a gap, reduce gap. Or iterate backwards if one array has empty space at end."
            },
            {
              "question": "Reverse an array in-place.",
              "answer": "**Two Pointers.** `swap(arr[L], arr[R])`. Simple, but tests if you know how to manipulate memory directly."
            }
          ],
          "resources": [
            "https://leetcode.com/articles/two-pointer-technique/ - Official Guide",
            "https://www.geeksforgeeks.org/two-pointers-technique/ - Basics"
          ],
          "practiceQuestions": [
            {
              "name": "Remove Duplicates from Sorted Array",
              "slug": "remove-duplicates-from-sorted-array",
              "number": 26,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
            },
            {
              "name": "Remove Element",
              "slug": "remove-element",
              "number": 27,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-element/"
            },
            {
              "name": "Move Zeroes",
              "slug": "move-zeroes",
              "number": 283,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/move-zeroes/"
            },
            {
              "name": "Two Sum II",
              "slug": "two-sum-ii",
              "number": 167,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/two-sum-ii/"
            },
            {
              "name": "Reverse String",
              "slug": "reverse-string",
              "number": 344,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-string/"
            },
            {
              "name": "Squares of a Sorted Array",
              "slug": "squares-of-a-sorted-array",
              "number": 977,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/squares-of-a-sorted-array/"
            },
            {
              "name": "Valid Palindrome",
              "slug": "valid-palindrome",
              "number": 125,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-palindrome/"
            },
            {
              "name": "Sort Colors",
              "slug": "sort-colors",
              "number": 75,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/sort-colors/"
            },
            {
              "name": "Merge Sorted Array",
              "slug": "merge-sorted-array",
              "number": 88,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-sorted-array/"
            },
            {
              "name": "Container With Most Water",
              "slug": "container-with-most-water",
              "number": 11,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/container-with-most-water/"
            },
            {
              "name": "3Sum",
              "slug": "3sum",
              "number": 15,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/3sum/"
            }
          ]
        },
        {
          "id": "week_4_2d_arrays",
          "name": "Week 4: 2D Arrays (Matrices)",
          "estimatedHours": 13.5,
          "description": "Mapping Row-Major [i][j] coordinates to linear memory addresses. Semiconductor context: Image Sensors & Displays - camera frames are 2D pixel matrices for ROI processing.",
          "learningTip": [
            "**Row-Major Order:** C stores 2D arrays row-by-row. `arr[i][j]` is next to `arr[i][j+1]` in RAM. `arr[i][j]` is NOT next to `arr[i+1][j]`.",
            "**Cache Locality:** Iterating `for(i) for(j)` is 100x faster than `for(j) for(i)` because the CPU pre-fetches the next cache line.",
            "**Flattening:** In embedded, we often malloc a 1D array `int *p = malloc(R*C*4)` and access it as `p[i*C + j]` to ensure contiguous memory.",
            "**DMA (Direct Memory Access):** Peripherals (Camera, SPI) write to linear blocks. Understanding 2D-to-1D mapping is vital for processing these buffers."
          ],
          "mustNotMiss": [
            "**Address Formula:** `&arr[i][j] = Base + (i * COLS + j) * sizeof(Type)`. Memorize this.",
            "**Pointer Decay:** `void func(int arr[][COLS])` - You MUST specify the column dimension so the compiler knows the stride.",
            "**Stack Overflow:** `int matrix[1000][1000]` on stack (inside a function) will crash the firmware (Stack is usually < 8KB). Always use `static` or global or heap for large arrays.",
            "**Rotation:** Rotating an image (matrix) in-place requires careful coordinate mapping `(i, j) -> (j, n-1-i)`."
          ],
          "interviewQuestions": [
            {
              "question": "Why is looping columns-first slower than rows-first in C?",
              "answer": "**Cache Misses.** Row-first accesses `addr, addr+4, addr+8` (Spatial Locality). Column-first accesses `addr, addr+4000, addr+8000`, causing a cache miss on every read."
            },
            {
              "question": "Implement a 2D array using `malloc`.",
              "answer": "**Single Block vs Array of Pointers.** Prefer single block `malloc(R*C*sizeof(int))` for fragmentation. `int**` (array of pointers) causes double dereference overhead and non-contiguous memory."
            }
          ],
          "resources": [
            "https://gallery.analyticsvidhya.com/view/row-major-vs-column-major-order-in-programming-languages-1  - Visualization of Memory Layout",
            "https://stackoverflow.com/questions/992902/when-to-use-malloc-for-2d-array - Best practices for embedded C"
          ],
          "practiceQuestions": [
            {
              "name": "Transpose Matrix",
              "slug": "transpose-matrix",
              "number": 867,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/transpose-matrix/"
            },
            {
              "name": "Reshape the Matrix",
              "slug": "reshape-the-matrix",
              "number": 566,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reshape-the-matrix/"
            },
            {
              "name": "Matrix Diagonal Sum",
              "slug": "matrix-diagonal-sum",
              "number": 1572,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/matrix-diagonal-sum/"
            },
            {
              "name": "Toeplitz Matrix",
              "slug": "toeplitz-matrix",
              "number": 766,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/toeplitz-matrix/"
            },
            {
              "name": "Rotate Image",
              "slug": "rotate-image",
              "number": 48,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-image/"
            },
            {
              "name": "Spiral Matrix",
              "slug": "spiral-matrix",
              "number": 54,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/spiral-matrix/"
            },
            {
              "name": "Spiral Matrix II",
              "slug": "spiral-matrix-ii",
              "number": 59,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/spiral-matrix-ii/"
            },
            {
              "name": "Set Matrix Zeroes",
              "slug": "set-matrix-zeroes",
              "number": 73,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/set-matrix-zeroes/"
            },
            {
              "name": "Search a 2D Matrix",
              "slug": "search-a-2d-matrix",
              "number": 74,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-a-2d-matrix/"
            },
            {
              "name": "Valid Sudoku",
              "slug": "valid-sudoku",
              "number": 36,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/valid-sudoku/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_2_bit_manipulation",
      "name": "Bit Manipulation (The Register Interface)",
      "tier": 1,
      "estimatedHours": 61.5,
      "topics": [
        {
          "id": "week_5_boolean_logic",
          "name": "Week 5: Basic Boolean Logic",
          "estimatedHours": 17,
          "description": "Master & (Clear/Check), | (Set), ^ (Toggle), ~ (Flip), << (Shift). HIGHEST ROI section - in Embedded C, you control hardware by writing to 32-bit Registers. Set Bit 5 to turn on LED, read Bit 3 to check button press. Changing the wrong bit crashes the system.",
          "learningTip": [
            "**Registers:** A 32-bit register controls 32 different things. You must change ONE bit without touching the others.",
            "**Read-Modify-Write:** The golden rule of embedded. Read register, modify local copy, write back. `REG |= (1<<5);`",
            "**Masking:** A 'mask' selects specific bits. `0xFF` selects the bottom 8 bits.",
            "**Signed vs Unsigned:** Shifting signed integers is dangerous (arithmetic shift vs logical shift). ALWAYS use `uint32_t` for bitwise ops."
          ],
          "mustNotMiss": [
            "**SET Bit N:** `reg |= (1 << n);`",
            "**CLEAR Bit N:** `reg &= ~(1 << n);` (The `~` inverts the mask, putting a 0 at N and 1s elsewhere).",
            "**TOGGLE Bit N:** `reg ^= (1 << n);`",
            "**CHECK Bit N:** `if ((reg >> n) & 1)` OR `if (reg & (1 << n))`.",
            "**Extract N bits:** `(reg >> shift) & ((1 << width) - 1)`."
          ],
          "interviewQuestions": [
            {
              "question": "Write a macro to Set, Clear, and Toggle a bit.",
              "answer": "`#define SET_BIT(reg, n) ((reg) |= (1U << (n)))` ... note the specific casting `1U` to avoid signed shift UB."
            },
            {
              "question": "How to check if a number is a power of 2?",
              "answer": "`x && !(x & (x - 1))` - Standard interview trick."
            },
            {
              "question": "Swap two numbers without a temporary variable.",
              "answer": "`a ^= b; b ^= a; a ^= b;` - Classic XOR swap."
            }
          ],
          "resources": [
            "https://graphics.stanford.edu/~seander/bithacks.html - The Bible of Bit Twiddling Hacks",
            "https://en.wikipedia.org/wiki/Bitwise_operations_in_C - Reference"
          ],
          "practiceQuestions": [
            {
              "name": "Number of 1 Bits",
              "slug": "number-of-1-bits",
              "number": 191,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/number-of-1-bits/"
            },
            {
              "name": "Single Number",
              "slug": "single-number",
              "number": 136,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/single-number/"
            },
            {
              "name": "Missing Number",
              "slug": "missing-number",
              "number": 268,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/missing-number/"
            },
            {
              "name": "Add Binary",
              "slug": "add-binary",
              "number": 67,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/add-binary/"
            },
            {
              "name": "Reverse Bits",
              "slug": "reverse-bits",
              "number": 190,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-bits/"
            },
            {
              "name": "Power of Two",
              "slug": "power-of-two",
              "number": 231,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/power-of-two/"
            },
            {
              "name": "Hamming Distance",
              "slug": "hamming-distance",
              "number": 461,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/hamming-distance/"
            },
            {
              "name": "Complement of Base 10 Integer",
              "slug": "complement-of-base-10-integer",
              "number": 1009,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/complement-of-base-10-integer/"
            },
            {
              "name": "Find the Difference",
              "slug": "find-the-difference",
              "number": 389,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-difference/"
            }
          ]
        },
        {
          "id": "week_6_advanced_bit_hacks",
          "name": "Week 6: Advanced Bit Hacks",
          "estimatedHours": 15.5,
          "description": "Using masks to pack/unpack data. Semiconductor context: Packet Headers - a single 32-bit integer stores [Version: 4 bits][Length: 8 bits][Type: 4 bits][ID: 16 bits]. Extract using shifts and masks. **New:** Compiler Intrinsics and SWAR.",
          "learningTip": [
            "**Bitfields vs Shifts:** C bitfields (`struct { int a:4; }`) are non-portable (endianness issues). Embedded engineers prefer strict manual shifts and masks.",
            "**Branchless Programming:** `abs(x)` or `min(a,b)` can be done without `if` statements using bit hacks. Critical for pipelines.",
            "**Circular Buffers:** `tail = (tail + 1) & (SIZE - 1)` works ONLY if SIZE is power of 2. This is the most common embedded optimization.",
            "**Intrinsics (GCC/Clang):** Use `__builtin_clz(x)` (Count Leading Zeros) for finding highest priority bit. Use `__builtin_popcount(x)` for Hamming weight. These compile to SINGLE instructions on ARM/x86.",
            "**SWAR (SIMD Within A Register):** Processing 4 bytes at once in a `uint32_t`. Example: Check if any byte is zero: `(v - 0x01010101UL) & ~v & 0x80808080UL`."
          ],
          "mustNotMiss": [
            "**Isolate Lowest Set Bit:** `x & (-x)`. Binary form of `-x` is `~x + 1`.",
            "**Clear Lowest Set Bit:** `x & (x - 1)`. If `x` becomes 0, it was a power of 2.",
            "**Brian Kernighan’s Algorithm:** `while(n) { n &= (n-1); count++; }` - counts set bits in O(set_bits) time, not O(32).",
            "**Mask Creation:** `(1 << k) - 1` creates a mask of `k` ones.",
            "**Intrinsic functions:** know `__builtin_ctz`, `__builtin_clz`, `__builtin_popcount`."
          ],
          "interviewQuestions": [
            {
              "question": "Reverse bits of a byte using a lookup table.",
              "answer": "**Table Driven.** `O(1)` approach. `table[b]`. Trade-off: 256 bytes memory vs CPU cycles."
            },
            {
              "question": "Detect if two integers have opposite signs.",
              "answer": "`((x ^ y) < 0)`. The sign bit (MSB) will be 1 only if signs differ."
            },
            {
              "question": "Compute `x % n` where `n` is power of 2.",
              "answer": "`x & (n - 1)`. Much faster than modulo operator `%`."
            },
            {
              "question": "Implement `strlen` without a loop (using SWAR).",
              "answer": "**SWAR (SIMD Within A Register).** Read 4 bytes at a time as `uint32_t`. Use bit magic `(v - 0x01010101UL) & ~v & 0x80808080UL` to detect if any of the 4 bytes is NULL (0). Faster than byte-by-byte."
            }
          ],
          "resources": [
            "https://dev.to/somedood/bitwise-ops-for-networking-18n4 - Bitwise ops in Networking Headers",
            "https://catonmat.net/low-level-bit-hacks - Low Level Bit Hacks"
          ],
          "practiceQuestions": [
            {
              "name": "Counting Bits",
              "slug": "counting-bits",
              "number": 338,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/counting-bits/"
            },
            {
              "name": "Binary Number with Alternating Bits",
              "slug": "binary-number-with-alternating-bits",
              "number": 693,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-number-with-alternating-bits/"
            },
            {
              "name": "Subsets",
              "slug": "subsets",
              "number": 78,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/subsets/"
            },
            {
              "name": "Total Hamming Distance",
              "slug": "total-hamming-distance",
              "number": 477,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/total-hamming-distance/"
            },
            {
              "name": "Single Number II",
              "slug": "single-number-ii",
              "number": 137,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/single-number-ii/"
            },
            {
              "name": "Single Number III",
              "slug": "single-number-iii",
              "number": 260,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/single-number-iii/"
            },
            {
              "name": "Sum of Two Integers",
              "slug": "sum-of-two-integers",
              "number": 371,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/sum-of-two-integers/"
            }
          ]
        },
        {
          "id": "week_7_math_number_theory",
          "name": "Week 7: Math & Number Theory",
          "estimatedHours": 15.5,
          "description": "Modulo arithmetic, GCD, Primes. Semiconductor context: Timers & Clocks - calculate divisor for 80MHz clock to 9600 baud rate. Cryptography relies on Primes and GCD for secure boot.",
          "learningTip": [
            "**Prescalers:** How to get 1Hz from 80MHz? Divisors! GCD helps find the simplest integer ratio.",
            "**Ring Buffers:** `index = (index + 1) % SIZE`. Modulo arithmetic is the engine of circular queues.",
            "**Overflow:** `(a * b) % m` can overflow 32-bit `int` even if result < m. Cast to `uint64_t` first.",
            "**Cryptography:** RSS/ECC relies on modular exponentiation. Understanding `(a^b) % m` is the first step to crypto firmware."
          ],
          "mustNotMiss": [
            "**Euclidean Algo:** `gcd(a, b) = gcd(b, a % b)`. Recurse until `b == 0`. The base cases are non-negotiable.",
            "**LCM:** `lcm(a, b) = (a * b) / gcd(a, b)`. BEWARE: `a*b` might overflow. Do `(a / gcd(a,b)) * b` instead.",
            "**Prime Check:** Trial division up to `sqrt(N)`. If no divisors found by then, it's prime.",
            "**Fast Power:** `pow(x, n)` in O(log N) using binary exponentiation (`x^10 = (x^5)^2`)."
          ],
          "interviewQuestions": [
            {
              "question": "Implement `pow(a, b) % m` safely.",
              "answer": "**Modular Exponentiation.** Loop bits of `b`. If bit set, `res = (res * a) % m`. Always `a = (a * a) % m`."
            },
            {
              "question": "Calculate the Least Common Multiple of two Timer periods.",
              "answer": "`LCM(T1, T2) = (T1 * T2) / GCD(T1, T2)`. Used to synchronize tasks or find hyperperiod in RTOS schedulers."
            }
          ],
          "resources": [
            "https://cp-algorithms.com/algebra/binary-exp.html - Binary Exponentiation",
            "https://www.embedded.com/mathematics-of-fixed-point-arithmetic/ - Embedded Math"
          ],
          "practiceQuestions": [
            {
              "name": "Happy Number",
              "slug": "happy-number",
              "number": 202,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/happy-number/"
            },
            {
              "name": "Power of Three",
              "slug": "power-of-three",
              "number": 326,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/power-of-three/"
            },
            {
              "name": "Excel Sheet Column Number",
              "slug": "excel-sheet-column-number",
              "number": 171,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/excel-sheet-column-number/"
            },
            {
              "name": "Sqrt(x)",
              "slug": "sqrtx",
              "number": 69,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/sqrtx/"
            },
            {
              "name": "Pow(x, n)",
              "slug": "pow(x,-n)",
              "number": 50,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/pow(x,-n)/"
            },
            {
              "name": "Count Primes",
              "slug": "count-primes",
              "number": 204,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/count-primes/"
            },
            {
              "name": "Factorial Trailing Zeroes",
              "slug": "factorial-trailing-zeroes",
              "number": 172,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/factorial-trailing-zeroes/"
            }
          ]
        },
        {
          "id": "week_8_review_floating_point",
          "name": "Week 8: Review & Floating Point",
          "estimatedHours": 13.5,
          "description": "Review hardest Bit Manipulation problems. Project: Manual IEEE 754 Parser - proves understanding of how hardware stores decimals. Deep dive into floating point quirks.",
          "learningTip": [
            "**IEEE 754:** `Sign(1) | Exponent(8) | Mantissa(23)`. Understanding this layout is mandatory for writing specific drivers/bootloaders.",
            "**Fixed-Point:** Most cheap microcontrollers (Cortex-M0) HAVE NO FPU! We use 'Q-Format'. `Q16.16` means 16 bits integer, 16 bits fraction.",
            "**Precision:** `float` has ~7 decimal digits. `double` has ~15. `0.1 + 0.2 != 0.3` because 0.1 is infinite binary fraction.",
            "**Exceptions:** `NaN` (0/0) and `Inf` (1/0). Hardware FPU raises flags when these happen."
          ],
          "mustNotMiss": [
            "**Comparison:** NEVER use `a == b` for floats. Use `fabs(a - b) < EPSILON`.",
            "**Casting:** `(int)3.99` is `3`. Truncation is not rounding. Use `(int)(x + 0.5)` to round positive numbers.",
            "**Volatile Double:** Sometimes used to force FPU register flush, but generally avoid floats in Interrupt Service Routines (ISRs) - they are slow and save/restore context is huge."
          ],
          "interviewQuestions": [
            {
              "question": "Write a function to compare two floating point numbers.",
              "answer": "`bool isEqual(float a, float b) { return fabsf(a - b) < 1e-9; }`"
            },
            {
              "question": "What is a Subnormal (Denormal) number?",
              "answer": "Very small numbers near zero where the exponent is all 0s. They effectively reduce precision to represent smaller values. Processing them is 100x slower on some FPUs."
            },
            {
              "question": "Convert `3.5` to Q16.16 fixed-point format.",
              "answer": "`3.5 * 65536 = 229376`. Or `(3 << 16) | (1 << 15)`."
            }
          ],
          "resources": [
            "https://www.h-schmidt.net/FloatConverter/IEEE754.html - Interactive IEEE 754 Viewer",
            "https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ - The danger of float comparison"
          ],
          "practiceQuestions": [
            {
              "name": "Fraction to Recurring Decimal",
              "slug": "fraction-to-recurring-decimal",
              "number": 166,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/fraction-to-recurring-decimal/"
            },
            {
              "name": "Super Pow",
              "slug": "super-pow",
              "number": 372,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/super-pow/"
            },
            {
              "name": "Max Points on a Line",
              "slug": "max-points-on-a-line",
              "number": 149,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/max-points-on-a-line/"
            },
            {
              "name": "Valid Number",
              "slug": "valid-number",
              "number": 65,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/valid-number/"
            },
            {
              "name": "Basic Calculator",
              "slug": "basic-calculator",
              "number": 224,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/basic-calculator/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_3_data_streams_sliding_windows",
      "name": "Data Streams & Sliding Windows",
      "tier": 1,
      "estimatedHours": 53,
      "topics": [
        {
          "id": "week_9_string_parsing",
          "name": "Week 9: String Parsing (UART Context)",
          "estimatedHours": 14,
          "description": "Handling char arrays without standard libraries. Semiconductor context: AT Commands - ESP32 WiFi module sends '+WIFI:CONNECTED', need to parse this string to know state. Data arrives byte-by-byte via UART or SPI.",
          "learningTip": [
            "**No std::string:** In embedded C, a string is just a `char` array. You manage the memory and the NULL terminator.",
            "**Safety First:** `strcpy` is banned in safety-critical code (MISRA C). Use `strncpy` or `strlcpy` to prevent buffer overflows.",
            "**State Machines:** Parsing UART streams usually involves a 'switch-case' state machine processing one char at a time.",
            "**ATOI Implementation:** Writing `atoi` from scratch is a standard interview question to test ASCII arithmetic (`'5' - '0' = 5`)."
          ],
          "mustNotMiss": [
            "**NULL Terminator:** `char s[4] = \"ABC\";` includes `\\0`. Forgetting room for `\\0` is the #1 bug.",
            "**Bounds Checking:** Always know the size of your buffer. `buf[i]` access must check `if (i < SIZE)`.",
            "**Const Correctness:** `const char *s` means you can't change the characters. `char * const s` means you can't change the pointer.",
            "**Ascii Arithmetic:** `isdigit(c)` is `c >= '0' && c <= '9'`. `to_upper(c)` is `c - 'a' + 'A'`."
          ],
          "interviewQuestions": [
            {
              "question": "Implement `atoi` (String to Integer) handling overflows and whitespace.",
              "answer": "**Parsers.** Skip whitespace, handle sign, process digits `res = res*10 + (c-'0')`. Check `res > INT_MAX/10` for overflow."
            },
            {
              "question": "Implement `strstr` (Find substring).",
              "answer": "**Sliding Window / Brute Force.** Check if `needle` matches `haystack` starting at every position. optimize with KMP (advanced)."
            },
            {
              "question": "How do you parse a comma-separated string in C?",
              "answer": "**`strtok` vs Manual.** `strtok` modifies the string (inserts `\\0`). Re-entrant version `strtok_r` is preferred for RTOS threads."
            }
          ],
          "resources": [
            "https://barrgroup.com/embedded-systems/how-to/c-strings-embedded-software - Usage of Strings in Embedded",
            "https://en.cppreference.com/w/c/string/byte - Standard Library Reference"
          ],
          "practiceQuestions": [
            {
              "name": "Valid Anagram",
              "slug": "valid-anagram",
              "number": 242,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-anagram/"
            },
            {
              "name": "First Unique Character in a String",
              "slug": "first-unique-character-in-a-string",
              "number": 387,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/first-unique-character-in-a-string/"
            },
            {
              "name": "Implement strStr()",
              "slug": "find-the-index-of-the-first-occurrence-in-a-string",
              "number": 28,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
            },
            {
              "name": "Longest Common Prefix",
              "slug": "longest-common-prefix",
              "number": 14,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/longest-common-prefix/"
            },
            {
              "name": "Length of Last Word",
              "slug": "length-of-last-word",
              "number": 58,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/length-of-last-word/"
            },
            {
              "name": "Is Subsequence",
              "slug": "is-subsequence",
              "number": 392,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/is-subsequence/"
            },
            {
              "name": "Reverse Words in a String",
              "slug": "reverse-words-in-a-string",
              "number": 151,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-words-in-a-string/"
            },
            {
              "name": "String to Integer (atoi)",
              "slug": "string-to-integer-atoi",
              "number": 8,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/string-to-integer-atoi/"
            },
            {
              "name": "Longest Palindromic Substring",
              "slug": "longest-palindromic-substring",
              "number": 5,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-substring/"
            }
          ]
        },
        {
          "id": "week_10_fixed_sliding_window",
          "name": "Week 10: Fixed Sliding Window (DSP Filters)",
          "estimatedHours": 12.5,
          "description": "Window of size k moves across array. Semiconductor context: Moving Average Filter - smooth noisy temperature sensor by averaging last 10 readings. Foundation of Digital Signal Processing (FIR Filters).",
          "learningTip": [
            "**O(1) Update:** Don't re-sum the window! `newSum = oldSum - leaving + entering`. This is the definition of a recursive filter.",
            "**DSP Context:** This pattern *is* a Moving Average Filter. It smooths out high-frequency noise from sensors.",
            "**Circular Buffer:** In real firmware, the window wraps around. `buffer[head] = newVal; sum += newVal - buffer[tail];`",
            "**Pattern:** Initialize first k elements manually, then loop from k to n."
          ],
          "mustNotMiss": [
            "**Initialization:** Process first `k` elements separately -> `currentSum`.",
            "**Loop:** `for(i = k; i < n; step++) { currentSum += arr[i] - arr[i-k]; maxSum = max(maxSum, currentSum); }`",
            "**Boundary Check:** Ensure `n >= k`. If array is smaller than window, handle gracefully (return error or partial sum).",
            "**Rolling Hash:** The same 'add new, remove old' logic applies to hashing (Rabin-Karp) for substring search."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Moving Average Filter efficiently.",
              "answer": "**Circular Buffer + Running Sum.** `sum -= buffer[tail]; sum += new_val; buffer[tail] = new_val; tail = (tail+1)%K;` O(1) time."
            },
            {
              "question": "Detect if a permutation of string S1 exists in S2.",
              "answer": "**Fixed Frequency Map.** Window of size `len(S1)`. Maintain count of chars. If counts match, permutation found. O(N)."
            },
            {
              "question": "Find the maximum sum of any contiguous subarray of size K.",
              "answer": "**Sliding Window.** Calculate sum of first K. Then slide, adding `arr[i]` and subtracting `arr[i-k]`."
            }
          ],
          "resources": [
            "https://www.dsprelated.com/freebooks/filters/Moving_Average_Filters.html - The Math of Moving Averages",
            "https://leetcode.com/articles/sliding-window-maximum/ - Sliding Window guide"
          ],
          "practiceQuestions": [
            {
              "name": "Maximum Average Subarray I",
              "slug": "maximum-average-subarray-i",
              "number": 643,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-average-subarray-i/"
            },
            {
              "name": "Contains Duplicate II",
              "slug": "contains-duplicate-ii",
              "number": 219,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/contains-duplicate-ii/"
            },
            {
              "name": "Diet Plan Performance",
              "slug": "diet-plan-performance",
              "number": 1176,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/diet-plan-performance/"
            },
            {
              "name": "K Radius Subarray Averages",
              "slug": "k-radius-subarray-averages",
              "number": 2090,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/k-radius-subarray-averages/"
            },
            {
              "name": "Maximum Number of Vowels in a Substring",
              "slug": "maximum-number-of-vowels-in-a-substring",
              "number": 1456,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring/"
            },
            {
              "name": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
              "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
              "number": 1343,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/"
            },
            {
              "name": "Permutation in String",
              "slug": "permutation-in-string",
              "number": 567,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/permutation-in-string/"
            },
            {
              "name": "Find All Anagrams in a String",
              "slug": "find-all-anagrams-in-a-string",
              "number": 438,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-all-anagrams-in-a-string/"
            },
            {
              "name": "Repeated DNA Sequences",
              "slug": "repeated-dna-sequences",
              "number": 187,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/repeated-dna-sequences/"
            },
            {
              "name": "Sliding Window Maximum",
              "slug": "sliding-window-maximum",
              "number": 239,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/sliding-window-maximum/"
            }
          ]
        },
        {
          "id": "week_11_dynamic_sliding_window",
          "name": "Week 11: Dynamic Sliding Window",
          "estimatedHours": 14,
          "description": "Window expands and shrinks based on data validity. Semiconductor context: TCP Congestion Control - expand window until packet loss (condition fail), then shrink. Variable Bitrate Buffers.",
          "learningTip": [
            "**Expand then Shrink:** `for(right...) { add(right); while(invalid) { remove(left); left++; } update_max(); }`",
            "**Monotonicity:** The window only slides right. `left` never moves back. O(2N) = O(N).",
            "**Embedded use:** Finding the longest interference-free signal block, or managing variable-length UART packets."
          ],
          "mustNotMiss": [
            "**Invariant:** The window `[left, right]` must always satisfy the condition (or be about to fix it).",
            "**Min vs Max:** For 'Longest Valid Subarray', update answer *after* the while loop. For 'Shortest Valid Subarray', update *inside* the while loop.",
            "**Frequency Map:** Use `int count[256]` instead of HashMaps for character problems. Much faster and zero-allocation."
          ],
          "interviewQuestions": [
            {
              "question": "Find longest subarray with sum <= K.",
              "answer": "**Dynamic Window.** Expand right, if sum > K, shrink left until sum <= K. O(N)."
            },
            {
              "question": "Implement a Rate Limiter.",
              "answer": "**Sliding Window Counter.** Keep timestamps in a queue. Remove timestamps older than 1 second. if `size() < LIMIT`, allow request."
            },
            {
              "question": "Find the smallest window in String S containing all characters of String T.",
              "answer": "**Minimum Window Substring.** Use frequency arrays. Expand until all chars found, then shrink left to minimize."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/minimum-window-substring/solution/ - The ultimate sliding window template",
            "https://www.geeksforgeeks.org/window-sliding-technique/ - GeeksForGeeks Guide"
          ],
          "practiceQuestions": [
            {
              "name": "Maximize the Confusion of an Exam",
              "slug": "maximize-the-confusion-of-an-exam",
              "number": 2024,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximize-the-confusion-of-an-exam/"
            },
            {
              "name": "Binary Subarrays With Sum",
              "slug": "binary-subarrays-with-sum",
              "number": 930,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/binary-subarrays-with-sum/"
            },
            {
              "name": "Count Complete Subarrays in an Array",
              "slug": "count-complete-subarrays-in-an-array",
              "number": 2799,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/count-complete-subarrays-in-an-array/"
            },
            {
              "name": "Minimum Window Substring (Hard)",
              "slug": "minimum-window-substring-(hard)",
              "number": 76,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/minimum-window-substring-(hard)/"
            },
            {
              "name": "Longest Substring Without Repeating Characters",
              "slug": "longest-substring-without-repeating-characters",
              "number": 3,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            },
            {
              "name": "Max Consecutive Ones III",
              "slug": "max-consecutive-ones-iii",
              "number": 1004,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/max-consecutive-ones-iii/"
            },
            {
              "name": "Minimum Size Subarray Sum",
              "slug": "minimum-size-subarray-sum",
              "number": 209,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/minimum-size-subarray-sum/"
            },
            {
              "name": "Longest Repeating Character Replacement",
              "slug": "longest-repeating-character-replacement",
              "number": 424,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-repeating-character-replacement/"
            },
            {
              "name": "Fruit Into Baskets",
              "slug": "fruit-into-baskets",
              "number": 904,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/fruit-into-baskets/"
            },
            {
              "name": "Count Number of Nice Subarrays",
              "slug": "count-number-of-nice-subarrays",
              "number": 1248,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/count-number-of-nice-subarrays/"
            },
            {
              "name": "Minimum Window Substring",
              "slug": "minimum-window-substring",
              "number": 76,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/minimum-window-substring/"
            }
          ]
        },
        {
          "id": "week_12_buffer_review",
          "name": "Week 12: Buffer Review (Ring Buffers)",
          "estimatedHours": 12.5,
          "description": "Deep dive into Data Structures for Data Streams. Semiconductor context: UART RX Buffer (Ring Buffer), Audio DMA (Double Buffering), and Frame Buffers. **New:** DMA Descriptors & Scatter-Gather.",
          "learningTip": [
            "**Ring Buffer:** FIFO structure with fixed size. `head` writes, `tail` reads. Critical for UART/SPI drivers.",
            "**DMA (Direct Memory Access):** Hardware copies data from Peripheral to RAM while CPU sleeps. You just process the buffer.",
            "**Double Buffering (Ping-Pong):** Use two buffers. DMA fills Buffer A. When full, DMA switches to Buffer B (interrupt fires). CPU processes A while DMA fills B. Zero downtime.",
            "**DMA Descriptors:** A Linked List in hardware! Each node contains: `srcptr`, `destptr`, `size`, `next_desc_ptr`. Allows DMA to scatter/gather data without CPU intervention.",
            "**Atomic access:** Updating `head` or `tail` must be atomic if shared between ISR and Main Loop."
          ],
          "mustNotMiss": [
            "**Next Position:** `next = (current + 1) % SIZE`. Avoid `%` if SIZE is power of 2: `(current + 1) & (SIZE - 1)`.",
            "**Full vs Empty:** If `head == tail`, is it empty or full? Standard solution: Keep one slot open. `(head + 1) % SIZE == tail` means Full.",
            "**Volatile:** Buffer memory shared with ISR must be `volatile` to prevent compiler caching.",
            "**Descriptor Chaining:** How to process non-contiguous memory blocks using DMA? Chain descriptors."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Circular Buffer in C.",
              "answer": "**Struct-based.** `typedef struct { uint8_t data[SIZE]; size_t head; size_t tail; } RingBuf;`. Implement `push()` and `pop()`."
            },
            {
              "question": "Why do we need 'volatile' for DMA buffers?",
              "answer": "**Cache Coherency.** The hardware modifies memory behind the CPU's back. The compiler must know values can change unexpectedly."
            },
            {
              "question": "Explain 'Scatter-Gather' DMA.",
              "answer": "**Non-Contiguous IO.** Instead of one large block, DMA reads a Linked List of 'Descriptors'. Each descriptor points to a small buffer. Allows copying fragmented memory into a single peripheral stream without CPU copying."
            }
          ],
          "resources": [
            "https://embed.org/blog/ring-buffer/ - Ring Buffer implementation details",
            "https://www.doulos.com/knowhow/c/volatile/ - Understanding Volatile"
          ],
          "practiceQuestions": [
            {
              "name": "Moving Average from Data Stream",
              "slug": "moving-average-from-data-stream",
              "number": 346,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/moving-average-from-data-stream/"
            },
            {
              "name": "Implement Queue using Stacks",
              "slug": "implement-queue-using-stacks",
              "number": 232,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-queue-using-stacks/"
            },
            {
              "name": "Design Circular Deque",
              "slug": "design-circular-deque",
              "number": 641,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-circular-deque/"
            },
            {
              "name": "Design Circular Queue",
              "slug": "design-circular-queue",
              "number": 622,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-circular-queue/"
            },
            {
              "name": "Peeking Iterator",
              "slug": "peeking-iterator",
              "number": 284,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/peeking-iterator/"
            },
            {
              "name": "Flatten Nested List Iterator",
              "slug": "flatten-nested-list-iterator",
              "number": 341,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/flatten-nested-list-iterator/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_4_linked_lists_stacks",
      "name": "Linked Lists & Stacks (The Kernel)",
      "tier": 2,
      "estimatedHours": 94.5,
      "topics": [
        {
          "id": "week_13_singly_linked_lists",
          "name": "Week 13: Singly Linked Lists (OS Basics)",
          "estimatedHours": 23,
          "description": "Manipulating next pointers. Semiconductor context: OS Kernel (FreeRTOS) 'ReadyQueue' is a Linked List of tasks. 'Malloc' uses a Free List to track empty memory blocks.",
          "learningTip": [
            "**Cache Miss:** Linked Lists are terrible for CPU cache. Random jumps in memory. Use arrays unless O(1) mid-insert is strictly required.",
            "**Intrusive Lists:** In kernels, the 'next' pointer is embedded *inside* the Task struct, not a separate Wrapper Node. `struct Task { ... struct list_head list; ... }`.",
            "**Sentinel Nodes:** Always use a 'Dummy Head' to simplify edge cases (inserting at start/end).",
            "**Cycle Detection:** Drivers often hang in infinite loops if a list becomes circular. Floyd's Algorithm protects against this."
          ],
          "mustNotMiss": [
            "**Traversal:** `while(curr) { process(curr); curr = curr->next; }`",
            "**Reverse:** `next = curr->next; curr->next = prev; prev = curr; curr = next;` - Memorize this.",
            "**Fast/Slow:** Pattern for finding middle (1x/2x speed) or cycles.",
            "**Memory Leak:** Removing a node? `free()` it! In embedded, leaking 10 bytes/sec crashes the system in days."
          ],
          "interviewQuestions": [
            {
              "question": "Reverse a Linked List in-place.",
              "answer": "**3 Pointers.** `prev`, `curr`, `next`. Iterate and flip pointers. Return `prev` as new head."
            },
            {
              "question": "Detect a cycle in a linked list.",
              "answer": "**Floyd's Cycle-Finding Algorithm.** Slow pointer moves 1 step, Fast moves 2. If they collide, there is a cycle."
            },
            {
              "question": "Why avoid Linked Lists in real-time systems?",
              "answer": "**Determinism.** Traversing a list is O(N) with unknown cache hits. Arrays allows O(1) access and prefetching."
            }
          ],
          "resources": [
            "https://kernel.org/doc/html/latest/core-api/kernel-api.html#list-management-functions - Linux Kernel List API",
            "https://www.data-structures-in-practice.com/intrusive-linked-lists/ - Intrusive Lists explained"
          ],
          "practiceQuestions": [
            {
              "name": "Reverse Linked List",
              "slug": "reverse-linked-list",
              "number": 206,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-linked-list/"
            },
            {
              "name": "Middle of the Linked List",
              "slug": "middle-of-the-linked-list",
              "number": 876,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/middle-of-the-linked-list/"
            },
            {
              "name": "Delete Node in a Linked List",
              "slug": "delete-node-in-a-linked-list",
              "number": 237,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/delete-node-in-a-linked-list/"
            },
            {
              "name": "Merge Two Sorted Lists",
              "slug": "merge-two-sorted-lists",
              "number": 21,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/merge-two-sorted-lists/"
            },
            {
              "name": "Remove Duplicates from Sorted List",
              "slug": "remove-duplicates-from-sorted-list",
              "number": 83,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
            },
            {
              "name": "Intersection of Two Linked Lists",
              "slug": "intersection-of-two-linked-lists",
              "number": 160,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
            },
            {
              "name": "Linked List Cycle",
              "slug": "linked-list-cycle",
              "number": 141,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/linked-list-cycle/"
            },
            {
              "name": "Palindrome Linked List",
              "slug": "palindrome-linked-list",
              "number": 234,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/palindrome-linked-list/"
            },
            {
              "name": "Remove Linked List Elements",
              "slug": "remove-linked-list-elements",
              "number": 203,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-linked-list-elements/"
            }
          ]
        },
        {
          "id": "week_14_advanced_lists",
          "name": "Week 14: Advanced Lists (Doubly Linked & LRU)",
          "estimatedHours": 25.5,
          "description": "Doubly Linked Lists and complex pointer manipulation. Semiconductor context: LRU Cache implementation - how CPU decides which cache line to evict.",
          "learningTip": [
            "**Doubly Linked:** `prev` pointer allows O(1) deletion if you have the node pointer. Essential for LRU Cache.",
            "**LRU Cache:** The 'Hello World' of System Design. HashMap (for lookup) + Doubly Linked List (for ordering).",
            "**Merge Sort:** The preferred sorting algorithm for Linked Lists (no random access needed).",
            "**Kernel API:** Linux uses `list_add`, `list_del`, `list_for_each` macros. Learn to read them."
          ],
          "mustNotMiss": [
            "**Delete DLL Node:** `node->prev->next = node->next; node->next->prev = node->prev;` (Check NULLs!)",
            "**Insert After:** `new->next = cur->next; new->prev = cur; cur->next->prev = new; cur->next = new;`",
            "**LRU Logic:** Access -> Move to Head. Full -> Remove Tail.",
            "**XOR List:** Obscure trick to save memory: `next ^ prev`. Interviewers love asking about this for embedded."
          ],
          "interviewQuestions": [
            {
              "question": "Implement an LRU Cache.",
              "answer": "**Hash Map + Doubly Linked List.** Map stores `<Key, Node*>`. List stores `Nodes` ordered by recency. Get: Move to head. Put: Add to head, evict tail if full."
            },
            {
              "question": "Reverse a Doubly Linked List.",
              "answer": "**Swap Pointers.** For each node, `swap(curr->next, curr->prev)`. Then `head = curr->prev` at the end."
            },
            {
              "question": "How to implement a simplified 'malloc'?",
              "answer": "**Free List.** A linked list of free blocks. `malloc` finds a block of size >= N. `free` adds it back to the list."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/lru-cache/solution/ - Standard LRU Implementation",
            "https://wiki.osdev.org/Memory_Allocation - OS Memory Allocators"
          ],
          "practiceQuestions": [
            {
              "name": "Reverse Nodes in k",
              "slug": "reverse-nodes-in-k",
              "number": 25,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reverse-nodes-in-k/"
            },
            {
              "name": "Linked List Cycle II",
              "slug": "linked-list-cycle-ii",
              "number": 142,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/linked-list-cycle-ii/"
            },
            {
              "name": "Remove Nth Node From End of List",
              "slug": "remove-nth-node-from-end-of-list",
              "number": 19,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
            },
            {
              "name": "Copy List with Random Pointer",
              "slug": "copy-list-with-random-pointer",
              "number": 138,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/copy-list-with-random-pointer/"
            },
            {
              "name": "LRU Cache",
              "slug": "lru-cache",
              "number": 146,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lru-cache/"
            },
            {
              "name": "Reorder List",
              "slug": "reorder-list",
              "number": 143,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reorder-list/"
            },
            {
              "name": "Rotate List",
              "slug": "rotate-list",
              "number": 61,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotate-list/"
            },
            {
              "name": "Swap Nodes in Pairs",
              "slug": "swap-nodes-in-pairs",
              "number": 24,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/swap-nodes-in-pairs/"
            },
            {
              "name": "Add Two Numbers",
              "slug": "add-two-numbers",
              "number": 2,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/add-two-numbers/"
            },
            {
              "name": "Reverse Linked List II",
              "slug": "reverse-linked-list-ii",
              "number": 92,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/reverse-linked-list-ii/"
            }
          ]
        },
        {
          "id": "week_15_stacks",
          "name": "Week 15: Stacks (LIFO)",
          "estimatedHours": 23,
          "description": "Last In, First Out. Semiconductor context: Nested Interrupts - CPU pushes context to stack when ISR fires, pops it back when done. Stack overflow causes Hard Fault. **New:** Stack Painting & Canaries.",
          "learningTip": [
            "Stack: LIFO - Last In First Out",
            "Used for: function calls (call stack), expression evaluation, undo, DFS",
            "Array implementation: O(1) push/pop, fixed size",
            "Understanding call stack is essential for debugging and recursion",
            "**Stack Painting:** Fill stack memory with a pattern (e.g., `0xDEADBEEF`) at startup. To find 'High Water Mark' (max usage), count how many patterns remain untouched.",
            "**Stack Canary:** A special value placed at the end of a stack frame. If a buffer overflow overwrites it, the CPU triggers a Fault before returning, preventing code injection."
          ],
          "mustNotMiss": [
            "Array stack: int stack[SIZE]; int top = -1;",
            "Push: if(top < SIZE-1) stack[++top] = val; else overflow_error();",
            "Pop: if(top >= 0) return stack[top--]; else underflow_error();",
            "Peek: if(top >= 0) return stack[top];",
            "In C: function calls use stack - local variables, return addresses stored there",
            "Stack overflow: recursion too deep, or large local arrays - use static/heap instead",
            "**Hard Fault:** What happens when Stack Pointer hits the end of RAM? The CPU crashes safely (hopefully)."
          ],
          "interviewQuestions": [
            {
              "question": "How do you detect Stack Overflow in an embedded system?",
              "answer": "**Stack Painting.** Fill stack with `0xCC` or `0xDEADBEEF`. Periodically check from the bottom up to see how much of the pattern is overwritten. The boundary is the 'High Water Mark'."
            },
            {
              "question": "What is a Stack Canary?",
              "answer": "**Security/Safety.** A magic number placed before the Return Address on the stack. If a buffer overflow occurs, the canary is overwritten first. The function checks the canary before returning; if changed, it faults."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Valid Parentheses",
              "slug": "valid-parentheses",
              "number": 20,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/valid-parentheses/"
            },
            {
              "name": "Min Stack",
              "slug": "min-stack",
              "number": 155,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/min-stack/"
            },
            {
              "name": "Implement Queue using Stacks",
              "slug": "implement-queue-using-stacks",
              "number": 232,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-queue-using-stacks/"
            },
            {
              "name": "Evaluate Reverse Polish Notation",
              "slug": "evaluate-reverse-polish-notation",
              "number": 150,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
            },
            {
              "name": "Baseball Game",
              "slug": "baseball-game",
              "number": 682,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/baseball-game/"
            },
            {
              "name": "Remove All Adjacent Duplicates In String",
              "slug": "remove-all-adjacent-duplicates-in-string",
              "number": 1047,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/"
            },
            {
              "name": "Make The String Great",
              "slug": "make-the-string-great",
              "number": 1544,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/make-the-string-great/"
            },
            {
              "name": "Simplify Path",
              "slug": "simplify-path",
              "number": 71,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/simplify-path/"
            },
            {
              "name": "Decode String",
              "slug": "decode-string",
              "number": 394,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/decode-string/"
            }
          ]
        },
        {
          "id": "week_16_monotonic_stacks",
          "name": "Week 16: Monotonic Stacks (Telemetry Analysis)",
          "estimatedHours": 23,
          "description": "Finding the 'Next Greater Element'. Semiconductor context: Sensor Peak Detection - finding the next time temperature exceeds current threshold in a stream of log data.",
          "learningTip": [
            "**Monotonic Decreasing Stack:** Finds the 'Next Greater Element'. Elements in stack are always sorted descending.",
            "**Monotonic Increasing Stack:** Finds the 'Next Smaller Element'.",
            "**Pattern:** `while(!stack.isEmpty() && stack.peek() < current) { process(stack.pop()); } stack.push(current);`",
            "**Applications:** Histogram areas, stock spans, sensor threshold alerts."
          ],
          "mustNotMiss": [
            "**Next Greater Element:** Store indices, not values, to calculate distance.",
            "**Circular Array:** Loop indices `i % N` to simulate circular buffer behavior with monotonic stacks.",
            "**Trapping Rain Water:** Classic hard problem solvable with Monotonic Stack (or Two Pointers).",
            "**Complexity:** O(N). Each element is pushed once and popped once."
          ],
          "interviewQuestions": [
            {
              "question": "Find the Next Greater Element for every element in an array.",
              "answer": "**Monotonic Stack.** Iterate. While `current > stack.top`, pop stack and mark `current` as the next greater for the popped element."
            },
            {
              "question": "Find the largest rectangle in a histogram.",
              "answer": "**Monotonic Stack.** For each bar, find the first smaller bar to the left and right. The width is `right - left - 1`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/next-greater-element-ii/solution/ - NEXT Greater Element Pattern",
            "https://cp-algorithms.com/data_structures/stack_queue_modification.html - Advanced Stack Modifications"
          ],
          "practiceQuestions": [
            {
              "name": "Next Greater Element I",
              "slug": "next-greater-element-i",
              "number": 496,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/next-greater-element-i/"
            },
            {
              "name": "Next Greater Element II",
              "slug": "next-greater-element-ii",
              "number": 503,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/next-greater-element-ii/"
            },
            {
              "name": "Daily Temperatures",
              "slug": "daily-temperatures",
              "number": 739,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/daily-temperatures/"
            },
            {
              "name": "Online Stock Span",
              "slug": "online-stock-span",
              "number": 901,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/online-stock-span/"
            },
            {
              "name": "Largest Rectangle in Histogram",
              "slug": "largest-rectangle-in-histogram",
              "number": 84,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
            },
            {
              "name": "Trapping Rain Water",
              "slug": "trapping-rain-water",
              "number": 42,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/trapping-rain-water/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_5_queues_heaps_trees",
      "name": "Queues, Heaps & Trees (Buffering & Hierarchy)",
      "tier": 2,
      "estimatedHours": 96.5,
      "topics": [
        {
          "id": "week_17_circular_queues",
          "name": "Week 17: Circular Queues (UART Buffers)",
          "estimatedHours": 27,
          "description": "Fixed array that wraps around using Modulo %. THE #1 MOST USED structure in firmware - connects hardware (UART/ADC) to software. Connects ISRs to Main Loop.",
          "learningTip": [
            "**Ring Buffer:** The standard for async data. `head` is where data comes in (ISR), `tail` is where you read it.",
            "**Lock-Free:** If single producer (ISR) and single consumer (Main), you often don't need locks IF `head` and `tail` depend on atomic writes.",
            "**Modulo vs Bitwise:** `idx = (idx + 1) % SIZE` is slow. `idx = (idx + 1) & (SIZE - 1)` is fast implies SIZE is power of 2.",
            "**Project:** Write a UART Driver. `void UART_Handler() { rx_buffer.push(REG_DATA); }`"
          ],
          "mustNotMiss": [
            "**Full Condition:** `(head + 1) % SIZE == tail`. Leave one slot empty to distinguish Full from Empty.",
            "**Volatile:** `volatile int head, tail;` is mandatory if shared with ISR.",
            "**Decoupling:** Queues detaches 'hard absolute real-time' (ISR) from 'soft real-time' (processing).",
            "**DMA:** Advanced ring buffers use DMA to write memory directly. CPU only updates `tail`."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Lock-Free Ring Buffer in C.",
              "answer": "**Atomic Indices.** `push()` updates `data` then `head`. `pop()` reads `data` then updates `tail`. Memory barriers may be needed on ARM."
            },
            {
              "question": "Why is `size_t` better than `int` for array indexing?",
              "answer": "**Portability.** `size_t` guarantees holding the max array size of the platform (32-bit or 64-bit). `int` might overflow."
            },
            {
              "question": "How to handle buffer overflow in a UART RX ISR?",
              "answer": "**Drop or Overwrite.** Oldest Data (Overwrite) or Newest Data (Drop). Usually drop new data and set an 'Overflow Error' flag."
            }
          ],
          "resources": [
            "https://ferrous-systems.com/blog/lock-free-ring-buffer/ - Rust/Embedded Lock Free Ring Buffer",
            "https://www.embedded.com/ring-buffer-basics/ - Embedded.com Guide"
          ],
          "practiceQuestions": [
            {
              "name": "Moving Average from Data Stream",
              "slug": "moving-average-from-data-stream",
              "number": 346,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/moving-average-from-data-stream/"
            },
            {
              "name": "Implement Stack using Queues",
              "slug": "implement-stack-using-queues",
              "number": 225,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/implement-stack-using-queues/"
            },
            {
              "name": "Number of Recent Calls",
              "slug": "number-of-recent-calls",
              "number": 933,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/number-of-recent-calls/"
            },
            {
              "name": "Time Needed to Buy Tickets",
              "slug": "time-needed-to-buy-tickets",
              "number": 2073,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/time-needed-to-buy-tickets/"
            },
            {
              "name": "Design Circular Queue",
              "slug": "design-circular-queue",
              "number": 622,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-circular-queue/"
            },
            {
              "name": "Design Circular Deque",
              "slug": "design-circular-deque",
              "number": 641,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-circular-deque/"
            },
            {
              "name": "Dota2 Senate",
              "slug": "dota2-senate",
              "number": 649,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/dota2-senate/"
            }
          ]
        },
        {
          "id": "week_18_trees_bst",
          "name": "Week 18: Trees & BST (File Systems)",
          "estimatedHours": 24.5,
          "description": "Hierarchical data. Semiconductor context: File Systems (FAT32/Ext4) - directories are nodes, files are leaves. Device Trees (DTS) in Linux/Zephyr describe hardware topology.",
          "learningTip": [
            "**Recursive Structure:** A tree is a node with pointers to children. File systems are trees.",
            "**BST Property:** Left < Root < Right. In-order traversal gives sorted data. Used in `CFS` (Linux Scheduler) to track tasks by runtime.",
            "**Recursion vs Iteration:** Recursion uses stack space (potentially unsafe in firmware). Iterative DFS uses an explicit heap stack.",
            "**Project:** Implement a mock 'ls -R' (recursive list) for a simulated directory structure."
          ],
          "mustNotMiss": [
            "**Traversals:** Pre-order (Copy/Clone), In-order (Sorted), Post-order (Delete/Free).",
            "**Height:** `1 + max(height(left), height(right))`. Base case: `if(!node) return 0;`",
            "**BST Search:** `if(val < root->val) go_left; else go_right;` O(log N).",
            "**Stack Overflow:** In embedded, stick to 1-2KB stack. Avoid deep recursion. Use iterative traversal for deep trees."
          ],
          "interviewQuestions": [
            {
              "question": "Find the Lowest Common Ancestor (LCA) of two file paths.",
              "answer": "**Recursion.** If root matches either, return root. Look in left/right. If both return non-null, root is LCA."
            },
            {
              "question": "Validate a Binary Search Tree.",
              "answer": "**Range Check.** Pass `(min, max)` down. `validate(node, min, max)`. Left must be in `(min, node->val)`, Right in `(node->val, max)`."
            },
            {
              "question": "Serialize and Deserialize a Binary Tree (for storage).",
              "answer": "**Pre-order with Null markers.** Save `1,2,#,#,3,#,#`. Reconstruct by consuming stream."
            }
          ],
          "resources": [
            "https://devicetree.org/ - Linux Device Tree Specification",
            "https://leetcode.com/problems/validate-binary-search-tree/solution/ - BST Validation Patterns"
          ],
          "practiceQuestions": [
            {
              "name": "Maximum Depth of Binary Tree",
              "slug": "maximum-depth-of-binary-tree",
              "number": 104,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
            },
            {
              "name": "Same Tree",
              "slug": "same-tree",
              "number": 100,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/same-tree/"
            },
            {
              "name": "Invert Binary Tree",
              "slug": "invert-binary-tree",
              "number": 226,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/invert-binary-tree/"
            },
            {
              "name": "Binary Tree Level Order Traversal",
              "slug": "binary-tree-level-order-traversal",
              "number": 102,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
            },
            {
              "name": "Validate Binary Search Tree",
              "slug": "validate-binary-search-tree",
              "number": 98,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/validate-binary-search-tree/"
            },
            {
              "name": "Lowest Common Ancestor of a Binary Search Tree",
              "slug": "lowest-common-ancestor-of-a-binary-search-tree",
              "number": 235,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
            },
            {
              "name": "Construct Binary Tree from Preorder and Inorder Traversal",
              "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
              "number": 105,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
            },
            {
              "name": "Serialize and Deserialize Binary Tree",
              "slug": "serialize-and-deserialize-binary-tree",
              "number": 297,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"
            }
          ]
        },
        {
          "id": "week_19_tries",
          "name": "Week 19: Tries (IP Routing)",
          "estimatedHours": 22.5,
          "description": "Prefix Trees. Semiconductor context: IP Routing Tables (Longest Prefix Match). Flash Filesystems (JFFS2) use trie-like structures for compression and path lookups.",
          "learningTip": [
            "**Prefix Tree:** Nodes are characters. Root -> c -> a -> t (word 'cat').",
            "**Space vs Time:** Tries trade memory for O(L) time complexity (L = string length). Faster than Hash Map O(L) for many strings with common prefixes.",
            "**Bitwise Trie:** Used in routers. Nodes are 0 or 1. Depth 32 for IPv4.",
            "**Project:** Implement an Autocomplete engine or a simple IP router lookup `search_ip(uint32_t ip)`."
          ],
          "mustNotMiss": [
            "**Structure:** `struct TrieNode { struct TrieNode *children[26]; bool isEnd; };`",
            "**Insert:** Loop char by char. If child is NULL, malloc it. Move down.",
            "**Search:** Loop char by char. If child NULL, return false. At end, return `isEnd`.",
            "**Memory Pool:** Mallocing millions of nodes is slow/fragmented. Use a static array of nodes `TrieNode pool[10000];` for high peformance."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Router with Longest Prefix Match.",
              "answer": "**Bitwise Trie.** Insert routes (e.g. 192.168.1.0/24). Search IP bit-by-bit. Keep track of the *last valid* leaf seen."
            },
            {
              "question": "Design an Autocomplete System.",
              "answer": "**Trie + Metadata.** Each node stores 'Top 3 hottest searches' with this prefix. O(1) retrieval after traversal."
            },
            {
              "question": "Replace Hash Map with Trie?",
              "answer": "**Yes, for Strings.** Trie has no collisions, sorted order (lexicographical), and can save space if prefixes are shared."
            }
          ],
          "resources": [
            "https://vincent.bernat.ch/en/blog/2017-ipv4-route-lookup-linux - How Linux does Route Lookup (Trie/Radix)",
            "https://leetcode.com/problems/implement-trie-prefix-tree/solution/ - Standard Trie Implementation"
          ],
          "practiceQuestions": [
            {
              "name": "Implement Trie (Prefix Tree)",
              "slug": "implement-trie-prefix-tree",
              "number": 208,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
            },
            {
              "name": "Design Add and Search Words Data Structure",
              "slug": "design-add-and-search-words-data-structure",
              "number": 211,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
            },
            {
              "name": "Longest Word in Dictionary",
              "slug": "longest-word-in-dictionary",
              "number": 720,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-word-in-dictionary/"
            },
            {
              "name": "Map Sum Pairs",
              "slug": "map-sum-pairs",
              "number": 677,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/map-sum-pairs/"
            },
            {
              "name": "Maximum XOR of Two Numbers in an Array",
              "slug": "maximum-xor-of-two-numbers-in-an-array",
              "number": 421,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/"
            },
            {
              "name": "Word Search II",
              "slug": "word-search-ii",
              "number": 212,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/word-search-ii/"
            }
          ]
        },
        {
          "id": "week_20_heaps",
          "name": "Week 20: Heaps (RTOS Schedulers)",
          "estimatedHours": 22.5,
          "description": "Priority Queues. Semiconductor context: RTOS Task Scheduler (Earliest Deadline First). Timer Wheel management for software timers.",
          "learningTip": [
            "**Heap Property:** Min-Heap (Parent <= Child) or Max-Heap (Parent >= Child).",
            "**Implicit Tree:** Stored in an array. Children of `i` are `2i+1`, `2i+2`. No pointers needed!",
            "**O(1) Access:** `peek()` is O(1). `push()` and `pop()` are O(log N).",
            "**Project:** Implement a 'cooperative scheduler' that runs the task with the earliest deadline."
          ],
          "mustNotMiss": [
            "**Indexing (0-based):** `left = 2*i + 1`, `right = 2*i + 2`, `parent = (i-1)/2`.",
            "**Heapify Up (Push):** Add to end, swap with parent until restored.",
            "**Heapify Down (Pop):** Swap root with last, remove last, swap new root with smallest child until restored.",
            "**Make Heap:** Build from bottom-up in O(N).",
            "**Memory:** Heaps are cache-friendly (contiguous array), unlike linked-node trees."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Priority Queue for interrupts.",
              "answer": "**Max Heap.** Higher priority number = closer to root. `pop()` returns the interrupt to handle next."
            },
            {
              "question": "Find the Kth largest element in a stream.",
              "answer": "**Min Heap of size K.** Keep top K elements. Root is the Kth largest. If new element > root, replace root and heapify."
            },
            {
              "question": "Heapsort vs Mergesort?",
              "answer": "**Heapsort** is O(1) space (in-place) but unstable and poor cache locality compared to Mergesort. **Mergesort** is stable but O(N) space."
            }
          ],
          "resources": [
            "https://www.freertos.org/Implementation/a00010.html - FreeRTOS Task Scheduling (Linked Lists, but concepts apply)",
            "https://leetcode.com/problems/design-twitter/solution/ - Merging K sorted feeds (Heap application)"
          ],
          "practiceQuestions": [
            {
              "name": "Last Stone Weight",
              "slug": "last-stone-weight",
              "number": 1046,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/last-stone-weight/"
            },
            {
              "name": "Kth Largest Element in an Array",
              "slug": "kth-largest-element-in-an-array",
              "number": 215,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
            },
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "number": 347,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            },
            {
              "name": "K Closest Points to Origin",
              "slug": "k-closest-points-to-origin",
              "number": 973,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/k-closest-points-to-origin/"
            },
            {
              "name": "Task Scheduler",
              "slug": "task-scheduler",
              "number": 621,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/task-scheduler/"
            },
            {
              "name": "Find Median from Data Stream",
              "slug": "find-median-from-data-stream",
              "number": 295,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/find-median-from-data-stream/"
            },
            {
              "name": "Merge k Sorted Lists",
              "slug": "merge-k-sorted-lists",
              "number": 23,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/merge-k-sorted-lists/"
            },
            {
              "name": "IPO",
              "slug": "ipo",
              "number": 502,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/ipo/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_6_graphs_dp_final",
      "name": "Graphs, DP & The Final Exam",
      "tier": 3,
      "estimatedHours": 129.5,
      "topics": [
        {
          "id": "week_21_graphs_bfs_dfs",
          "name": "Week 21: Graph BFS/DFS (Garbage Collection)",
          "estimatedHours": 26,
          "description": "Nodes and Edges. Semiconductor context: Garbage Collection (Mark-and-Sweep) using DFS. Mesh Network Broadcasting using BFS.",
          "learningTip": [
            "**Adjacency List:** `vector<vector<int>> adj;` Best for sparse graphs (most embedded networks).",
            "**BFS:** Shortest path in unweighted graph. Use a Queue. 'Broadcasting' a message.",
            "**DFS:** Exhaustive connection check. Use Recursion/Stack. 'Marking' live objects.",
            "**Project:** Simulate a 'Mark-and-Sweep' GC. Start from 'root' pointers, DFS to mark reachable blocks."
          ],
          "mustNotMiss": [
            "**Visited Array:** `bool visited[N];` Crucial to avoid infinite loops in cycles.",
            "**Implicit Graphs:** Matrix Grid. `dx[]={0,0,1,-1}; dy[]={1,-1,0,0};`",
            "**Connected Components:** Loop 0..N, if !visited[i] -> DFS(i), count++.",
            "**Flood Fill:** Typical BFS recursion in image processing."
          ],
          "interviewQuestions": [
            {
              "question": "Implement 'Mark and Sweep' GC phase.",
              "answer": "**DFS/BFS.** Start from root set (stack/globals). Mark every reachable object 'alive'. Unmarked are garbage."
            },
            {
              "question": "Find shortest path in a mesh network.",
              "answer": "**BFS.** Flood network from source. First time packet reaches dest = shortest path (hops)."
            }
          ],
          "resources": [
            "https://spin.atomicobject.com/2014/09/03/mark-and-sweep-gc-go/ - Visualizing Mark and Sweep",
            "https://leetcode.com/problems/number-of-islands/solution/ - Standard Flood Fill"
          ],
          "practiceQuestions": [
            {
              "name": "Number of Islands",
              "slug": "number-of-islands",
              "number": 200,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-islands/"
            },
            {
              "name": "01 Matrix",
              "slug": "01-matrix",
              "number": 542,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/01-matrix/"
            },
            {
              "name": "Clone Graph",
              "slug": "clone-graph",
              "number": 133,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/clone-graph/"
            },
            {
              "name": "Keys and Rooms",
              "slug": "keys-and-rooms",
              "number": 841,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/keys-and-rooms/"
            },
            {
              "name": "Rotting Oranges",
              "slug": "rotting-oranges",
              "number": 994,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rotting-oranges/"
            },
            {
              "name": "Word Ladder",
              "slug": "word-ladder",
              "number": 127,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/word-ladder/"
            }
          ]
        },
        {
          "id": "week_22_graph_topo",
          "name": "Week 22: Topological Sort (Build Systems)",
          "estimatedHours": 24,
          "description": "Ordering dependencies. Semiconductor context: Build Systems (Make/CMake) - determining compilation order. Deadlock detection in resource graphs.",
          "learningTip": [
            "**DAG:** Directed Acyclic Graph. Topo sort only exists for DAGs.",
            "**Kahn's Algorithm (BFS):** Count in-degrees. Queue nodes with 0 in-degree. Remove and decrement neighbors.",
            "**DFS Approach:** Post-order traversal reversed.",
            "**Cycle Detection:** If Topo Sort doesn't include all nodes, there is a cycle (Deadlock/Circular Dependency)."
          ],
          "mustNotMiss": [
            "**State Array:** 0=Unvisited, 1=Visiting, 2=Visited. If DFS sees 1, Cycle!",
            "**Project:** Write a simplified 'make' utility that orders 10 files based on `#include` dependencies."
          ],
          "interviewQuestions": [
            {
              "question": "Detect task deadlock in a scheduler.",
              "answer": "**Cycle Detection.** Build 'waits-for' graph. DFS. Back edge to 'Visiting' node = Deadlock."
            },
            {
              "question": "Order compilation of C files.",
              "answer": "**Topological Sort.** Files are nodes. Includes are edges. Kahn's Algo."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/course-schedule-ii/solution/ - Standard Topo Sort",
            "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/ - Cycle Detection"
          ],
          "practiceQuestions": [
            {
              "name": "Course Schedule",
              "slug": "course-schedule",
              "number": 207,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule/"
            },
            {
              "name": "Course Schedule II",
              "slug": "course-schedule-ii",
              "number": 210,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/course-schedule-ii/"
            },
            {
              "name": "Find Eventual Safe States",
              "slug": "find-eventual-safe-states",
              "number": 802,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/find-eventual-safe-states/"
            },
            {
              "name": "Alien Dictionary",
              "slug": "alien-dictionary",
              "number": 269,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/alien-dictionary/"
            }
          ]
        },
        {
          "id": "week_23_union_find",
          "name": "Week 23: Union Find (Clustering)",
          "estimatedHours": 22,
          "description": "Start with N disjoint sets, merge them. Semiconductor context: Network Clustering - grouping sensor nodes. Image Processing - Connected Component Labeling.",
          "learningTip": [
            "**Disjoint Set Union (DSU):** `parent[]` array. `find(x)` returns representative.",
            "**Path Compression:** `parent[x] = find(parent[x])`. Flattens tree. Essential for O(1) amortized.",
            "**Union by Rank:** Attach small tree to big tree.",
            "**Kruskal's MST:** Use DSU to build Minimum Spanning Tree (Network Cabling)."
          ],
          "mustNotMiss": [
            "**Find:** `if(parent[x] == x) return x; return parent[x] = find(parent[x]);`",
            "**Union:** `rootX = find(x); rootY = find(y); if(rootX != rootY) parent[rootX] = rootY;`",
            "**Time:** Inverse Ackermann function α(N) ≈ O(1). Theoretically fastest graph algo.",
            "**Grid to Graph:** 2D Grid cells can be nodes. Union adjacent '1's."
          ],
          "interviewQuestions": [
            {
              "question": "Find number of connected components in a network.",
              "answer": "**Union Find.** Initialize N components. For each valid link, Union. Answer = `initial_count - successful_unions`."
            },
            {
              "question": "Minimum cable to connect all sensors.",
              "answer": "**Kruskal's Algorithm.** Sort edges by cost. Iterate and Union if endpoints not already connected."
            }
          ],
          "resources": [
            "https://cp-algorithms.com/data_structures/disjoint_set_union.html - DSU Deep Dive",
            "https://leetcode.com/problems/number-of-provinces/solution/ - Basic Union Find"
          ],
          "practiceQuestions": [
            {
              "name": "Number of Provinces",
              "slug": "number-of-provinces",
              "number": 547,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/number-of-provinces/"
            },
            {
              "name": "Redundant Connection",
              "slug": "redundant-connection",
              "number": 684,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/redundant-connection/"
            },
            {
              "name": "Accounts Merge",
              "slug": "accounts-merge",
              "number": 721,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/accounts-merge/"
            },
            {
              "name": "Min Cost to Connect All Points",
              "slug": "min-cost-to-connect-all-points",
              "number": 1584,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/"
            },
            {
              "name": "Longest Consecutive Sequence",
              "slug": "longest-consecutive-sequence",
              "number": 128,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-consecutive-sequence/"
            }
          ]
        },
        {
          "id": "week_24_dp_resource",
          "name": "Week 24: DP Resource Optimization",
          "estimatedHours": 29.5,
          "description": "Solving sub-problems once. Semiconductor context: 0/1 Knapsack for Memory Allocation (fitting tasks into limited RAM). Bitmask DP for Peripheral State Management.",
          "learningTip": [
            "**DP = Recursion + Memoization:** Top-down is easier to write. Bottom-up saves stack space.",
            "**Knapsack Pattern:** `dp[w] = max(dp[w], dp[w-weight] + value)`. Essential for resource constraint problems.",
            "**Bitmask DP:** Use an integer to represent a set of visited nodes/states (up to 32/64).",
            "**Project:** Implement a memory allocator optimizer that fits the most high-priority checks into 16KB of SRAM."
          ],
          "mustNotMiss": [
            "**Memoization Table:** Initialize with -1. `if(memo[state] != -1) return memo[state];`",
            "**State Reduction:** If `dp[i]` only needs `dp[i-1]`, use two variables or one array. Modulo `%` for rolling arrays.",
            "**Bit Manipulation:** `(mask >> i) & 1` check bit. `mask | (1 << i)` set bit.",
            "**Complexity:** O(N * Capacity) for Knapsack is pseudo-polynomial. Beware of large capacities."
          ],
          "interviewQuestions": [
            {
              "question": "Maximize value of tasks fitting in fixed time/RAM.",
              "answer": "**0/1 Knapsack.** `dp[capacity] = max(val + dp[capacity-cost], dp[capacity])`."
            },
            {
              "question": "Count ways to climb stairs with 1 or 2 steps.",
              "answer": "**Fibonacci.** `dp[i] = dp[i-1] + dp[i-2]`. Base cases `dp[1]=1`, `dp[2]=2`."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/partition-equal-subset-sum/solution/ - Knapsack Application",
            "https://cp-algorithms.com/dynamic_programming/profile-dynamics.html - DP on Broken Profiles (Advanced)"
          ],
          "practiceQuestions": [
            {
              "name": "Climbing Stairs",
              "slug": "climbing-stairs",
              "number": 70,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/climbing-stairs/"
            },
            {
              "name": "Maximum Subarray",
              "slug": "maximum-subarray",
              "number": 53,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/maximum-subarray/"
            },
            {
              "name": "Best Time to Buy and Sell Stock",
              "slug": "best-time-to-buy-and-sell-stock",
              "number": 121,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
            },
            {
              "name": "House Robber",
              "slug": "house-robber",
              "number": 198,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/house-robber/"
            },
            {
              "name": "Coin Change",
              "slug": "coin-change",
              "number": 322,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/coin-change/"
            },
            {
              "name": "Partition Equal Subset Sum",
              "slug": "partition-equal-subset-sum",
              "number": 416,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/partition-equal-subset-sum/"
            },
            {
              "name": "Word Break",
              "slug": "word-break",
              "number": 139,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/word-break/"
            },
            {
              "name": "Decode Ways",
              "slug": "decode-ways",
              "number": 91,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/decode-ways/"
            }
          ]
        },
        {
          "id": "week_25_dp_sequence",
          "name": "Week 25: DP Sequence Alignment (Text & Bio)",
          "estimatedHours": 28,
          "description": "String Algorithms. Semiconductor context: Text Diffing (git diff), DNA Sequencing (Bio-Chips), Error Correction Codes (ECC distance).",
          "learningTip": [
            "**LCS (Longest Common Subsequence):** Foundational for diff tools. `dp[i][j] = (c1==c2) ? 1+dp[i-1][j-1] : max(...)`.",
            "**Edit Distance (Levenshtein):** Min ops to convert A to B. Used in spell checkers and autocorrect.",
            "**Space Optimization:** These usually require O(N*M) space. Can be optimized to O(min(N,M)) if only length is needed.",
            "**Project:** Build a 'Tiny Diff' tool that takes two strings and outputs the edit script."
          ],
          "mustNotMiss": [
            "**2D Table:** Row = String A, Col = String B. Cell `dp[i][j]` = answer for prefixes `A[0..i]` and `B[0..j]`.",
            "**Traceback:** To reconstruct the *actual* solution (not just cost), store 'from_left', 'from_top', 'match' in a separate table.",
            "**Hirschberg's Algo:** O(N) space for reconstructing LCS is advanced but worth knowing exists.",
            "**Palindromes:** Longest Palindromic Subseq is LCS(s, reverse(s))."
          ],
          "interviewQuestions": [
            {
              "question": "How does `git diff` work?",
              "answer": "**Longest Common Subsequence.** Lines are 'characters'. Find LCS, anything not in LCS is an insertion/deletion."
            },
            {
              "question": "Fuzzy matching search.",
              "answer": "**Edit Distance.** Find words in dictionary with Edit Distance < K from query."
            }
          ],
          "resources": [
            "https://leetcode.com/problems/edit-distance/solution/ - Classical Edit Distance",
            "https://neerc.ifmo.ru/wiki/index.php?title=Hirschberg%27s_algorithm - Linear Space LCS"
          ],
          "practiceQuestions": [
            {
              "name": "Longest Common Subsequence",
              "slug": "longest-common-subsequence",
              "number": 1143,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-common-subsequence/"
            },
            {
              "name": "Longest Palindromic Subsequence",
              "slug": "longest-palindromic-subsequence",
              "number": 516,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/longest-palindromic-subsequence/"
            },
            {
              "name": "Minimum ASCII Delete Sum for Two Strings",
              "slug": "minimum-ascii-delete-sum-for-two-strings",
              "number": 712,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/"
            },
            {
              "name": "Uncrossed Lines",
              "slug": "uncrossed-lines",
              "number": 1035,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/uncrossed-lines/"
            },
            {
              "name": "Interleaving String",
              "slug": "interleaving-string",
              "number": 97,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/interleaving-string/"
            },
            {
              "name": "Edit Distance",
              "slug": "edit-distance",
              "number": 72,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/edit-distance/"
            },
            {
              "name": "Distinct Subsequences",
              "slug": "distinct-subsequences",
              "number": 115,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/distinct-subsequences/"
            },
            {
              "name": "Shortest Common Supersequence",
              "slug": "shortest-common-supersequence",
              "number": 1092,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/shortest-common-supersequence/"
            }
          ]
        }
      ]
    },
    {
      "id": "month_7_expert_systems",
      "name": "Expert Systems & Capstone",
      "tier": 4,
      "estimatedHours": 203,
      "topics": [
        {
          "id": "week_26_concurrency",
          "name": "Week 26: Concurrency & Real-Time Systems",
          "estimatedHours": 20,
          "description": "Low-level synchronization without an OS. Focus on Atomics, Memory Barriers, and Real-Time constraints. Semiconductor context: Multi-core synchronization and Lock-free data structures.",
          "learningTip": [
            "**Volatile != Atomic:** Volatile prevents optimization. Atomic ensures indivisibility. You usually need both.",
            "**Spinlock vs Mutex:** Spinlock = Busy Wait (burns CPU, good for short hold). Mutex = Sleep (context switch, good for long hold).",
            "**ABA Problem:** If a value changes A -> B -> A, a CAS (Compare-And-Swap) might pass incorrectly. Use Version Counters.",
            "**Memory Barriers:** `DMB` (Data Memory Barrier) forces memory order. Essential when interacting with DMA or other cores."
          ],
          "mustNotMiss": [
            "**Atomic CAS:** `bool compare_exchange_weak(expected, desired)`.",
            "**LDREX/STREX:** ARM exclusives. `LDREX` loads and tags. `STREX` fails if tag is broken.",
            "**Priority Inversion:** High priority task blocked by Low priority task holding a lock. Fix: **Priority Inheritance**.",
            "**Deadlock:** Circular dependency. Prevention: Acquire locks in efficient fixed order."
          ],
          "interviewQuestions": [
            {
              "question": "Implement a Spinlock using C11 atomics.",
              "answer": "`while(flag.test_and_set(std::memory_order_acquire));` to lock. `flag.clear(std::memory_order_release);` to unlock."
            },
            {
              "question": "What is the 'Mars Pathfinder' problem?",
              "answer": "**Priority Inversion.** A low-priority weather task held a mutex, blocking a high-priority bus task. A medium task preempted the low task, stalling the high task forever. Fixed with Priority Inheritance."
            },
            {
              "question": "Explain Memory Barriers (DMB/DSB/ISB) on ARM.",
              "answer": "**DMB:** Data Memory Barrier - ensures memory accesses finished. **DSB:** Data Synchronization Barrier - waits for specific instructions. **ISB:** Instruction Synchronization Barrier - flushes pipeline."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Traffic Light Controlled Intersection",
              "slug": "traffic-light-controlled-intersection",
              "number": 1279,
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/traffic-light-controlled-intersection/"
            },
            {
              "name": "Print FooBar Alternately",
              "slug": "print-foobar-alternately",
              "number": 1115,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/print-foobar-alternately/"
            },
            {
              "name": "Building H2O",
              "slug": "building-h2o",
              "number": 1117,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/building-h2o/"
            },
            {
              "name": "The Dining Philosophers",
              "slug": "the-dining-philosophers",
              "number": 1226,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/the-dining-philosophers/"
            }
          ],
          "resources": [
            "https://preshing.com/20120612/an-introduction-to-lock-free-programming/ - Lock Free Intro",
            "https://www.youtube.com/watch?v=tIibPzrcw6I - Mars Pathfinder Explanation"
          ]
        },
        {
          "id": "week_27_advanced_c_architecture",
          "name": "Week 27: Advanced C Architecture (Linux Kernel Style)",
          "estimatedHours": 18,
          "description": "Writing Object-Oriented C without classes. Polymorphism, Encapsulation, and Opaque Types used in Linux Kernel and large embedded codebases.",
          "learningTip": [
            "**Opaque Types:** `typedef struct Context ctx_t;` in header. Define struct in `.c` file. Forces users to use API, preventing direct member access.",
            "**V-Tables:** `struct file_ops { int (*read)(...); int (*write)(...); };`. Simulate classes/interfaces using function pointers.",
            "**Intrusive Data Structures:** `container_of(ptr, type, member)`. Don't put data in nodes; put nodes in data. Avoids `malloc` for every list element.",
            "**Error Handling (goto):** `if(fail) goto cleanup;`. The standard pattern for resource cleanup in C kernels."
          ],
          "mustNotMiss": [
            "**container_of Macro:** `#define container_of(ptr, type, member) ({ ... })`. Magic pointer arithmetic to get parent struct.",
            "**Inheritance in C:** Struct embedding. `struct Child { struct Parent p; int child_data; };`. Cast `Child*` to `Parent*` safe due to layout.",
            "**Polymorphism:** `void* private_data` pattern for drivers. Allows same driver structure to point to different hardware contexts."
          ],
          "interviewQuestions": [
            {
              "question": "How do you implement a 'class' with private members in C?",
              "answer": "**Opaque Types (Pimpl Idiom).** Declare `typedef struct Object obj_t;` in `.h`. Define `struct Object { int private; };` in `.c`. User only sees the pointer."
            },
            {
              "question": "What is `container_of` used for?",
              "answer": "**Intrusive Linked Lists.** Given a pointer to a `list_head` inside a struct, calculate the address of the containing struct using `offsetof`."
            },
            {
              "question": "Why use `goto` in system programming?",
              "answer": "**Cleanup.** In functions with multiple failure points, `goto fail;` jumping to a unified cleanup section (free memory, close fds) reduces code redundancy and bugs."
            }
          ],
          "resources": [
            "https://kernel.org/doc/html/latest/core-api/kernel-api.html - Linux Kernel API",
            "https://www.youtube.com/watch?v=PSvJ13w5h_s - Object Oriented Programming in C"
          ],
          "practiceQuestions": [
            {
              "name": "Encode and Decode TinyURL",
              "slug": "encode-and-decode-tinyurl",
              "number": 535,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/encode-and-decode-tinyurl/"
            },
            {
              "name": "Design Hit Counter",
              "slug": "design-hit-counter",
              "number": 362,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-hit-counter/"
            }
          ]
        },
        {
          "id": "week_28_capstone_kv_store",
          "name": "Week 28: Capstone Project 'Graphite' (Pure C KV Store)",
          "estimatedHours": 60,
          "description": "The Final Boss. Build a persistent Key-Value Store based on Log-Structured Merge Trees (like RocksDB) using strict C99. No Classes, No STL.",
          "learningTip": [
            "**Architecture:** Write -> WAL (Append Only) -> Memtable (SkipList) -> Flush -> SSTable (Disk).",
            "**LSM Tree:** Optimized for high write throughput. Random writes become sequential writes.",
            "**Polymorphism in C:** Use `void*` keys/values and function pointer comparators `int (*cmp)(void*, void*)`.",
            "**Manual Memory:** You must implement your own allocators or carefully `malloc/free` nodes."
          ],
          "mustNotMiss": [
            "**Memtable:** Use **Skip List** (Week 14) or Red-Black Tree. Fast in-memory insert.",
            "**SSTable:** Sorted String Table. Immutable file on disk. Sparse Index for fast seek.",
            "**Cache:** Block Cache using **LRU** (Week 14) to store uncompressed data blocks.",
            "**Manifest:** Metadata file tracking all SSTables and current 'Version'."
          ],
          "interviewQuestions": [
            {
              "question": "Why LSM Tree over B+ Tree for Write-Heavy workloads?",
              "answer": "**Sequential I/O.** LSM appends to end of file (Log). B+ Tree updates pages in place (Random I/O). Sequential is 10x-100x faster on SSD/HDD."
            },
            {
              "question": "How do you handle deletes in an append-only system?",
              "answer": "**Tombstones.** Write a special 'DELETE' marker for the key. Real deletion happens during Compaction (garbage collection)."
            },
            {
              "question": "Design the 'Get(Key)' path.",
              "answer": "1. Check Memtable. 2. Check Immutable Memtables. 3. Check Block Cache. 4. Check SSTables (Level 0 to N) using Bloom Filters first."
            }
          ],
          "resources": [
            "https://github.com/facebook/rocksdb/wiki/RocksDB-Basics - RocksDB Architecture",
            "https://dataintensive.net/ - Designing Data-Intensive Applications (The Bible)"
          ],
          "practiceQuestions": [
            {
              "name": "Design Log Storage System",
              "slug": "design-log-storage-system",
              "number": 635,
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/design-log-storage-system/"
            },
            {
              "name": "Design In-Memory File System",
              "slug": "design-in-memory-file-system",
              "number": 588,
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/design-in-memory-file-system/"
            }
          ]
        },
        {
          "id": "week_29_codecrafters_shell",
          "name": "Week 29: Capstone II — Build Your Own Shell (CodeCrafters)",
          "estimatedHours": 25,
          "description": "Build a fully functional Unix shell from scratch in C. Parse commands, spawn processes with fork/exec, implement pipes, I/O redirection, autocompletion, and history. This project teaches the OS primitives that semiconductor engineers at Nvidia/Qualcomm use daily — process management, IPC, and file descriptor manipulation.",
          "learningTip": [
            "**fork() + execvp():** Master the parent-child process model. fork() duplicates the process, execvp() replaces the child's memory with the new program. waitpid() collects the exit status.",
            "**pipe() + dup2():** These two syscalls are the backbone of IPC. pipe() creates a pair of file descriptors; dup2() redirects stdin/stdout to pipe ends. This is exactly how RTOS tasks communicate via message queues.",
            "**File descriptors are integers:** stdin=0, stdout=1, stderr=2. Redirection is just closing one FD and opening another in its place. This maps directly to hardware register I/O.",
            "**Signal handling:** SIGINT (Ctrl+C), SIGCHLD (child terminated). Use sigaction() — it's the portable, reliable way to handle signals. Signals are the userspace analog of hardware interrupts."
          ],
          "mustNotMiss": [
            "**fork/exec/wait lifecycle:** The holy trinity of process management. Every embedded Linux interview asks about this.",
            "**pipe() for IPC:** How `ls | grep foo` works — one process writes to pipe, another reads. Identical to producer-consumer in RTOS.",
            "**dup2() for redirection:** Replacing stdout with a file descriptor. This is how logging frameworks work in embedded systems.",
            "**PATH resolution:** How the shell finds executables — traversing directories, checking permissions. Tests string manipulation and filesystem APIs."
          ],
          "interviewQuestions": [
            {
              "question": "Explain the fork/exec/wait pattern in Unix process creation.",
              "answer": "**fork()** creates a child process (exact copy of parent). **exec()** replaces the child's memory image with a new program. **wait()/waitpid()** in the parent blocks until the child terminates and collects its exit status. This separation allows the parent to set up the child's environment (redirections, pipes) between fork and exec."
            },
            {
              "question": "How does a Unix pipe work internally?",
              "answer": "**pipe()** creates two file descriptors: fd[0] for reading, fd[1] for writing. Data written to fd[1] can be read from fd[0]. The kernel maintains a 64KB buffer between them. For `cmd1 | cmd2`: fork twice, connect cmd1's stdout to fd[1] and cmd2's stdin to fd[0] using dup2(). Close unused ends to avoid deadlock."
            },
            {
              "question": "What happens if you forget to close unused pipe ends?",
              "answer": "**Deadlock or hang.** The reading process waits for EOF, which only happens when ALL write ends are closed. If the parent still holds the write end open, the reader blocks forever. Always close unused pipe FDs after dup2() — this is a classic embedded systems interview gotcha."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Build Your Own Shell (CodeCrafters)",
              "slug": "codecrafters-shell",
              "difficulty": "Hard",
              "link": "https://app.codecrafters.io/courses/shell/overview"
            }
          ],
          "resources": [
            "https://app.codecrafters.io/courses/shell/overview",
            "https://man7.org/linux/man-pages/man2/fork.2.html"
          ]
        },
        {
          "id": "week_30_codecrafters_interpreter_1",
          "name": "Week 30: Capstone III — Build Your Own Interpreter Part 1: Lexer, Parser & Evaluator (CodeCrafters)",
          "estimatedHours": 30,
          "description": "Build the first half of a tree-walk interpreter in C. Implement a lexer/scanner that tokenizes source code, a recursive descent parser that builds an AST, and an expression evaluator. Heavy pointer manipulation, dynamic memory allocation, and recursive algorithms. The tokenizer mirrors UART/SPI protocol frame parsing — reading raw bytes and extracting structured data.",
          "learningTip": [
            "**Lexer = Protocol parser:** A lexer reads a raw character stream and produces tokens. This is identical to parsing UART frames — read bytes, identify start/stop markers, extract payload. Same state machine approach.",
            "**AST nodes = malloc + pointers:** Every AST node is a heap-allocated struct with pointers to children. Building an AST exercises the exact memory management skills tested at Nvidia/Qualcomm.",
            "**Recursive descent:** Each grammar rule becomes a function. `parseExpression()` calls `parseTerm()` calls `parseFactor()`. The call stack IS the parse tree. Deep recursion tests stack overflow awareness.",
            "**Error recovery:** When the parser encounters invalid input, it must recover gracefully (synchronize to the next statement). This mirrors error handling in communication protocols — skip corrupted frames, resync on the next valid header."
          ],
          "mustNotMiss": [
            "**Token struct design:** Define a Token struct with type (enum), lexeme (char*), literal value (union), and line number. This tests struct/union/enum — core C interview topics.",
            "**Dynamic array for tokens:** Grow the token list with realloc(). Track size vs capacity. This is the same pattern as circular buffers in embedded systems.",
            "**Visitor pattern for AST:** Use function pointers to dispatch on node type. This is the C equivalent of virtual methods — exactly how hardware abstraction layers (HAL) work.",
            "**Memory ownership:** Who frees the AST nodes? Track ownership carefully to prevent leaks. Use valgrind to verify zero leaks."
          ],
          "interviewQuestions": [
            {
              "question": "How would you design a tokenizer for a simple language in C?",
              "answer": "**State machine approach:** Maintain a current position and a start position in the source string. Switch on the current character: single chars → emit token directly. Multi-char operators (==, !=) → look ahead one char. Strings → advance until closing quote. Numbers → advance while isdigit(). Identifiers → advance while isalnum(). Store tokens in a dynamically-grown array (realloc pattern)."
            },
            {
              "question": "What is a recursive descent parser and why is it popular?",
              "answer": "**Each grammar rule = one function.** The parser has functions like `expression()`, `term()`, `factor()`, `primary()`. Each consumes tokens and builds AST nodes. It's popular because: (1) simple to implement, (2) easy to debug (stack trace = parse tree), (3) produces good error messages, (4) no external tools needed (unlike yacc/bison)."
            },
            {
              "question": "How do you handle operator precedence in a parser?",
              "answer": "**Precedence climbing:** Lower-precedence rules call higher-precedence rules. `expression()` handles `+`/`-` and calls `term()`. `term()` handles `*`/`/` and calls `unary()`. `unary()` handles `-`/`!` and calls `primary()`. The call depth enforces precedence — deeper = higher precedence = binds tighter."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Build Your Own Interpreter (CodeCrafters)",
              "slug": "codecrafters-interpreter",
              "difficulty": "Hard",
              "link": "https://app.codecrafters.io/courses/interpreter/overview"
            }
          ],
          "resources": [
            "https://app.codecrafters.io/courses/interpreter/overview",
            "https://craftinginterpreters.com/"
          ]
        },
        {
          "id": "week_31_codecrafters_interpreter_2",
          "name": "Week 31: Capstone III (contd.) — Interpreter Part 2: State, Functions, Classes & Inheritance",
          "estimatedHours": 30,
          "description": "Complete the interpreter by implementing variables, scoping, control flow (if/else, while, for), user-defined functions with closures, and a class system with inheritance. This half exercises symbol tables (hash maps), function pointers for dispatch, scope chains (stack-based memory), and vtable-style method resolution — all directly applicable to firmware architecture.",
          "learningTip": [
            "**Environment = Hash map:** Variables live in an Environment struct — a hash map of name→value pairs. Each scope gets a new Environment pointing to its parent. This chain is identical to how firmware maintains nested configuration contexts.",
            "**Function pointers for dispatch:** When the evaluator encounters a function call, it looks up a function pointer and invokes it. This is the same dispatch mechanism used in interrupt vector tables and HAL layers.",
            "**Closures capture environment:** A closure is a function + a pointer to the environment where it was defined. In C, this means storing a struct pointer alongside the function pointer — exactly how RTOS callbacks carry context.",
            "**Vtable for classes:** Method resolution = look up method name in a function pointer table. If not found, walk up the superclass chain. This is how C++ vtables work under the hood, and how HAL drivers resolve platform-specific implementations."
          ],
          "mustNotMiss": [
            "**Scope chain traversal:** Variable lookup walks the environment chain (current → parent → grandparent). This is O(n) in scope depth. Mirrors stack frame unwinding in debuggers.",
            "**Closures in C:** A closure struct holds { function_ptr, captured_environment_ptr }. When called, restore the captured environment. Tests deep understanding of pointer lifetime and ownership.",
            "**Control flow as AST nodes:** if/while/for are just AST nodes with condition + body pointers. The evaluator checks the condition, then recursively evaluates the body. Clean separation of parsing and execution.",
            "**Garbage collection awareness:** Without GC, you must manually track when environments and AST nodes can be freed. Reference counting or arena allocation are common strategies."
          ],
          "interviewQuestions": [
            {
              "question": "How do closures work at the memory level in C?",
              "answer": "**A closure is a pair: (function_ptr, environment_ptr).** When a function is defined, we capture a pointer to the current environment (scope). When the closure is later called, we restore that environment as the enclosing scope — NOT the caller's scope. This requires the captured environment to outlive the scope where it was created, which means heap allocation and careful lifetime management."
            },
            {
              "question": "How would you implement a simple class system with inheritance in C?",
              "answer": "**Vtable pattern:** Each class has a struct with a pointer to its method table (array of function pointers) and a pointer to its superclass. Method lookup: search the class's table first, then walk up the superclass chain. Instance = struct with { class_ptr, fields_hash_map }. Constructor = allocate instance, call init method. This is exactly how C++ implements virtual dispatch."
            },
            {
              "question": "What is the difference between static and dynamic scoping?",
              "answer": "**Static (lexical) scoping:** Variable resolved based on where the function is DEFINED in the source code. Most languages use this. **Dynamic scoping:** Variable resolved based on the CALL STACK at runtime. Bash uses this. Static scoping is predictable and enables closures. Dynamic scoping is simpler to implement but harder to reason about."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Build Your Own Interpreter - Part 2 (CodeCrafters)",
              "slug": "codecrafters-interpreter-2",
              "difficulty": "Hard",
              "link": "https://app.codecrafters.io/courses/interpreter/overview"
            }
          ],
          "resources": [
            "https://app.codecrafters.io/courses/interpreter/overview",
            "https://craftinginterpreters.com/statements-and-state.html"
          ]
        },
        {
          "id": "week_32_codecrafters_http_server",
          "name": "Week 32: Capstone IV — Build Your Own HTTP Server (CodeCrafters)",
          "estimatedHours": 20,
          "description": "Build a multi-threaded HTTP/1.1 server from scratch in C using raw TCP sockets. Handle GET/POST requests, serve static files, support gzip compression, and manage persistent connections. This project teaches the networking and concurrency primitives that map directly to network stack development on SoCs — socket programming, buffer management, and interrupt-driven concurrent I/O.",
          "learningTip": [
            "**Socket API is the foundation:** socket() → bind() → listen() → accept() → recv()/send(). This is the same sequence used in every network-capable embedded device. Master each syscall's parameters and error handling.",
            "**Buffer management is critical:** HTTP requests arrive as raw bytes. You must parse headers from a byte buffer — find '\\r\\n' delimiters, extract Content-Length, read the body. This is identical to UART/SPI frame parsing with start bytes, length fields, and payloads.",
            "**Concurrency model choice:** pthread_create() for thread-per-connection (simple, but expensive) vs select()/poll()/epoll for event-driven I/O (efficient, mirrors interrupt-driven embedded systems). Know the trade-offs.",
            "**Gzip compression in C:** Use zlib's deflate() and inflate(). Understand that compression reduces bandwidth at the cost of CPU — a constant trade-off in embedded systems with limited network and compute resources."
          ],
          "mustNotMiss": [
            "**TCP is a byte stream:** Unlike UDP, TCP has no message boundaries. You must handle partial reads (recv returns fewer bytes than expected) and buffer reassembly. This is the #1 networking bug in embedded systems.",
            "**struct sockaddr_in:** IP address + port packed into a struct. Use htons() for byte order conversion — network byte order is big-endian. This tests your endianness knowledge directly.",
            "**Concurrent connections:** Use either threads (pthread) or I/O multiplexing (select/poll). For embedded systems, event-driven (select) is preferred because threads are expensive on constrained hardware.",
            "**HTTP keep-alive:** Reuse TCP connections for multiple requests. Requires careful state management — track which connection is in which state. Same pattern as managing multiple UART channels."
          ],
          "interviewQuestions": [
            {
              "question": "Walk through the TCP socket API lifecycle for a server.",
              "answer": "**1. socket()** — create a socket file descriptor (AF_INET, SOCK_STREAM). **2. bind()** — associate with an IP:port. **3. listen()** — mark as passive (accept connections). **4. accept()** — block until a client connects, return a NEW fd for that connection. **5. recv()/send()** — read/write data on the connection fd. **6. close()** — tear down. Key insight: accept() returns a new FD — the original socket keeps listening."
            },
            {
              "question": "How would you handle 10,000 concurrent connections in C?",
              "answer": "**Event-driven I/O with epoll (Linux):** One thread monitors all connections. epoll_wait() returns only the FDs that have data ready — O(1) per ready FD vs O(n) for select(). Use non-blocking sockets. This is the foundation of nginx and Node.js. In embedded systems, this maps to interrupt-driven I/O where the CPU sleeps until an interrupt fires."
            },
            {
              "question": "Why is TCP a byte stream and what problems does this cause?",
              "answer": "**TCP guarantees delivery and ordering, but NOT message boundaries.** A single send() of 1000 bytes might arrive as two recv() calls of 600 + 400 bytes. You must: (1) buffer incoming data, (2) parse for delimiters (\\r\\n in HTTP) or read Content-Length bytes, (3) handle partial messages. This is the exact same challenge as assembling UART frames from a DMA buffer."
            }
          ],
          "practiceQuestions": [
            {
              "name": "Build Your Own HTTP Server (CodeCrafters)",
              "slug": "codecrafters-http-server",
              "difficulty": "Hard",
              "link": "https://app.codecrafters.io/courses/http-server/overview"
            }
          ],
          "resources": [
            "https://app.codecrafters.io/courses/http-server/overview",
            "https://beej.us/guide/bgnet/"
          ]
        }
      ]
    }
  ]
}
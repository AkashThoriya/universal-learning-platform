{
  "id": "databases_sql_by_rahul_grover",
  "name": "Databases & SQL by Rahul Grover",
  "description": "Comprehensive Databases and SQL course covering DBMS fundamentals, SQL commands, joins, subqueries, indexing, transactions, and schema design. Includes advanced analytics with window functions, CTEs, and database programmability - critical for backend engineering and interview preparation.",
  "category": "Computer Science",
  "totalEstimatedHours": 61.5,
  "prerequisites": [
    "Basic computer literacy",
    "Understanding of rows and columns (Excel experience helps)",
    "No prior coding experience required, though helpful"
  ],
  "resources": [
    "https://datalemur.com/sql-tutorial",
    "https://www.postgresql.org/docs/current/tutorial.html",
    "https://sqlbolt.com/",
    "https://mode.com/sql-tutorial/"
  ],
  "stages": [
    {
      "id": "foundation",
      "name": "SQL Foundation Assessment",
      "totalMarks": 100,
      "duration": 180,
      "durationUnit": "minutes",
      "sections": [
        {
          "id": "sql_basics",
          "name": "SQL Basics & CRUD",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "joins_subqueries",
          "name": "Joins & Subqueries",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "transactions_indexing",
          "name": "Transactions & Indexing",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "schema_design",
          "name": "Schema Design & Normalization",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "advanced",
      "name": "Advanced SQL Assessment",
      "totalMarks": 150,
      "duration": 270,
      "durationUnit": "minutes",
      "sections": [
        {
          "id": "window_functions",
          "name": "Window Functions & Analytics",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "ctes_optimization",
          "name": "CTEs & Query Optimization",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "programmability",
          "name": "Stored Procedures & Triggers",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    }
  ],
  "defaultSyllabus": [
    {
      "id": "introduction_dbms",
      "name": "Introduction to DBMS",
      "tier": 1,
      "estimatedHours": 3.5,
      "topics": [
        {
          "id": "intro_to_dbms",
          "name": "SQL 1: Intro to DBMS",
          "estimatedHours": 2,
          "description": "Understand the fundamentals of Database Management Systems - what they are, why we need them over simple file storage, and how relational databases organize data into tables with relationships. This lecture covers the foundation that everything else builds upon.",
          "practiceQuestions": [
            {
              "name": "Combine Two Tables",
              "slug": "combine-two-tables",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/combine-two-tables/"
            }
          ],
          "learningTip": [
            "**Concept Check:** Databases are not just 'storage'. They are 'engines' that guarantee your data is correct (ACID), accessible, and secure.",
            "**SQL Mental Model:** SQL is NOT procedural like Python/Java. You don't tell the DB *how* to loop. You describe the *result set* you want, and the Query Optimizer figures out the most efficient path.",
            "**The 'R' in RDBMS:** It stands for 'Relational'. The absolute power comes from *linking* simple tables (Users, Orders) to answer complex questions (Who bought what?). Study 'Foreign Keys' deeply.",
            "**Normalization vs Performance:** In interviews, knowing *how* to normalize is Level 1. Knowing *when to de-normalize* for performance is Level 2 (Senior Engineer thinking)."
          ],
          "mustNotMiss": [
            "**DBMS vs RDBMS:** The key difference is *relationships*. RDBMS enforces referential integrity (Foreign Keys). If you delete a User, RDBMS stops you from leaving orphaned Orders.",
            "**The 4 Languages of SQL:** \n1. **DDL** (Structure): CREATE, ALTER, DROP, TRUNCATE \n2. **DML** (Data): INSERT, UPDATE, DELETE, MERGE \n3. **DQL** (Query): SELECT \n4. **DCL/TCL** (Control): GRANT, REVOKE, COMMIT, ROLLBACK",
            "**TRUNCATE vs DELETE (Interview Favorite):** \n*   DELETE is a DML (slow, logs every row, triggers fire). \n*   TRUNCATE is a DDL (instant, resets auto-increment, no triggers). Never use TRUNCATE if you can roll back!",
            "**ACID Properties:** A (Atomicity - All/None), C (Consistency - Rules), I (Isolation - No Peeking), D (Durability - Saved forever). You WILL be asked to explain this with a 'Bank Transfer' example."
          ],
          "interviewQuestions": [
            {
              "question": "What is Normalization? Explain 1NF, 2NF, 3NF, and BCNF.",
              "answer": "**Normalization** reduces redundancy and dependency. \n*   **1NF:** Atomic values (no list/sets in columns), unique rows. \n*   **2NF:** 1NF + No Partial Dependency (non-key col depends on WHOLE composite key). \n*   **3NF:** 2NF + No Transitive Dependency (non-key col depends ONLY on PK, not other non-key cols). \n*   **BCNF:** 3NF + Every determinant is a Candidate Key."
            },
            {
              "question": "What is Denormalization and when should you use it?",
              "answer": "**Denormalization** adds redundancy to speed up reads (avoids costly joins). \n*   **Use when:** Read-heavy analytics (Star Schema), reporting dashboards where JOIN performance is the bottleneck. \n*   **Trade-off:** Faster reads, but slower writes (update logic complexity) and risk of data inconsistency."
            },
            {
              "question": "What are the ACID properties?",
              "answer": "**Atomicity:** All or nothing. \n**Consistency:** DB stays valid (constraints). \n**Isolation:** Transactions don't spy on each other. \n**Durability:** Saved changes survive crash."
            },
            {
              "question": "Difference between DELETE, TRUNCATE, and DROP?",
              "answer": "**DELETE:** DML, row-by-row, slow, logs, triggers fire. \n**TRUNCATE:** DDL, massive fast delete, resets identity, no triggers. \n**DROP:** DDL, deletes table structure entirely."
            },
            {
              "question": "What is the difference between DBMS and RDBMS?",
              "answer": "**DBMS:** Stores data as files/xml (e.g., File System). No relationships enforced. \n**RDBMS:** Tables + Relationships (Foreign Keys). ACID compliant. Supports distributed transactions and concurrency."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/intro-to-sql",
            "https://datalemur.com/sql-tutorial/sql-interview-guide"
          ]
        },
        {
          "id": "sql_basics_practice",
          "name": "SQL 1.5: Practice Session - Basics",
          "estimatedHours": 1.5,
          "description": "Reinforce your understanding of SQL basics with these targeted practice questions from DataLemur. Focus on SELECT, WHERE clauses, and handling NULL values.",
          "practiceQuestions": [
            {
              "name": "Data Science Skills",
              "slug": "data-science-skills",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/data-science-skills"
            },
            {
              "name": "Facebook App Completeness",
              "slug": "facebook-web-log",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/facebook-web-log"
            },
            {
              "name": "Review Stars",
              "slug": "sql-select-where",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/sql-select-where"
            }
          ],
          "learningTip": [
            "Use `IS NULL` to check for missing values, never `= NULL`.",
            "The `IN` operator is a cleaner way to specify multiple OR conditions for the same column.",
            "Remember that `WHERE` filters rows before any grouping or aggregation happens."
          ],
          "mustNotMiss": [
            "Checking for NULL: `WHERE column IS NULL`",
            "Pattern matching: `WHERE column LIKE 'A%'`",
            "Multiple values: `WHERE column IN (1, 2, 3)`"
          ],
          "interviewQuestions": []
        }
      ]
    },
    {
      "id": "keys_constraints",
      "name": "Keys & Constraints",
      "tier": 1,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "lab_session_keys",
          "name": "SQL 2: Lab Session on Keys",
          "estimatedHours": 2,
          "description": "Hands-on practice with database keys - the building blocks that ensure data integrity and establish relationships between tables. Master Primary Keys, Foreign Keys, Unique Keys, Candidate Keys, and Composite Keys through practical exercises.",
          "practiceQuestions": [
            {
              "name": "Delete Duplicate Emails",
              "slug": "delete-duplicate-emails",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/delete-duplicate-emails/"
            },
            {
              "name": "Duplicate Emails",
              "slug": "duplicate-emails",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/duplicate-emails/"
            },
            {
              "name": "Primary Department for Each Employee",
              "slug": "primary-department-for-each-employee",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/primary-department-for-each-employee/"
            },
            {
              "name": "Recyclable and Low Fat Products",
              "slug": "recyclable-and-low-fat-products",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/recyclable-and-low-fat-products/"
            },
            {
              "name": "Invalid Tweets",
              "slug": "invalid-tweets",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/invalid-tweets/"
            }
          ],
          "learningTip": [
            "**Keys are your Data Guards:** Without keys, your database is just a messy spreadsheet. Keys enforce *identity* (PK) and *validity* (FK).",
            "**The NULL Trap:** A Unique Key can have NULLs, but a Primary Key cannot. Why? Because you can't identify a row with 'unknown' ID.",
            "**Composite Keys:** Don't fear them. They just mean 'It takes TWO pieces of info to be unique'. Example: You can be in Class A, and Class B. But you can only be in Class A *once*. So (Student + Class) must be unique.",
            "**Surrogate vs Natural Keys:** A 'Natural Key' is real data (Email, SSN). A 'Surrogate Key' is a fake ID (Serial 1, 2, 3). In production, we almost ALWAYS use Surrogate Keys (IDs) for performance and stability."
          ],
          "mustNotMiss": [
            "**Primary Key (PK):** The DNA of a row. \n*   Unique + Not Null. \n*   Only 1 per table. \n*   Most DBs automatically create a 'Clustered Index' on it (makes lookups instant).",
            "**Unique Key (UK):** The 'Username' rule. \n*   Values must be unique. \n*   Can have NULLs (Standard SQL says multiple NULLs allowed, Oracle says one). \n*   Table can have MANY unique keys.",
            "**Foreign Key (FK):** The 'Relationship Link'. pointing to a PK in another table. It prevents you from adding an Order for a non-existent Customer.",
            "**Composite Key:** A PK made of multiple columns. Standard pattern for 'Join Tables' in Many-to-Many relationships.",
            "**Candidate Key:** any set of columns that *could* have been selected as the Primary Key."
          ],
          "interviewQuestions": [
            {
              "question": "Primary Key vs Unique Key vs Candidate Key?",
              "answer": "**PK:** Unique ID, NOT NULL, Cluster Index (usually), Only 1 per table. \n**UK:** Unique values, Allows NULL (1 in SQL Server, many in Postgres), Non-Clustered (usually). \n**Candidate:** Any unique key that *could* be PK."
            },
            {
              "question": "What is a Composite Primary Key?",
              "answer": "A PK made of 2+ columns. Used in **Many-to-Many** mapping tables (e.g., `Enrollment(StudentID, CourseID)`). Both together must be unique."
            },
            {
              "question": "Explain Foreign Key constraints: CASCADE, SET NULL, RESTRICT.",
              "answer": "**CASCADE:** Delete parent -> Delete child automatically. \n**SET NULL:** Delete parent -> Set child FK to NULL (orphaned but kept). \n**RESTRICT:** Delete parent -> Fail if children exist (default safety)."
            },
            {
              "question": "Can a Primary Key contain NULL?",
              "answer": "No. By definition, a PK must be unique and known (NOT NULL) to identify the row."
            },
            {
              "question": "Can a table have multiple Unique Keys?",
              "answer": "Yes. E.g., UserID is PK, but Email and PhoneNumber can both be Unique Keys."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-create-table",
            "https://datalemur.com/sql-tutorial/sql-foreign-key"
          ]
        }
      ]
    },
    {
      "id": "crud_operations",
      "name": "CRUD Operations",
      "tier": 1,
      "estimatedHours": 7,
      "topics": [
        {
          "id": "crud_part_1",
          "name": "SQL 3: CRUD - Part 1",
          "estimatedHours": 2,
          "description": "Master the four fundamental database operations: Create (INSERT), Read (SELECT), Update (UPDATE), Delete (DELETE). Learn SELECT with DISTINCT, WHERE clauses with various operators, pattern matching with LIKE, and understand why SQL query execution order is different from how you write it.",
          "practiceQuestions": [
            {
              "name": "Big Countries",
              "slug": "big-countries",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/big-countries/"
            },
            {
              "name": "Find Customer Referee",
              "slug": "find-customer-referee",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-customer-referee/"
            },
            {
              "name": "Article Views I",
              "slug": "article-views-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/article-views-i/"
            },
            {
              "name": "Not Boring Movies",
              "slug": "not-boring-movies",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/not-boring-movies/"
            }
          ],
          "learningTip": [
            "**Visualizing SQL Execution:** SQL looks like English, but it executes like a pipeline. You write `SELECT` first, but the DB executes `FROM` and `WHERE` first to find the data. That's why you can't use an Alias in the WHERE clause!",
            "**Pattern Matching Power:** `LIKE` is great, but slow on large text. `LIKE 'A%'` can use an index (fast), but `LIKE '%A'` cannot (slow table scan).",
            "**The NULL Trap (Part 2):** `NULL != NULL` is true. `NULL = NULL` is false. Everything with NULL is UNKNOWN. Always use `IS NULL`.",
            "**DISTINCT vs GROUP BY:** `SELECT DISTINCT col` and `SELECT col ... GROUP BY col` might look the same, but `GROUP BY` allows you to calculate aggregates (Count, Sum)."
          ],
          "mustNotMiss": [
            "**Order of Execution (Memorize This):** FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT.",
            "**The '%' Wildcard:** Matches 0, 1, or Many characters. `'Data%'` matches 'Data', 'Database', 'Data'.",
            "**The '_' Wildcard:** Matches EXACTLY one character. `'_at'` matches 'Cat', 'Bat', 'Rat' but NOT 'Brat'.",
            "**IS NULL:** The ONLY correct way to find missing data. `WHERE email = NULL` will return zero rows, forever and always.",
            "**Aliases:** You CAN use column aliases in `ORDER BY` and `GROUP BY`, but NOT in `WHERE` (see Order of Execution Point 1)."
          ],
          "interviewQuestions": [
            {
              "question": "Write a query to select unique records from a table using DISTINCT.",
              "answer": "`SELECT DISTINCT column1, column2 FROM TableName;` \n\nNote: DISTINCT applies to the combination of ALL selected columns. It removes rows where the values of *all* listed columns are identical."
            },
            {
              "question": "How does the LIKE operator work with wildcards (%) and (_)?",
              "answer": "`LIKE` performs pattern matching. \n\n1. **% (Percent):** Matches zero, one, or multiple characters. Example: `'A%'` matches 'A', 'Apple', 'Ant'. \n2. **_ (Underscore):** Matches exactly ONE character. Example: `'_a'` matches 'ta', 'pa' but NOT 'tea'."
            },
            {
              "question": "What is the order of execution for an SQL query?",
              "answer": "Logical processing order: \n1. **FROM / JOIN** (Identify data source) \n2. **WHERE** (Filter rows) \n3. **GROUP BY** (Aggregate) \n4. **HAVING** (Filter groups) \n5. **SELECT** (Choose columns) \n6. **DISTINCT** (Remove duplicates) \n7. **ORDER BY** (Sort) \n8. **LIMIT / OFFSET** (Pagination)"
            },
            {
              "question": "Why can't you use a column alias in the WHERE clause?",
              "answer": "Because `WHERE` runs **before** `SELECT` (where the alias is created). The database doesn't know the alias exists yet. \n\nYou *can* use aliases in `GROUP BY`, `ORDER BY`, or `HAVING` (in MySQL) because they run after aliases are defined."
            },
            {
              "question": "What is the difference between WHERE column = NULL and WHERE column IS NULL?",
              "answer": "`WHERE column = NULL` always returns FALSE/Unknown processing because NULL represents an 'unknown' value, and 'unknown' cannot be equal to 'unknown'. \n\n`WHERE column IS NULL` is the only correct way to check for missing values."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-select",
            "https://datalemur.com/sql-tutorial/sql-where",
            "https://datalemur.com/sql-tutorial/sql-order-by",
            "https://datalemur.com/sql-tutorial/sql-like",
            "https://datalemur.com/sql-tutorial/sql-in"
          ]
        },
        {
          "id": "string_date_functions",
          "name": "SQL 3.5: String & Date Functions",
          "estimatedHours": 1.5,
          "description": "Master essential utilities for data manipulation. Learn to clean and format text with string functions, and perform temporal analysis with date functions.",
          "practiceQuestions": [
            {
              "name": "Fix Names in a Table",
              "slug": "fix-names-in-a-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fix-names-in-a-table/"
            },
            {
              "name": "Group Sold Products By The Date",
              "slug": "group-sold-products-by-the-date",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/group-sold-products-by-the-date/"
            }
          ],
          "learningTip": [
            "**Sanitization:** Data is rarely clean. Your first step in any analysis is often `TRIM()`, `UPPER()`, and `COALESCE()`.",
            "**Date Arithmetic:** Never do `date_col + 7`. Always use `DATE_ADD(date_col, INTERVAL 7 DAY)`. Why? Leap years, end of months, and differing database standards.",
            "**Type Casting:** Strings looking like numbers ('123') will fail math operations in strict DBs. Explicitly `CAST(col AS INT)` to be safe.",
            "**Regex:** When `LIKE` isn't enough (e.g., 'Find valid email formats'), use `REGEXP` or `SIMILAR TO`."
          ],
          "mustNotMiss": [
            "**String:** `CONCAT`, `SUBSTRING`, `LENGTH`, `UPPER/LOWER`, `TRIM`, `REPLACE`.",
            "**Date:** `NOW`/`GETDATE`, `DATEDIFF` (Time between dates), `DATE_ADD` (Project future dates), `EXTRACT`/`DATE_PART` (Get Year/Month).",
            "**Casting:** `CAST(val AS type)` or `CONVERT(type, val)`. Essential for joining mismatched types (e.g., String ID vs Int ID).",
            "**Formatting:** `TO_CHAR(date, 'YYYY-MM-DD')` is crucial for reporting."
          ],
          "interviewQuestions": [
            {
              "question": "How to extract the Year from a Date column?",
              "answer": "`EXTRACT(YEAR FROM date_col)` (Standard SQL) or `YEAR(date_col)` (MySQL/SQL Server)."
            },
            {
              "question": "Difference between CHAR and VARCHAR?",
              "answer": "**CHAR(n):** Fixed length. Padded with spaces. Faster for fixed size data (e.g., Country Code). \n**VARCHAR(n):** Variable length. Saves space. Slower due to length byte overhead."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-string-functions",
            "https://datalemur.com/sql-tutorial/sql-date-functions",
            "https://datalemur.com/sql-tutorial/sql-arithmetic-math-functions"
          ]
        },
        {
          "id": "lab_session_2",
          "name": "SQL 4: Lab Session 2 - Aggregations & Grouping",
          "estimatedHours": 3.5,
          "description": "Intensive hands-on practice with GROUP BY for categorizing data, aggregate functions (COUNT, SUM, AVG, MIN, MAX) for calculations, HAVING for filtering groups, and ORDER BY for sorting. These are the bread-and-butter of data analysis queries.",
          "practiceQuestions": [
            {
              "name": "Classes More Than 5 Students",
              "slug": "classes-more-than-5-students",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/classes-more-than-5-students/"
            },
            {
              "name": "Customer Placing the Largest Number of Orders",
              "slug": "customer-placing-the-largest-number-of-orders",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/"
            },
            {
              "name": "Game Play Analysis I",
              "slug": "game-play-analysis-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/game-play-analysis-i/"
            },
            {
              "name": "Daily Leads and Partners",
              "slug": "daily-leads-and-partners",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/daily-leads-and-partners/"
            },
            {
              "name": "Find Followers Count",
              "slug": "find-followers-count",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/find-followers-count/"
            },
            {
              "name": "Actors and Directors Who Cooperated At Least Three Times",
              "slug": "actors-and-directors-who-cooperated-at-least-three-times",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/"
            },
            {
              "name": "Top Travellers",
              "slug": "top-travellers",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/top-travellers/"
            },
            {
              "name": "Group Sold Products By The Date",
              "slug": "group-sold-products-by-the-date",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/group-sold-products-by-the-date/"
            },
            {
              "name": "Laptop vs. Mobile Viewership",
              "slug": "laptop-mobile-viewership",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/laptop-mobile-viewership"
            },
            {
              "name": "Histogram of Tweets",
              "slug": "sql-histogram-tweets",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/sql-histogram-tweets"
            },
            {
              "name": "Average Review Ratings",
              "slug": "sql-avg-review-ratings",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/sql-avg-review-ratings"
            }
          ],
          "learningTip": [
            "**The GROUP BY Law:** If you have `GROUP BY dept`, then in your `SELECT`, you can ONLY have `dept` or an `AGGREGATE FUNCTION(col)`. You cannot SELECT `name` because which name would you pick for the whole department?",
            "**WHERE vs HAVING:** This is the #1 SQL Interview Question. `WHERE` filters *rows* (before grouping). `HAVING` filters *groups* (after grouping). You can't say `WHERE COUNT(*) > 5`.",
            "**Counting Secrets:** `COUNT(*)` counts rows (even with NULLs). `COUNT(email)` counts only rows where email is NOT NULL. Use this difference to count missing/present values!",
            "**Aggregation Mental Model:** Imagine physically sorting all rows into piles (Buckets) based on the group column. Then applying a calculator to each pile (Sum, Avg)."
          ],
          "mustNotMiss": [
            "**GROUP BY Rule:** Columns in SELECT must be either (a) Grouping Columns or (b) Aggregated. No exceptions (in standard SQL).",
            "**HAVING Clause:** Used ONLY for filtering potentially aggregated data. `HAVING SUM(salary) > 100000` is valid. `WHERE SUM(salary) > 100000` is error.",
            "**COUNT(*) vs COUNT(col):** COUNT(*) = Row Count. COUNT(col) = Non-Null Value Count.",
            "**Multiple Grouping:** `GROUP BY City, Gender` creates a bucket for each unique combination (e.g., 'Delhi-Male', 'Delhi-Female', 'Mumbai-Male').",
            "**Optimization:** Always filter with `WHERE` first if possible, to reduce the number of rows that need to be grouped."
          ],
          "interviewQuestions": [
            {
              "question": "Write a query using GROUP BY to count employees in each department.",
              "answer": "`SELECT Department, COUNT(*) FROM Employees GROUP BY Department;`"
            },
            {
              "question": "What is the difference between WHERE and HAVING clauses?",
              "answer": "**WHERE** filters individual **rows** *before* grouping. It cannot check aggregate values (e.g., `WHERE COUNT(*) > 5` is illegal). \n\n**HAVING** filters **groups** *after* grouping. It acts on the results of aggregates (e.g., `HAVING COUNT(*) > 5` is valid)."
            },
            {
              "question": "How do you sort results by multiple columns (e.g., Department ASC, Salary DESC)?",
              "answer": "`SELECT * FROM Employees ORDER BY Department ASC, Salary DESC;` \n\nThis first sorts everything by Department A-Z. Then, *within* each department, it sorts employees by Salary High-to-Low."
            },
            {
              "question": "What is the difference between COUNT(*) and COUNT(column_name)?",
              "answer": "**COUNT(*)** counts ALL rows, including those with NULLs. \n\n**COUNT(column)** counts only rows where that specific column is NOT NULL."
            },
            {
              "question": "Can you use an aggregate function in the WHERE clause? Why or why not?",
              "answer": "**NO.** The `WHERE` clause is processed before aggregation occurs. The database hasn't calculated the SUM or COUNT yet, so it can't filter by it. You must use `HAVING`."
            },
            {
              "question": "Write a query to find the department with the highest average salary.",
              "answer": "```sql\nSELECT Department, AVG(Salary) as AvgSal \nFROM Employees \nGROUP BY Department \nORDER BY AvgSal DESC \nLIMIT 1;\n```"
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-group-by",
            "https://datalemur.com/sql-tutorial/sql-having",
            "https://datalemur.com/sql-tutorial/sql-aggregate-functions",
            "https://datalemur.com/sql-tutorial/sql-min-max",
            "https://datalemur.com/sql-tutorial/sql-avg-sum"
          ]
        }
      ]
    },
    {
      "id": "joins",
      "name": "SQL Joins",
      "tier": 2,
      "estimatedHours": 5.75,
      "topics": [
        {
          "id": "joins_fundamentals",
          "name": "SQL 5: Joins",
          "estimatedHours": 3.75,
          "description": "Master all types of SQL joins - the mechanism for combining data from multiple tables. Understand INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN, CROSS JOIN, and SELF JOIN. This is one of the most tested topics in SQL interviews.",
          "practiceQuestions": [
            {
              "name": "Employees Earning More Than Their Managers",
              "slug": "employees-earning-more-than-their-managers",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/employees-earning-more-than-their-managers/"
            },
            {
              "name": "Rising Temperature",
              "slug": "rising-temperature",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rising-temperature/"
            },
            {
              "name": "Product Sales Analysis I",
              "slug": "product-sales-analysis-i",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/product-sales-analysis-i/"
            },
            {
              "name": "Page With No Likes",
              "slug": "sql-page-with-no-likes",
              "difficulty": "Easy",
              "link": "https://datalemur.com/questions/sql-page-with-no-likes"
            },
            {
              "name": "Signup Activation Rate",
              "slug": "signup-confirmation-rate",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/signup-confirmation-rate"
            },
            {
              "name": "Cities With Completed Trades",
              "slug": "completed-trades",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/completed-trades"
            }
          ],
          "learningTip": [
            "**The 'Filter' Effect:** `INNER JOIN` is also a filter! It drops rows that don't match. If you want to keep rows even if they don't match, you MUST use `LEFT JOIN`.",
            "**Left vs Right:** Professional SQL developers almost ALWAYS use `LEFT JOIN`. `RIGHT JOIN` is confusing to read (filtering backwards). Stick to LEFT.",
            "**Visualizing Joins:** Don't just think Venn Diagrams. Think of 'appending columns'. Joins make your table *wider* (more columns), Unions make your table *taller* (more rows).",
            "**The Cartesian Explosion:** A `CROSS JOIN` between a 1000-row table and a 1000-row table creates 1 MILLION rows. Always check your ON clause!"
          ],
          "mustNotMiss": [
            "**INNER JOIN:** The 'Strict' Join. Returns only perfect matches. Use when you need data to exist in both places (e.g., Only Orders with valid Customers).",
            "**LEFT JOIN:** The 'Preserving' Join. Keeps everything from the Left table. Fills missing Right data with NULL. Use for 'Find all Customers, even those without Orders'.",
            "**FULL OUTER JOIN:** The 'greedy' join. Keeps everything from both sides. Fills gaps with NULLs. Useful for comparing two lists to find mismatches.",
            "**SELF JOIN:** Joining a table to itself. Critical for Hierarchies (Employee -> Manager) or Comparing rows within a group (Find duplicates).",
            "**ON vs WHERE:** In an INNER JOIN, they are similar. In a LEFT JOIN, `ON` filters the Right table *before* joining (preserving Left rows), while `WHERE` filters the result *after* joining (potentially removing Left rows)."
          ],
          "interviewQuestions": [
            {
              "question": "What is the difference between CROSS JOIN and NATURAL JOIN?",
              "answer": "**CROSS JOIN:** Cartesian product (A rows * B rows). No ON clause needed. \n**NATURAL JOIN:** Automatic join on columns with the *same name*. Dangerous practice (can join wrong cols)."
            },
            {
              "question": "How do you find records in Table A that are NOT in Table B?",
              "answer": "**Left Anti-Join:** \n`SELECT a.* FROM A LEFT JOIN B ON a.id = b.id WHERE b.id IS NULL` \n\n**NOT EXISTS** (Often faster): \n`SELECT * FROM A WHERE NOT EXISTS (SELECT 1 FROM B WHERE B.id = A.id)`"
            },
            {
              "question": "What are the different types of Joins?",
              "answer": "**Inner:** Match in Both. \n**Left:** All Left + Match Right (Null if missing). \n**Right:** All Right + Match Left. \n**Full:** Match in Either (Union of Left/Right). \n**Cross:** All combinations."
            },
            {
              "question": "How to handle NULLs in JOIN conditions?",
              "answer": "Standard `=` comparison fails on NULLs. \nUse `COALESCE(col, 'default')` to join NULLs as values: \n`ON COALESCE(A.code, '') = COALESCE(B.code, '')`"
            },
            {
              "question": "Write a Self-Join to find Employees earning more than their Manager.",
              "answer": "`SELECT e.name FROM Emp e JOIN Emp m ON e.mgr_id = m.id WHERE e.sal > m.sal`"
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-joins",
            "https://datalemur.com/sql-tutorial/sql-left-vs-incremental-join",
            "https://datalemur.com/sql-tutorial/sql-self-join",
            "https://datalemur.com/sql-tutorial/sql-full-outer-join"
          ]
        },
        {
          "id": "lab_session_3",
          "name": "SQL 6: Lab Session 3 - Advanced Joins Practice",
          "estimatedHours": 2,
          "description": "Intensive practice with complex join scenarios - finding records that don't have matches (orphans), identifying duplicates, combining data from 3+ tables, and solving real-world data relationship problems. Heavy practice session!",
          "practiceQuestions": [
            {
              "name": "Customers Who Never Order",
              "slug": "customers-who-never-order",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/customers-who-never-order/"
            },
            {
              "name": "Employee Bonus",
              "slug": "employee-bonus",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/employee-bonus/"
            },
            {
              "name": "Students and Examinations",
              "slug": "students-and-examinations",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/students-and-examinations/"
            },
            {
              "name": "Sales Person",
              "slug": "sales-person",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/sales-person/"
            },
            {
              "name": "Replace Employee ID With The Unique Identifier",
              "slug": "replace-employee-id-with-the-unique-identifier",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/"
            },
            {
              "name": "Managers with at Least 5 Direct Reports",
              "slug": "managers-with-at-least-5-direct-reports",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
            },
            {
              "name": "Confirmation Rate",
              "slug": "confirmation-rate",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/confirmation-rate/"
            },
            {
              "name": "Average Time of Process per Machine",
              "slug": "average-time-of-process-per-machine",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/average-time-of-process-per-machine/"
            },
            {
              "name": "Product Sales Analysis III",
              "slug": "product-sales-analysis-iii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/product-sales-analysis-iii/"
            },
            {
              "name": "Customer Who Visited but Did Not Make Any Transactions",
              "slug": "customer-who-visited-but-did-not-make-any-transactions",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/"
            }
          ],
          "learningTip": [
            "**The Anti-Join Pattern:** How do you find Customers who *never* ordered? `LEFT JOIN` + `WHERE right.id IS NULL`. This is faster and more readable than `NOT IN` subqueries in many DBs.",
            "**Handling Duplicates:** Joins can unexpectedly multiply your rows if the relationship isn't 1:1. If you join on a column that isn't unique, you get a Cartesian product for those matches. Always check row counts!",
            "**Chaining Joins:** You can chain as many joins as you want. `FROM Keys k JOIN Guitars g ON k.id = g.key_id JOIN Amps a ON g.id = a.guitar_id`. It flows linearly.",
            "**Aliasing:** Aliases are mandatory for readability. `FROM Customer c JOIN Order o` is better than typing full names every time."
          ],
          "mustNotMiss": [
            "**Finding Orphans (Anti-Join):** `SELECT * FROM A LEFT JOIN B ON A.id = B.id WHERE B.id IS NULL`. Memorize this pattern.",
            "**Complex Filtering:** You can put complex logic in the ON clause! `ON e.dept_id = d.id AND e.salary > 50000`. This filters rows *during* the join process.",
            "**Natural Join Danger:** NEVER use `NATURAL JOIN` in production. It joins on *all* columns with the same name, which breaks your code if someone adds a `status` column to both tables later.",
            "**3+ Table Joins:** The database joins two tables, takes the result, and joins it to the third. The order of INNER JOINS doesn't matter for the result, but the optimizer might reorder them for speed."
          ],
          "interviewQuestions": [
            "Find all customers who have never placed an order (using LEFT JOIN).",
            "Write a query to find duplicate email addresses in a Users table.",
            "How do you find records in table A that have no match in table B?",
            "Write a query to list products that have never been ordered.",
            "Find employees who belong to departments that have more than 5 employees.",
            "How would you optimize a query that joins 5+ tables?"
          ]
        }
      ]
    },
    {
      "id": "subqueries_views",
      "name": "Subqueries & Views",
      "tier": 2,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "subqueries_and_views",
          "name": "SQL 7: Subqueries and Views",
          "estimatedHours": 2,
          "description": "Master the art of nested queries - queries within queries that allow you to compute intermediate results and use them in your main query. Also learn Views as a way to save complex queries as virtual tables for reuse and security.",
          "practiceQuestions": [
            {
              "name": "Second Highest Salary",
              "slug": "second-highest-salary",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/second-highest-salary/"
            },
            {
              "name": "Nth Highest Salary",
              "slug": "nth-highest-salary",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/nth-highest-salary/"
            },
            {
              "name": "Department Highest Salary",
              "slug": "department-highest-salary",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/department-highest-salary/"
            },
            {
              "name": "Immediate Food Delivery II",
              "slug": "immediate-food-delivery-ii",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/immediate-food-delivery-ii/"
            }
          ],
          "learningTip": [
            "Non-correlated subquery runs ONCE, returns a value, outer query uses it. Like computing MAX salary once, then finding all employees with that salary.",
            "Correlated subquery runs ONCE PER ROW of outer query - it references outer query's columns. Much slower but sometimes necessary.",
            "Views are 'saved queries' that act like tables. CREATE VIEW high_earners AS SELECT * FROM emp WHERE salary > 100000. Then: SELECT * FROM high_earners",
            "Use subqueries when you need to compute something (max, avg) then use the result in a comparison."
          ],
          "mustNotMiss": [
            "Non-correlated: SELECT * FROM employees WHERE salary = (SELECT MAX(salary) FROM employees) - inner query runs once, doesn't reference outer",
            "Correlated: SELECT e.* FROM employees e WHERE e.salary > (SELECT AVG(salary) FROM employees WHERE dept = e.dept) - inner query uses e.dept from outer",
            "Second highest salary: SELECT MAX(salary) FROM emp WHERE salary < (SELECT MAX(salary) FROM emp) - neat pattern for Nth highest",
            "CREATE VIEW view_name AS SELECT ... - creates a virtual table. SELECT * FROM view_name works like selecting from a table",
            "Simple views (single table, no aggregates) are updatable. Complex views (joins, aggregates, DISTINCT) are read-only."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between a Correlated Subquery and a Non-Correlated Subquery?",
              "answer": "**Non-Correlated:** Independent of outer query. Runs once total. Efficient. \n\n**Correlated:** References columns from the outer query. Runs *once for every row* of the outer query. Can be very slow."
            },
            {
              "question": "Find the second highest salary using a subquery.",
              "answer": "`SELECT MAX(Salary) FROM Employee WHERE Salary < (SELECT MAX(Salary) FROM Employee);`"
            },
            {
              "question": "What is a View? Can you update data through a View?",
              "answer": "A View is a virtual table (saved query). \n\n**Updateable:** YES, if it maps 1:1 to a table (Simple View). \n**Read-Only:** NO, if it contains joins, aggregates, DISTINCT, or GROUP BY (Complex View)."
            },
            {
              "question": "When would you use a subquery vs a JOIN?",
              "answer": "Use **JOIN** to select columns from multiple tables (generally faster). \nUse **Subquery** to filter data based on a calculation (e.g., 'where salary > average') or for existence checks (`EXISTS`)."
            },
            {
              "question": "Write a subquery to find employees earning above their department average.",
              "answer": "```sql\nSELECT Name, Salary \nFROM Employees e \nWHERE Salary > (\n    SELECT AVG(Salary) \n    FROM Employees \n    WHERE DeptID = e.DeptID\n);\n```"
            },
            {
              "question": "What are the advantages of using Views for security?",
              "answer": "Views allow **row/column level security**. You can give a user access to a View that shows only 'public' columns (Name, Email) while restricting access to the underlying table that contains sensitive data (Salary, Password)."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-subquery",
            "https://datalemur.com/sql-tutorial/sql-correlated-subquery",
            "https://datalemur.com/sql-tutorial/sql-exists",
            "https://datalemur.com/sql-tutorial/sql-views"
          ]
        }
      ]
    },
    {
      "id": "indexing",
      "name": "Indexing",
      "tier": 2,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "indexing_fundamentals",
          "name": "SQL 8: Indexing",
          "estimatedHours": 2,
          "description": "Deep dive into database indexing - the secret sauce that makes databases fast. Understand how indexes work internally (B-Tree structure), when to use them, when NOT to use them, and how they trade write performance for read performance.",
          "practiceQuestions": [
            {
              "name": "Biggest Single Number",
              "slug": "biggest-single-number",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/biggest-single-number/"
            }
          ],
          "learningTip": [
            "**The Book Index Analogy:** A table is a book. A Clustered Index is the page numbers (Physical Order). A Non-Clustered Index is the Index at the back (Logical Order -> Page Number).",
            "**No Free Lunch:** Indexes speed up Reads (SELECT) but slow down Writes (INSERT/UPDATE). Why? Because you have to update the index tree every time you change data.",
            "**Composite Index Trap:** If you index `(Lastname, Firstname)`, searching by `Firstname` ALONE is useless! The index is sorted by Lastname-first. This is the **Leftmost Prefix Rule**.",
            "**Selectivity:** Indexing a 'Gender' column (M/F) is useless. The DB will just scan the whole table because 50% of rows match. Indexes work best on high-cardinality (unique) data."
          ],
          "mustNotMiss": [
            "**Clustered Index:** The physical ordering of data. **Leaf nodes = Data Pages.** Only 1 per table (usually PK).",
            "**Non-Clustered Index:** A separate structure. **Leaf nodes = Pointers** to the Clustered Index key. You can have many.",
            "**Leftmost Prefix Rule:** A composite index on columns (A, B, C) supports queries on (A), (A,B), (A,B,C) but **NOT** (B) or (C) alone.",
            "**Covering Index:** A query where *all* requested columns are in the index itself. Fast! No need to look up the main table (Key Lookup).",
            "**Sargable Queries:** `WHERE YEAR(date_col) = 2023` kills the index (function on column). Use `WHERE date_col BETWEEN '2023-01-01' AND '2023-12-31'` to use the index."
          ],
          "interviewQuestions": [
            {
              "question": "Clustered vs. Non-Clustered Index: Physical storage difference?",
              "answer": "**Clustered:** Reorders actual rows on disk. Leaf nodes = Data. 1 per table. \n**Non-Clustered:** Separate structure. Leaf nodes = Pointers (to PK). Many per table."
            },
            {
              "question": "What is the 'Leftmost Prefix' rule?",
              "answer": "Composite Index `(A, B)` is used for `WHERE A=1` or `WHERE A=1 AND B=2`. \nIt is **NOT** used for `WHERE B=2` because the B-Tree is sorted by A first."
            },
            {
              "question": "When should you AVOID creating an index?",
              "answer": "1. Small tables (Scan is faster). \n2. Low Cardinality cols (Gender, Status). \n3. High Write intensity (Logging tables). \n4. Columns with rare queries."
            },
            {
              "question": "What is Index Seek vs Index Scan?",
              "answer": "**Seek:** Traversing tree to find specific keys (Fast, O(log N)). \n**Scan:** Reading all leaf nodes of the index (Slower, O(N))."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-indexes-guide",
            "https://datalemur.com/sql-tutorial/sql-query-optimization"
          ]
        }
      ]
    },
    {
      "id": "transactions",
      "name": "Transactions",
      "tier": 2,
      "estimatedHours": 4,
      "topics": [
        {
          "id": "transactions_acid",
          "name": "SQL 9: Transactions & ACID",
          "estimatedHours": 2,
          "description": "Understand database transactions - the mechanism that ensures your data stays consistent even when things go wrong. Learn ACID properties that guarantee reliability: Atomicity, Consistency, Isolation, Durability. This is critical for system design interviews.",
          "practiceQuestions": [
            {
              "name": "Consecutive Numbers",
              "slug": "consecutive-numbers",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/consecutive-numbers/"
            }
          ],
          "learningTip": [
            "Imagine transferring â‚¹1000 from Account A to Account B. Two operations: Debit A, Credit B. If system crashes between them, money is LOST. Transactions prevent this.",
            "ATOMICITY: All or nothing. Either BOTH debit and credit happen, or NEITHER happens. No partial state.",
            "CONSISTENCY: Database moves from one valid state to another. If a rule says balance >= 0, transaction that violates this is rejected.",
            "DURABILITY: Once you see 'success', the data is safe even if server catches fire 1 second later. Written to disk, not just memory."
          ],
          "mustNotMiss": [
            "BEGIN TRANSACTION or START TRANSACTION - marks the start. All subsequent statements are part of this transaction.",
            "COMMIT - makes all changes permanent. Once committed, changes survive crashes, are visible to others.",
            "ROLLBACK - undoes ALL changes since BEGIN. As if nothing happened. Database returns to previous consistent state.",
            "SAVEPOINT name - creates a checkpoint. ROLLBACK TO SAVEPOINT name - undo to that checkpoint, but keep earlier changes.",
            "ACID is the interview acronym: Atomicity (all or nothing), Consistency (rules enforced), Isolation (transactions don't see each other's partial work), Durability (committed = permanent)"
          ],
          "interviewQuestions": [
            {
              "question": "Explain the ACID properties in detail with examples.",
              "answer": "**Atomicity:** All or nothing. (e.g., Transfer $100: debit & credit both succeed, or neither happens). \n**Consistency:** Data validity rules preserved. (e.g., Account balance cannot be negative). \n**Isolation:** Transactions don't interfere with each other's intermediate states. (e.g., One transaction doesn't see another's uncommitted changes). \n**Durability:** Committed data is permanent and survives system failures. (e.g., Once a transaction commits, the changes are saved to disk)."
            },
            {
              "question": "What happens during a ROLLBACK command?",
              "answer": "The `ROLLBACK` command undoes all modifications made by the current uncommitted transaction. It returns the database to its state before the `BEGIN TRANSACTION` statement, effectively discarding all changes made within that transaction."
            },
            {
              "question": "How does the Atomicity property ensure data integrity?",
              "answer": "Atomicity treats a sequence of SQL operations as a single, indivisible unit. If any part of this unit fails, the entire unit is aborted, preventing 'partial updates' or inconsistent data states. This ensures that either all changes are applied successfully, or none are, maintaining data integrity."
            },
            {
              "question": "What is a SAVEPOINT and when would you use it?",
              "answer": "A `SAVEPOINT` is a partial checkpoint within a transaction. It allows you to `ROLLBACK TO SAVEPOINT name`, undoing changes only up to that point, without aborting the entire transaction. This is useful in complex transactions where you might want to retry a specific step or handle errors for a subset of operations."
            },
            {
              "question": "Describe a real-world scenario where transactions are critical (e.g., bank transfer).",
              "answer": "**E-commerce Checkout:** When a customer places an order, a transaction might involve: \n1. Decrementing inventory for purchased items. \n2. Inserting the order details into the `Orders` table. \n3. Processing payment. \nIf payment fails, the entire transaction must be rolled back to ensure inventory is restored and no incomplete order records are left, preventing partial success."
            },
            {
              "question": "What is the difference between implicit and explicit transactions?",
              "answer": "**Implicit Transactions:** The database system automatically treats each individual SQL statement (like `INSERT`, `UPDATE`, `DELETE`) as a separate transaction, committing it immediately upon successful execution. This is often the default 'auto-commit' mode. \n**Explicit Transactions:** The user explicitly defines the start and end of a transaction using commands like `BEGIN TRANSACTION` and `COMMIT` or `ROLLBACK`. This allows multiple SQL statements to be grouped into a single logical unit of work."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-transactions-acid"
          ]
        },
        {
          "id": "transactions_isolation",
          "name": "SQL 10: Transaction Isolation Levels",
          "estimatedHours": 2,
          "description": "Deep dive into the 'I' in ACID - Isolation. What happens when multiple transactions run simultaneously? Learn about isolation levels (Read Uncommitted to Serializable), concurrency problems (Dirty Reads, Phantom Reads), and locking strategies.",
          "practiceQuestions": [
            {
              "name": "Last Person to Fit in the Bus",
              "slug": "last-person-to-fit-in-the-bus",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/last-person-to-fit-in-the-bus/"
            }
          ],
          "learningTip": [
            "Isolation level is a trade-off: Higher isolation = safer but slower (more locking). Lower isolation = faster but risk of reading incorrect data.",
            "Interview question: 'User sees their balance is â‚¹1000, starts a transfer of â‚¹800. Another transaction deducts â‚¹500 in between. What happens?' Answer depends on isolation level!",
            "Optimistic locking: Assume no conflict, check at commit time. Good when conflicts are rare. Uses version numbers.",
            "Pessimistic locking: Lock data when you read it, prevent others from modifying. Good when conflicts are common but reduces concurrency."
          ],
          "mustNotMiss": [
            "READ UNCOMMITTED: Can read data that other transactions haven't committed yet. Risk: Dirty Read - reading data that might be rolled back!",
            "READ COMMITTED: Only see committed data. Solves dirty reads. But same query in transaction might return different results (Non-Repeatable Read).",
            "REPEATABLE READ: Same query always returns same result within transaction. But new rows might appear (Phantom Read). MySQL default.",
            "SERIALIZABLE: Transactions execute as if one-by-one. No anomalies. But slowest because of heavy locking.",
            "Three anomalies: Dirty Read (reading uncommitted), Non-Repeatable Read (row changed between reads), Phantom Read (new matching rows appear)"
          ],
          "interviewQuestions": [
            {
              "question": "Explain the Transaction Isolation Levels with examples.",
              "answer": "1. **Read Uncommitted:** Dirty reads allowed. Fastest, no locking, but unsafe. \n2. **Read Committed:** No dirty reads. Writers temporarily block readers (or use snapshots). Standard default. \n3. **Repeatable Read:** Consistent reads within same transaction. Prevents 'non-repeatable reads'. \n4. **Serializable:** Strict serial execution. Uses Range Locks. Slowest, zero concurrency errors."
            },
            {
              "question": "What are Dirty Reads, Non-Repeatable Reads, and Phantom Reads?",
              "answer": "**Dirty Read:** Reading uncommitted data. \n**Non-Repeatable Read:** Reading same row twice gets different values (someone updated it). \n**Phantom Read:** Running same range query twice finds different number of rows (someone inserted new row)."
            },
            {
              "question": "Difference between Optimistic and Pessimistic Locking?",
              "answer": "**Pessimistic:** Lock row immediately upon read. Safest, lowers concurrency. \n**Optimistic:** No locks. Check version/timestamp at save time. High concurrency, risk of retry."
            },
            {
              "question": "Which isolation level would you choose for a banking application and why?",
              "answer": "**Serializable** or **Repeatable Read**. Financial data requires strict consistency; you cannot tolerate phantom withdrawals or balance changes during a calculation."
            },
            {
              "question": "How does MVCC (Multi-Version Concurrency Control) work?",
              "answer": "**MVCC (Multi-Version Concurrency Control)** keeps multiple versions of a row instead of overwriting immediately. \n\n**Key Benefit:** Readers read the 'snapshot' version from when they started, while Writers create a new version. **Readers do NOT block Writers**, and **Writers do NOT block Readers**, significantly boosting concurrency."
            },
            {
              "question": "What is a deadlock and how can you prevent it?",
              "answer": "Two transactions waiting for each other's locks forever. \n\n**Prevent:** Access resources in same order. Keep transactions short. Use timeouts."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-isolation-levels",
            "https://datalemur.com/sql-tutorial/sql-mvcc"
          ]
        }
      ]
    },
    {
      "id": "schema_design",
      "name": "Schema Design",
      "tier": 2,
      "estimatedHours": 4,
      "topics": [
        {
          "id": "schema_design_normalization",
          "name": "SQL 11: Schema Design - Normalization",
          "estimatedHours": 2,
          "description": "Learn how to design good database schemas using normalization - a systematic way to eliminate data redundancy and prevent update anomalies. Master 1NF, 2NF, 3NF rules that most databases should follow.",
          "practiceQuestions": [
            {
              "name": "Reformat Department Table",
              "slug": "reformat-department-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reformat-department-table/"
            },
            {
              "name": "Rearrange Products Table",
              "slug": "rearrange-products-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rearrange-products-table/"
            }
          ],
          "learningTip": [
            "Why normalize? Imagine storing {StudentName, CourseName, InstructorName, InstructorEmail} in one table. If instructor changes email, you must update EVERY row for their courses!",
            "1NF: 'Atomic values' - no lists in cells. Bad: 'Math, Physics, Chemistry'. Good: Three separate rows.",
            "2NF: 'No partial dependencies' - every non-key column must depend on the ENTIRE primary key, not just part of it.",
            "3NF: 'No transitive dependencies' - non-key columns must depend on the KEY, not on OTHER non-key columns."
          ],
          "mustNotMiss": [
            "1NF Rules: Each cell has single value (no arrays). Each row is unique (has primary key). No repeating groups of columns.",
            "2NF: Must be in 1NF + no partial dependencies. If PK is (StudentID, CourseID), then InstructorName shouldn't depend only on CourseID.",
            "3NF: Must be in 2NF + no transitive dependencies. If EmployeeID â†’ DepartmentID â†’ DepartmentName, remove DepartmentName from employee table.",
            "BCNF (Boyce-Codd): Stricter than 3NF. Every determinant must be a candidate key. Rarely needed in practice.",
            "3NF is sufficient for 90% of applications. It eliminates most redundancy while keeping the design practical."
          ],
          "interviewQuestions": [
            "Explain 1NF, 2NF, and 3NF with examples.",
            "Why is 3NF (Third Normal Form) usually sufficient for most applications?",
            "Convert a flat spreadsheet of Student-Course data into a normalized schema.",
            "What are update anomalies and how does normalization prevent them?",
            "When is BCNF required over 3NF?",
            "What are insertion, deletion, and update anomalies?"
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-normalization",
            "https://datalemur.com/sql-tutorial/sql-normal-forms"
          ]
        },
        {
          "id": "schema_design_er_diagrams",
          "name": "SQL 12: ER Diagrams & Denormalization",
          "estimatedHours": 2,
          "description": "Master Entity-Relationship diagrams for visualizing database designs before writing SQL. Also learn when to intentionally BREAK normalization rules (denormalization) for performance in read-heavy systems.",
          "practiceQuestions": [
            {
              "name": "Fix Names in a Table",
              "slug": "fix-names-in-a-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fix-names-in-a-table/"
            },
            {
              "name": "Patients With a Condition",
              "slug": "patients-with-a-condition",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/patients-with-a-condition/"
            }
          ],
          "learningTip": [
            "E-R diagrams are a THINKING tool, not just documentation. Draw boxes (entities), connect with lines (relationships), note cardinality (1-to-many, etc.).",
            "Denormalization is purposely adding redundancy to speed up reads. Store customer name directly in Order table instead of joining every time.",
            "Normalize for write-heavy (banking, transactions). Denormalize for read-heavy (analytics dashboards, reporting).",
            "NoSQL databases often require denormalized designs because they don't support joins efficiently."
          ],
          "mustNotMiss": [
            "One-to-One: User â†’ UserProfile. Either share primary key, or one table has foreign key with UNIQUE constraint.",
            "One-to-Many: Customer â†’ Orders. Foreign key goes on the 'many' side (orders table has customer_id).",
            "Many-to-Many: Students â†” Courses. Requires a junction/bridge table: Enrollments(student_id, course_id).",
            "Denormalization examples: Store total_order_amount in Order instead of computing SUM of items. Store product_name in OrderItem instead of joining.",
            "When to denormalize: Read queries vastly outnumber writes, JOINs are becoming bottleneck, you can accept slightly stale data."
          ],
          "interviewQuestions": [
            {
              "question": "When should you intentionally De-normalize a database?",
              "answer": "For **Read Performance**. If complex JOINs excessively slow down critical queries (e.g., analytics dashboard), you might duplicate data (like customer name in Orders table) to avoid the overhead, accepting the risk of slower updates."
            },
            {
              "question": "Design an E-R diagram for an E-commerce system (User, Order, Product).",
              "answer": "Entities: User, Order, Product. \nRelationships: \n1. User 1:N Order (One user, many orders) \n2. Order M:N Product (Order has many products, Product in many orders). \n\n*Requires 'OrderItems' junction table to handle the M:N link.*"
            },
            {
              "question": "What is the difference between a One-to-One and One-to-Many relationship?",
              "answer": "**1:1 (One-to-One):** A row in Table A links to ONE row in Table B. (e.g., User -> Passport). \n**1:N (One-to-Many):** A row in Table A links to MULTIPLE rows in Table B. (e.g., Teacher -> Students)."
            },
            {
              "question": "How would you design a schema for a social media 'followers' feature?",
              "answer": "Self-referencing M:N relationship table `Follows`: \n- `follower_id` (FK to Users) \n- `followee_id` (FK to Users) \n- PK: Composite `(follower_id, followee_id)`"
            },
            {
              "question": "When would you choose a star schema vs a snowflake schema?",
              "answer": "**Star Schema:** Central fact table, denormalized dimensions. Faster queries. best for Data Marts. \n**Snowflake Schema:** Normalized dimensions (split into tables). Saves space, but complex joins. Good for huge dimensions."
            },
            {
              "question": "How do you represent Many-to-Many relationships in a relational database?",
              "answer": "You CANNOT link them directly. You must create a **Junction Table** (Associative Entity) that holds the foreign keys of both parents. e.g., `Student_Classes` table links `Students` and `Classes`."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-er-diagrams",
            "https://datalemur.com/sql-tutorial/sql-denormalization"
          ]
        }
      ]
    },
    {
      "id": "advanced_analytics",
      "name": "Advanced Analytics - Window Functions",
      "tier": 3,
      "estimatedHours": 4.25,
      "topics": [
        {
          "id": "window_functions_topic",
          "name": "SQL 13: Window Functions - CRITICAL FOR INTERVIEWS",
          "estimatedHours": 4.25,
          "description": "Master SQL window functions - RANK, DENSE_RANK, ROW_NUMBER, LAG, LEAD, running totals. These are THE most asked advanced SQL topics in technical interviews. They let you calculate across a 'window' of rows without collapsing results like GROUP BY does.",
          "practiceQuestions": [
            {
              "name": "Rank Scores",
              "slug": "rank-scores",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/rank-scores/"
            },
            {
              "name": "Department Top Three Salaries",
              "slug": "department-top-three-salaries",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/department-top-three-salaries/"
            },
            {
              "name": "Consecutive Numbers",
              "slug": "consecutive-numbers",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/consecutive-numbers/"
            },
            {
              "name": "Human Traffic of Stadium",
              "slug": "human-traffic-of-stadium",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/human-traffic-of-stadium/"
            },
            {
              "name": "Game Play Analysis IV",
              "slug": "game-play-analysis-iv",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/game-play-analysis-iv/"
            },
            {
              "name": "Count Salary Categories",
              "slug": "count-salary-categories",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/count-salary-categories/"
            },
            {
              "name": "User's Third Transaction",
              "slug": "sql-third-transaction",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/sql-third-transaction"
            },
            {
              "name": "Highest-Grossing Items",
              "slug": "sql-highest-grossing",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/sql-highest-grossing"
            },
            {
              "name": "Top 5 Artists",
              "slug": "top-fans-rank",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/top-fans-rank"
            }
          ],
          "learningTip": [
            "**Group By vs Window:** `GROUP BY` collapses the party (10 rows -> 1 row). `Window Functions` keep the party going but add a 'summary' sticker to everyone's shirt (10 rows -> 10 rows + summary col).",
            "**The 'Frame' Concept:** By default, `ORDER BY` in a window implies 'Range Unbounded Preceding to Current Row' (Running Total). If you want a full partition average, remove the ORDER BY or change the frame.",
            "**Rank vs Dense Rank:** Think of the Olympics. If two people tie for Gold, is the next person Silver (Dense Rank) or Bronze (Rank)? SQL standard is usually 'Bronze' (Rank skips), but Dense Rank is friendlier.",
            "**Moving Averages:** Window functions are the ONLY sane way to calculate 7-day moving averages in SQL. Self-joins for this are a nightmare."
          ],
          "mustNotMiss": [
            "**Syntax:** `FUNC() OVER (PARTITION BY col1 ORDER BY col2)`. Memorize this structure.",
            "**PARTITION BY:** Resets the counter. Like 'Group By', but for the window. `ROW_NUMBER() OVER (PARTITION BY Dept)` gives a fresh 1,2,3 for EACH department.",
            "**ROW_NUMBER():** Always unique (1, 2, 3, 4). Good for pagination or 'Get top 1 per group'.",
            "**RANK():** Skips gaps on ties (1, 1, 3, 4).",
            "**DENSE_RANK():** No gaps on ties (1, 1, 2, 3). Use this for 'Find 2nd highest salary' questions.",
            "**LAG(col, n, default) OVER(...):** Value from n rows BEFORE. Useful for comparing current row to previous.",
            "**LEAD(col, n, default) OVER(...):** Value from n rows AFTER. Useful for time-series comparisons.",
            "**SUM(col) OVER(ORDER BY date):** Running total - cumulative sum up to current row."
          ],
          "interviewQuestions": [
            {
              "question": "Difference between RANK(), DENSE_RANK(), and ROW_NUMBER()?",
              "answer": "**ROW_NUMBER:** Unique seq (1,2,3,4). Ties get distinct numbers. \n**RANK:** Ties same rank, skips next (1,1,3,4). \n**DENSE_RANK:** Ties same rank, NO gap (1,1,2,3)."
            },
            {
              "question": "Write a query to calculate a running total (cumulative sum) using OVER().",
              "answer": "`SELECT Date, Val, SUM(Val) OVER (ORDER BY Date) as RunningTotal FROM Sales;`"
            },
            {
              "question": "Use LAG() and LEAD() to compare a row with the previous row.",
              "answer": "```sql\nSELECT Date, Income, \n(Income - LAG(Income) OVER(ORDER BY Date)) as Growth \nFROM Sales\n```"
            },
            {
              "question": "Find the top 3 earners in each department using window functions.",
              "answer": "```sql\nWITH Ranked AS (\n  SELECT *, DENSE_RANK() OVER(PARTITION BY Dept ORDER BY Sal DESC) as rnk \n  FROM Emp\n) \nSELECT * FROM Ranked WHERE rnk <= 3;\n```"
            },
            {
              "question": "Calculate a 7-day moving average of daily sales.",
              "answer": "`AVG(Sales) OVER (ORDER BY Date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)`"
            },
            {
              "question": "What is the difference between ROWS and RANGE in window frames?",
              "answer": "**ROWS:** Counts physical rows (e.g., 'previous 2 rows'). \n**RANGE:** Logical value range (e.g., 'rows with date within last 2 days'). Handles ties differently."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-window-functions",
            "https://datalemur.com/sql-tutorial/sql-rank-dense-rank-row-number",
            "https://datalemur.com/sql-tutorial/sql-lead-lag"
          ]
        }
      ]
    },
    {
      "id": "advanced_query_concepts",
      "name": "CTEs & Advanced Queries",
      "tier": 3,
      "estimatedHours": 7.5,
      "topics": [
        {
          "id": "ctes_temp_tables",
          "name": "SQL 14: CTEs (Common Table Expressions) & Recursive Queries",
          "estimatedHours": 7.5,
          "description": "Master CTEs (WITH clause) for breaking complex queries into readable, manageable pieces. Learn recursive CTEs for hierarchical data like org charts, category trees, and graph traversals. Understand when to use CTEs vs temporary tables.",
          "practiceQuestions": [
            {
              "name": "Employees Whose Manager Left the Company",
              "slug": "employees-whose-manager-left-the-company",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/employees-whose-manager-left-the-company/"
            },
            {
              "name": "Tree Node",
              "slug": "tree-node",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/tree-node/"
            },
            {
              "name": "Investments in 2016",
              "slug": "investments-in-2016",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/investments-in-2016/"
            },
            {
              "name": "The Number of Employees Which Report to Each Employee",
              "slug": "the-number-of-employees-which-report-to-each-employee",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/customers-who-never-order/"
            },
            {
              "name": "Supercloud Customer",
              "slug": "supercloud-customer",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/supercloud-customer"
            },
            {
              "name": "Odd and Even Measurements",
              "slug": "odd-even-measurements",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/odd-even-measurements"
            },
            {
              "name": "Duplicate Job Listings",
              "slug": "duplicate-job-listings",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/duplicate-job-listings"
            },
            {
              "name": "Sending vs. Opening Snaps",
              "slug": "time-spent-snaps",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/time-spent-snaps"
            },
            {
              "name": "Tweets' Rolling Averages",
              "slug": "rolling-average-tweets",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/rolling-average-tweets"
            },
            {
              "name": "Frequently Purchased Pairs",
              "slug": "frequently-purchased-pairs",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/frequently-purchased-pairs"
            },
            {
              "name": "Best-Selling Product",
              "slug": "best-selling-product",
              "difficulty": "Medium",
              "link": "https://datalemur.com/questions/best-selling-product"
            }
          ],
          "learningTip": [
            "**Refactoring with CTEs:** Think of CTEs as 'Variables' for your query. Instead of a nested subquery mess, you define `WITH regional_sales AS (...)`. It makes code readable top-to-bottom.",
            "**Recursion Magic:** Recursive CTEs are the standard way to walk trees (Org Charts, Category Paths). It loops until it finds no new rows.",
            "**Materialization:** Postgres and some others might 'materialize' (cache) a CTE, making it faster if referenced twice. MySQL usually doesn't.",
            "**Debugging:** CTEs are great for debugging. You can just `SELECT * FROM my_cte` to test the logic of one part before finishing the whole complex query."
          ],
          "mustNotMiss": [
            "**CTE Syntax:** `WITH cte_name AS (SELECT ...) SELECT * FROM cte_name`.",
            "**Recursive CTE Parts:** 1. Base Member (Reference Point) 2. UNION ALL 3. Recursive Member (Joins to CTE itself) 4. Termination Condition (Implicit when join finds no rows).",
            "**CTE vs Temp Table:** CTE exists only for *one* query. Temp Table exists for the *session*. Use CTE for readability, Temp Table for complex multi-step processing procedures.",
            "**Hierarchical Data:** If asked 'How to find all managers of an employee recursively?', the answer is ALWAYS 'Recursive CTE'."
          ],
          "interviewQuestions": [
            {
              "question": "What is a Common Table Expression (CTE) and how does it differ from a Subquery?",
              "answer": "A CTE (`WITH name AS...`) is a named temporary result set. \n\n**vs Subquery:** Better readability (linear vs nested). \n**Optimization:** Some DBs (Postgres) can 'materialize' CTEs (calculate once, reuse results), whereas subqueries might be re-executed multiple times if correlated."
            },
            {
              "question": "Write a Recursive CTE to generate an organization chart hierarchy.",
              "answer": "```sql\nWITH RECURSIVE Org AS (\n  SELECT Id, Name, 1 as Lvl FROM Emp WHERE ManagerID IS NULL -- Anchor\n  UNION ALL\n  SELECT e.Id, e.Name, o.Lvl+1 FROM Emp e JOIN Org o ON e.ManagerID = o.Id\n) SELECT * FROM Org;\n```"
            },
            {
              "question": "When should you use a Temporary Table vs a CTE?",
              "answer": "**CTE:** Single query, recursion, readability. \n**Temp Table:** Multiple steps, need indexing, complex processing across stored procedure calls."
            },
            {
              "question": "How would you find all children of a node in a tree structure?",
              "answer": "Use a **Recursive CTE** starting with the Parent ID as the anchor, and recursively joining the table to finding children."
            },
            {
              "question": "What is the difference between CTE and derived table (inline view)?",
              "answer": "Derived Table is a subquery in FROM (`SELECT * FROM (SELECT...) t`). \nCTE is defined *before* the query. CTEs are reusable and cleaner; functionality is overlapping."
            },
            {
              "question": "Can a CTE reference itself? How does recursive CTE work?",
              "answer": "**Yes.** It has an Anchor member (base case) and a Recursive member (that joins to the CTE itself). They are combined with UNION ALL."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-cte",
            "https://datalemur.com/sql-tutorial/sql-recursive-cte"
          ]
        }
      ]
    },
    {
      "id": "database_programmability",
      "name": "Database Programmability",
      "tier": 3,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "triggers_procedures",
          "name": "SQL 15: Stored Procedures, Functions & Triggers",
          "estimatedHours": 2,
          "description": "Learn database programming - encapsulating logic inside the database itself. Stored Procedures for reusable parameterized logic, Functions for computed values, and Triggers for automatic actions when data changes.",
          "practiceQuestions": [
            {
              "name": "Exchange Seats",
              "slug": "exchange-seats",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/exchange-seats/"
            },
            {
              "name": "Movie Rating",
              "slug": "movie-rating",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/movie-rating/"
            },
            {
              "name": "Average Selling Price",
              "slug": "average-selling-price",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/average-selling-price/"
            }
          ],
          "learningTip": [
            "**Stored Procedures are the API:** In many legacy systems, the App doesn't query tables directly. It calls `EXEC GetUser(id)`. This creates a security layer and allows DBAs to tune queries without changing App code.",
            "**Functions are for Math/Transformation:** Use Scalar Functions to format phone numbers or calculate tax. Never use them to change data (DML).",
            "**Triggers are Dangerous:** They are hidden logic. You update a table, and 5 other things happen magically. Great for auditing, terrible for debugging business logic.",
            "**SQL Injection Defense:** Stored Procedures naturally prevent SQL Injection because they separate code (the query plan) from data (the parameters)."
          ],
          "mustNotMiss": [
            "**Stored Procedure:** Pre-compiled SQL code. Can handle Logic (IF/ELSE), Transactions, and DML (Insert/Update). Can return multiple result sets.",
            "**User Defined Function (UDF):** Must return a value. Used in SELECT/WHERE clauses. Cannot modify database state (usually).",
            "**Trigger:** Event-driven. Fires on BEFORE/AFTER INSERT/UPDATE/DELETE. Use `OLD` and `NEW` keywords to access data before/after the change.",
            "**View:** A saved SELECT query. It has no data of its own (unless Materialized). Used for Security (hiding columns) and Simplicity."
          ],
          "interviewQuestions": [
            {
              "question": "Stored Procedure vs. Function?",
              "answer": "**Proc:** Void return or multiple result sets. Can change DB state (DML). Input/Output params. \n**Func:** Must return value. Used in SELECT. Cannot change DB state (usually)."
            },
            {
              "question": "What is a Materialized View?",
              "answer": "A physical copy of view data stored on disk. \n**Pros:** Fast reads for complex joins. \n**Cons:** Data is stale until refreshed. Good for analytics."
            },
            {
              "question": "Triggers: AFTER vs INSTEAD OF?",
              "answer": "**AFTER:** Runs after DML. Good for logging/auditing. \n**INSTEAD OF:** Runs *in place of* DML. Good for checking complex views or overriding logic."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-stored-procedures",
            "https://datalemur.com/sql-tutorial/sql-functions",
            "https://datalemur.com/sql-tutorial/sql-triggers"
          ]
        }
      ]
    },
    {
      "id": "string_date_functions_advanced",
      "name": "String & Date Functions",
      "tier": 3,
      "estimatedHours": 2,
      "topics": [
        {
          "id": "string_date_manipulation",
          "name": "SQL 16: String & Date Manipulation",
          "estimatedHours": 2,
          "description": "Learn essential SQL functions for working with text and temporal data. Master string operations like concatenation, substring extraction, and pattern matching, and date functions for formatting, extracting parts, and calculating differences.",
          "practiceQuestions": [
            {
              "name": "Fix Names in a Table",
              "slug": "fix-names-in-a-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/fix-names-in-a-table/"
            },
            {
              "name": "Patients With a Condition",
              "slug": "patients-with-a-condition",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/patients-with-a-condition/"
            },
            {
              "name": "Recyclable and Low Fat Products",
              "slug": "recyclable-and-low-fat-products",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/recyclable-and-low-fat-products/"
            }
          ],
          "learningTip": [
            "String functions are crucial for data cleaning and formatting. `TRIM`, `LOWER`, `UPPER`, `SUBSTRING` are your friends.",
            "Date functions are essential for time-series analysis. `DATE_PART` (Postgres) or `EXTRACT` (SQL Server/Oracle) for components, `DATE_ADD`/`DATE_SUB` for arithmetic.",
            "Regular expressions (`REGEXP_LIKE` or `RLIKE`) offer powerful pattern matching beyond `LIKE`.",
            "Always check your specific SQL dialect's documentation for exact function names and syntax (e.g., `CONCAT` vs `||`, `GETDATE()` vs `NOW()`)."
          ],
          "mustNotMiss": [
            "String: `CONCAT(str1, str2)`, `SUBSTRING(str, start, length)`, `LENGTH(str)`, `REPLACE(str, old, new)`, `TRIM(str)`, `LOWER(str)`, `UPPER(str)`",
            "Pattern Matching: `LIKE '%pattern%'`, `ILIKE` (case-insensitive), `REGEXP_LIKE(str, 'regex')`",
            "Date/Time: `CURRENT_DATE`, `CURRENT_TIMESTAMP`, `DATE_TRUNC('month', date_col)`, `EXTRACT(YEAR FROM date_col)`, `DATE_DIFF(unit, date1, date2)`",
            "Casting: `CAST(date_col AS DATE)`, `CAST(string_col AS INT)` - important for type conversions.",
            "Handling different date formats: `TO_DATE(string, 'YYYY-MM-DD')` or `STR_TO_DATE` (MySQL) for parsing."
          ],
          "interviewQuestions": [
            {
              "question": "How do you extract the year and month from a date column?",
              "answer": "`SELECT EXTRACT(YEAR FROM date_col), EXTRACT(MONTH FROM date_col) FROM table;` (Standard SQL) \n`SELECT YEAR(date_col), MONTH(date_col) FROM table;` (MySQL) \n`SELECT DATE_PART('year', date_col), DATE_PART('month', date_col) FROM table;` (Postgres)"
            },
            {
              "question": "Write a query to find all emails ending with '@example.com'.",
              "answer": "`SELECT email FROM users WHERE email LIKE '%@example.com';`"
            },
            {
              "question": "How to calculate the difference in days between two dates?",
              "answer": "`SELECT DATEDIFF(day, date1, date2) FROM table;` (SQL Server) \n`SELECT date2 - date1 FROM table;` (Postgres, returns interval) \n`SELECT DATEDIFF(date2, date1) FROM table;` (MySQL)"
            },
            {
              "question": "Clean a string by removing leading/trailing spaces and converting to lowercase.",
              "answer": "`SELECT LOWER(TRIM(my_string_column)) FROM my_table;`"
            },
            {
              "question": "How would you concatenate first name and last name into a full name?",
              "answer": "`SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;` (Standard) \n`SELECT first_name || ' ' || last_name AS full_name FROM users;` (Postgres/Oracle)"
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-string-functions",
            "https://datalemur.com/sql-tutorial/sql-date-functions"
          ]
        }
      ]
    },
    {
      "id": "pivot_unpivot",
      "name": "PIVOT & UNPIVOT",
      "tier": 3,
      "estimatedHours": 1.5,
      "topics": [
        {
          "id": "pivot_unpivot_data",
          "name": "SQL 17: PIVOT & UNPIVOT",
          "estimatedHours": 1.5,
          "description": "Transform rows into columns (PIVOT) and columns into rows (UNPIVOT) for better data analysis and reporting. Understand when and how to use these powerful, though sometimes database-specific, operations.",
          "practiceQuestions": [
            {
              "name": "Reformat Department Table",
              "slug": "reformat-department-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/reformat-department-table/"
            },
            {
              "name": "Rearrange Products Table",
              "slug": "rearrange-products-table",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/rearrange-products-table/"
            }
          ],
          "learningTip": [
            "**Pivot = Rotation:** You are taking row values ('Jan', 'Feb') and turning them into Column Headers. This reduces the number of rows.",
            "**Unpivot = Normalize:** You are taking Column Headers ('Jan_Sales', 'Feb_Sales') and turning them into row values. This increases the number of rows.",
            "**The CASE Trick:** Most PIVOTs in interviews are done manually: `SUM(CASE WHEN Month='Jan' THEN Sales ELSE 0 END)`. Learn this pattern by heart!"
          ],
          "mustNotMiss": [
            "**Manual PIVOT:** `SELECT ID, MAX(CASE WHEN Key='A' THEN Val END) as A, MAX(CASE WHEN Key='B' THEN Val END) as B FROM Tbl GROUP BY ID`.",
            "**When to usage:** PIVOT for Reporting (Human readable). UNPIVOT for Analytics (Machine readable / Charting tools prefer tall data).",
            "**Dynamic Pivot:** Standard SQL cannot pivot an unknown number of columns (e.g., if a new month appears). You need Dynamic SQL for that."
          ],
          "interviewQuestions": [
            {
              "question": "What is the purpose of PIVOT and UNPIVOT operations?",
              "answer": "**PIVOT:** Transforms rows into columns, aggregating data. Useful for cross-tab reports. \n**UNPIVOT:** Transforms columns into rows. Useful for normalizing 'wide' tables or preparing data for analysis."
            },
            {
              "question": "How can you achieve a PIVOT operation without using the PIVOT keyword?",
              "answer": "Using `CASE` statements with `GROUP BY`. For example, `SUM(CASE WHEN category = 'A' THEN value ELSE 0 END) AS CategoryA_Sum`."
            },
            {
              "question": "When would you use UNPIVOT?",
              "answer": "When you have data spread across multiple columns that logically represent values of a single attribute (e.g., `Jan_Sales`, `Feb_Sales`, `Mar_Sales` should be `Month`, `Sales`). It helps in converting 'wide' tables to 'tall' tables."
            },
            {
              "question": "Can PIVOT handle dynamic column names (i.e., columns not known beforehand)?",
              "answer": "Standard SQL PIVOT syntax usually requires static column names. For dynamic pivoting, you typically need to use **dynamic SQL** (constructing the query string programmatically) or rely on client-side application logic."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-pivot-table",
            "https://datalemur.com/sql-tutorial/sql-unpivot"
          ]
        }
      ]
    },
    {
      "id": "null_handling",
      "name": "NULL Handling",
      "tier": 3,
      "estimatedHours": 1,
      "topics": [
        {
          "id": "null_handling_fundamentals",
          "name": "SQL 18: NULL Handling",
          "estimatedHours": 1,
          "description": "Understand the intricacies of NULL values in SQL - what they represent, how they behave in comparisons, aggregates, and joins, and best practices for handling them to avoid unexpected results.",
          "practiceQuestions": [
            {
              "name": "Customers Who Never Order",
              "slug": "customers-who-never-order",
              "difficulty": "Easy",
              "link": "https://leetcode.com/problems/customers-who-never-order/"
            },
            {
              "name": "Managers with at Least 5 Direct Reports",
              "slug": "managers-with-at-least-5-direct-reports",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
            }
          ],
          "learningTip": [
            "**3-Valued Logic:** Boolean logic is `True, False`. SQL Logic is `True, False, Unknown`. `True AND Unknown` = `Unknown`. `False AND Unknown` = `False`.",
            "**Aggregation Filter:** `COUNT(col)` ignores NULLs. This is a feature, not a bug. It lets you count 'only people who have a phone number'.",
            "**Propagation:** `1 + NULL = NULL`. `String + NULL = NULL`. If you touch a NULL without protection (COALESCE), it destroys your value.",
            "**Ordering:** In some DBs (Oracle, Postgres), NULLs sort LAST (largest). In others (MySQL, SQL Server), NULLs sort FIRST (smallest). Use `NULLS LAST` to be safe."
          ],
          "mustNotMiss": [
            "**IS NULL / IS NOT NULL:** The only comparators that work.",
            "**COALESCE(a, b, c):** Returns first non-null. Use it to set default values: `COALESCE(Commission, 0)`.",
            "**NULLIF(a, b):** Returns NULL if a=b. Essential for avoiding 'Divide by Zero' errors: `Price / NULLIF(Qty, 0)` returns NULL instead of crashing.",
            "**Not In Trap:** `WHERE val NOT IN (1, 2, NULL)` returns EMPTY SET. Why? `val != NULL` is Unknown. So it never evaluates to True."
          ],
          "interviewQuestions": [
            {
              "question": "What is NULL in SQL and how does it differ from an empty string or zero?",
              "answer": "**NULL** represents missing or unknown data. It is not a value. \n**Empty string ('')** is a known value (a string of zero length). \n**Zero (0)** is a known numeric value. \nNULL behaves differently in comparisons and functions."
            },
            {
              "question": "How do you check for NULL values in a WHERE clause?",
              "answer": "You must use `IS NULL` or `IS NOT NULL`. \n`WHERE column = NULL` or `WHERE column != NULL` will always return no rows because any comparison with NULL results in UNKNOWN."
            },
            {
              "question": "Explain the behavior of aggregate functions (SUM, AVG, COUNT) with NULLs.",
              "answer": "Most aggregate functions (SUM, AVG, MIN, MAX) **ignore NULL values**. \n`COUNT(*)` counts all rows. \n`COUNT(column_name)` counts only non-NULL values in that column."
            },
            {
              "question": "What is COALESCE and when would you use it?",
              "answer": "`COALESCE(expr1, expr2, ..., exprN)` returns the first non-NULL expression in the list. \n**Use case:** Providing a default value when a column might be NULL, e.g., `COALESCE(phone_number, 'N/A')`."
            },
            {
              "question": "How do NULLs affect JOIN operations?",
              "answer": "Standard join conditions (`ON a.col = b.col`) will **not match** rows where either `a.col` or `b.col` is NULL, even if both are NULL. This is because `NULL = NULL` evaluates to UNKNOWN, not TRUE. Special handling (e.g., `COALESCE` or `IS NULL` in `ON` clause) is needed for NULL-safe joins."
            }
          ],
          "resources": [
            "https://datalemur.com/sql-tutorial/sql-null-values",
            "https://datalemur.com/sql-tutorial/sql-coalesce"
          ]
        }
      ]
    },
    {
      "id": "practical_scenarios",
      "name": "Interview Practice Scenarios",
      "tier": 3,
      "estimatedHours": 13,
      "topics": [
        {
          "id": "real_world_scenarios",
          "name": "SQL 19: Real-World SQL Interview Patterns",
          "estimatedHours": 13,
          "description": "Practice the most common SQL interview patterns - Top-N per group, finding gaps and islands (consecutive sequences), calculating running totals and moving averages, handling hierarchical data, and solving complex business logic problems.",
          "practiceQuestions": [
            {
              "name": "Trips and Users",
              "slug": "trips-and-users",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/trips-and-users/"
            },
            {
              "name": "Department Top Three Salaries",
              "slug": "department-top-three-salaries",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/department-top-three-salaries/"
            },
            {
              "name": "Human Traffic of Stadium",
              "slug": "human-traffic-of-stadium",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/human-traffic-of-stadium/"
            },
            {
              "name": "Market Analysis II",
              "slug": "market-analysis-ii",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/rank-scores/"
            },
            {
              "name": "Product Price at a Given Date",
              "slug": "product-price-at-a-given-date",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/product-price-at-a-given-date/"
            },
            {
              "name": "Game Play Analysis V",
              "slug": "game-play-analysis-v",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/game-play-analysis-iv/"
            },
            {
              "name": "Active User Retention",
              "slug": "user-retention",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/user-retention"
            },
            {
              "name": "Y-on-Y Growth Rate",
              "slug": "yoy-growth-rate",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/yoy-growth-rate"
            },
            {
              "name": "Repeated Payments",
              "slug": "repeated-payments",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/repeated-payments"
            },
            {
              "name": "Server Utilization Time",
              "slug": "total-utilization-time",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/total-utilization-time"
            },
            {
              "name": "Median Google Search Frequency",
              "slug": "median-search-freq",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/median-search-freq"
            },
            {
              "name": "Advertiser Status",
              "slug": "updated-status",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/updated-status"
            },
            {
              "name": "3-Topping Pizzas",
              "slug": "pizzas-topping-cost",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/pizzas-topping-cost"
            },
            {
              "name": "Maximize Prime Item Inventory",
              "slug": "prime-warehouse-storage",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/prime-warehouse-storage"
            },
            {
              "name": "International Call Percentage",
              "slug": "international-call-percentage",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/international-call-percentage"
            },
            {
              "name": "Department vs. Company Salary",
              "slug": "sql-department-company-salary",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/sql-department-company-salary"
            },
            {
              "name": "Patient Support Analysis",
              "slug": "patient-support-analysis",
              "difficulty": "Hard",
              "link": "https://datalemur.com/questions/patient-support-analysis"
            }
          ],
          "learningTip": [
            "Top N per group: ROW_NUMBER() OVER(PARTITION BY group ORDER BY value DESC), then WHERE rn <= N",
            "Gaps and islands: Subtract row_number from the date/sequence. Consecutive items will have the same difference (the 'island' identifier).",
            "Month-over-month: Use LAG(value) OVER(ORDER BY month) to get previous month, then compute percentage change.",
            "Always test edge cases mentally: What if there's only one row? What if there are ties? What if the column has NULLs?"
          ],
          "mustNotMiss": [
            "Top N per group: WITH ranked AS (SELECT *, ROW_NUMBER() OVER(PARTITION BY dept ORDER BY sal DESC) rn FROM emp) SELECT * FROM ranked WHERE rn <= 3",
            "Consecutive sequences (islands): SELECT *, date - ROW_NUMBER() as grp gives same value for consecutive dates. GROUP BY grp to find sequences.",
            "Running total: SUM(amount) OVER(ORDER BY date ROWS UNBOUNDED PRECEDING)",
            "Median: Two approaches - (1) Use PERCENTILE_CONT(0.5) if available, or (2) ROW_NUMBER from both ends and find middle",
            "Handle NULLs explicitly: COALESCE(column, 0), or filter with WHERE column IS NOT NULL, depending on requirements"
          ],
          "interviewQuestions": [
            {
              "question": "Find the Nth highest salary without using LIMIT.",
              "answer": "Determine N-1 salaries greater than itself. (Inefficient). \nBetter: `SELECT Salary FROM (SELECT Salary, DENSE_RANK() OVER(ORDER BY Salary DESC) rnk FROM Emp) WHERE rnk = N`"
            },
            {
              "question": "Get top 3 products by sales in each category.",
              "answer": "Use Window Function: \n`RANK() OVER (PARTITION BY Category ORDER BY Sales DESC)` then filter `WHERE rank <= 3`."
            },
            {
              "question": "Find employees who have been promoted consecutively for 3 years.",
              "answer": "Use `LEAD()` or Self Joins to check: \n`Year(PromoteDate) == Year(Prev) + 1 == Year(PrevPrev) + 2`."
            },
            {
              "question": "Calculate month-over-month growth percentage.",
              "answer": "`((CurrentMonthRev - LAG(CurrentMonthRev)) / LAG(CurrentMonthRev)) * 100`"
            },
            {
              "question": "Find users who logged in on consecutive days.",
              "answer": "Calculate `gap = Date - ROW_NUMBER()`. If `gap` is constant for multiple rows, they are consecutive."
            },
            {
              "question": "Design a query to detect fraud patterns in transactions.",
              "answer": "Look for high velocity (many txns in 1 min), geographic impossible travel (US txn then China txn in 1 hr), or amount outliers (> 5x avg)."
            },
            {
              "question": "How would you find gaps in a sequence of IDs?",
              "answer": "Find where `ID + 1` does NOT exist in the table. \n`SELECT ID + 1 FROM Tbl t1 WHERE NOT EXISTS (SELECT 1 FROM Tbl t2 WHERE t2.ID = t1.ID + 1)`"
            }
          ]
        }
      ]
    }
  ],
  "recommendedHoursPerWeek": 3
}
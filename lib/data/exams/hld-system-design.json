{
  "id": "hld_system_design",
  "name": "High Level Design (System Design)",
  "description": "Comprehensive System Design course covering distributed systems, caching, load balancing, databases, microservices, and real-world case studies like Uber, Netflix, and WhatsApp. Master the art of designing scalable systems for FAANG interviews.",
  "category": "Computer Science",
  "totalEstimatedHours": 70,
  "stages": [
    {
      "id": "foundation",
      "name": "HLD Foundation Assessment",
      "totalMarks": 100,
      "duration": 180,
      "sections": [
        {
          "id": "fundamentals",
          "name": "System Design Fundamentals",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "caching_lb",
          "name": "Caching & Load Balancing",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "databases",
          "name": "Databases & Storage",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        },
        {
          "id": "distributed",
          "name": "Distributed Systems",
          "maxMarks": 25,
          "maxTime": 45,
          "negativeMarking": 0
        }
      ]
    },
    {
      "id": "advanced",
      "name": "Advanced HLD Assessment",
      "totalMarks": 150,
      "duration": 270,
      "sections": [
        {
          "id": "case_studies",
          "name": "Case Studies",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "microservices",
          "name": "Microservices Architecture",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        },
        {
          "id": "infra",
          "name": "Infrastructure Components",
          "maxMarks": 50,
          "maxTime": 90,
          "negativeMarking": 0
        }
      ]
    }
  ],
  "defaultSyllabus": [
    {
      "id": "system_design_fundamentals",
      "name": "System Design Fundamentals",
      "tier": 1,
      "estimatedHours": 4,
      "topics": [
        {
          "id": "system_design_devops_overview",
          "name": "System Design for DevOps - Overview",
          "estimatedHours": 2,
          "description": "Introduction to system design thinking - understanding how large-scale systems are built, deployed, and maintained. Learn the CI/CD mindset, containerization with Docker, and deployment strategies that enable zero-downtime releases.",
          "practiceQuestions": [
            {
              "name": "Design CI/CD Pipeline",
              "slug": "design-ci-cd-pipeline",
              "difficulty": "Medium",
              "link": "https://github.com/donnemartin/system-design-primer#ci-cd"
            }
          ],
          "learningTip": [
            "**Scalability vs Performance:** Performance = 'how fast for one user'. Scalability = 'how many users can it handle'. You can have a slow but scalable system.",
            "**Latency vs Throughput:** Latency = time for one request. Throughput = requests per second. A highway can have high throughput (many cars) but high latency (traffic jam).",
            "**Stateful vs Stateless:** Stateless (REST) scales horizontally easily. Stateful requires sticky sessions or db-storage.",
            "**Bottlenecks:** Always ask 'Where does it break?'. CPU? RAM? Network I/O? Disk I/O?"
          ],
          "mustNotMiss": [
            "**CI/CD Pipeline:** Commit → Build (Docker) → Test (Unit/Integration) → Deploy (K8s) → Monitor (Prometheus).",
            "**Deployment Strategies:** \n1. **Blue-Green:** Instant switch, zero downtime, simple rollback. Expensive (2x infra). \n2. **Canary:** Gradual rollout (1% -> 10% -> 100%). Low risk, slow.",
            "**Infrastructure as Code (IaC):** Terraform/Ansible. Treat infra like software (Version Control, Reproducible).",
            "**Docker vs VM:** Docker = OS virtualization (lighter). VM = Hardware virtualization (heavier)."
          ],
          "interviewQuestions": [
            {
              "question": "Design a CI/CD pipeline for a microservices architecture.",
              "answer": "**Pipeline:** \n1. **Code Commit:** Trigger Webhook. \n2. **Build:** Run lint, unit tests, build Docker Image. \n3. **Push:** Tag image (`v1.2.3`) & push to Registry (ECR/DockerHub). \n4. **Deploy Staging:** Update K8s manifest in Staging. Run Integration/E2E tests. \n5. **Deploy Prod:** Manual Approval → Canary Rollout (10% traffic) → Monitor Error Rate → 100% Rollout."
            },
            {
              "question": "Blue-Green vs Canary Deployment - when to use which?",
              "answer": "**Blue-Green:** Use when you need **Instant Rollback** capability or strict zero-downtime requirements for major changes. Requires 2x budget. \n\n**Canary:** Use for **High-Risk** changes where you want to test on real users (A/B testing) without affecting everyone. Cheaper but slower."
            },
            {
              "question": "How do you handle database migrations with zero downtime?",
              "answer": "**Expand and Contract Pattern:** \n1. **Expand:** Add new column/table. Code writes to BOTH old & new (or purely optional). Deploy. \n2. **Migrate:** Backfill data from old to new. \n3. **Contract:** Deploy code to read/write ONLY new column. Remove old column."
            },
            {
              "question": "What is 'Configuration Drift' and how does IaC solve it?",
              "answer": "**Drift:** When servers in a cluster become different over time (manual updates, hotfixes). \n\n**IaC (Terraform):** Defines desired state in code. Running `terraform apply` forces all servers to match the code exactly, eliminating drift."
            },
            {
              "question": "Explain the concept of 'Immutable Infrastructure'.",
              "answer": "Never patch/update a running server. \n\n**Update:** Build new VM/Container image with updates deployed → Replace old one. \n\n**Benefit:** Predictable, easy to rollback, no 'works on my machine' issues."
            }
          ],
          "resources": [
            "https://bytebytego.com/courses/system-design-interview/scale-from-zero-to-millions-of-users",
            "https://github.com/donnemartin/system-design-primer#ci-cd"
          ]
        },
        {
          "id": "computer_networks_101",
          "name": "System Design and Computer Networks 101",
          "estimatedHours": 2,
          "description": "Master networking fundamentals that underpin all distributed systems - OSI model, TCP/IP, DNS resolution, HTTP/HTTPS, and how data flows from browser to server.",
          "practiceQuestions": [
            {
              "name": "What happens when you type google.com",
              "slug": "what-happens-google",
              "difficulty": "Medium",
              "link": "https://github.com/alex/what-happens-when"
            }
          ],
          "learningTip": [
            "**Latency Numbers:** Memorize these! L1 Cache (0.5ns) << RAM (100ns) << SSD (150us) << Network (150ms).",
            "**Bandwidth vs Latency:** You can stream Netflix (High Bandwidth) but lag in gaming (High Latency).",
            "**OSI Model:** Interviewers ask about L4 (Transport - TCP/UDP) and L7 (Application - HTTP). L4 LB is fast, L7 LB is smart.",
            "**DNS:** It's a hierarchy. Root (.) -> TLD (.com) -> Authoritative (google.com). Highly cached."
          ],
          "mustNotMiss": [
            "**TCP Handshake:** SYN → SYN-ACK → ACK. (3-Way). Reliable, Ordered, but Slower.",
            "**UDP:** 'Fire and Assume'. No handshake. Fast. Used for Video/Gaming/DNS.",
            "**HTTP/1.1 vs HTTP/2:** Text vs Binary. 1.1 has Head-of-Line blocking. 2.0 has Multiplexing.",
            "**HTTPS:** Uses TLS/SSL. Handshake is expensive (RSA/ECDHE). Session Resumption speeds it up.",
            "**Anycast DNS:** Route to 'closest' IP via BGP. Critical for CDN performance."
          ],
          "interviewQuestions": [
            {
              "question": "TCP vs UDP: Deep check.",
              "answer": "**TCP:** Connection-Oriented, Reliable (Ack/Retransmit), Flow Control (Window), Ordered. **Use:** Web, Email, File Transfer. \n\n**UDP:** Datagram, Unreliable (packet loss ok), No Flow Control, Unordered. **Use:** Real-time (VoIP, FPS Gaming), Broadcasting, DNS."
            },
            {
              "question": "How does HTTPS overhead impact latency and how to minimize it?",
              "answer": "**Overhead:** 2 RTT (Round Trip Time) for initial Handshake. \n\n**Optimization:** \n1. **TLS 1.3:** Reduces to 1 RTT (or 0-RTT for resumption). \n2. **Session Resumption:** Reuse session ID/tickets to skip full handshake. \n3. **OCSP Stapling:** Server sends cert status, saving client a lookup."
            },
            {
              "question": "What happens when you type google.com? (Deep Dive)",
              "answer": "1. **DNS:** Browser Cache -> OS -> ISP -> Root -> TLD -> Authoritative -> IP. \n2. **TCP:** 3-Way Handshake with IP. \n3. **TLS:** Key Exchange (HTTPS). \n4. **HTTP:** Client sends `GET /`. \n5. **Server:** LB -> Web Server -> App Server -> DB. \n6. **Response:** HTML/CSS/JS. Browser renders DOM."
            },
            {
              "question": "Explain HTTP/2 Multiplexing.",
              "answer": "**Problem in 1.1:** Browser opens 6 TCP connections. Requests are serial per connection (Head-of-Line Blocking). \n\n**HTTP/2:** Single TCP connection. Break requests into **Frames**. Interleave frames (Stream 1 chunk, Stream 2 chunk...). Reassemble at destination. No blocking."
            },
            {
              "question": "What is a 'Sticky Session' in Load Balancing?",
              "answer": "**Concept:** LB routes all requests from User A to Server X using a Cookie or IP Hash. \n\n**Pros:** easy to use local RAM cache. \n\n**Cons:** Uneven load (if User A is heavy), pain to auto-scale (removing Server X breaks session). **Avoid if possible; use Redis for shared state.**"
            }
          ],
          "resources": [
            "https://github.com/alex/what-happens-when",
            "https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/"
          ]
        }
      ]
    },
    {
      "id": "load_balancing_caching",
      "name": "Load Balancing & Caching",
      "tier": 1,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "load_balancing_consistent_hashing",
          "name": "Load Balancing and Consistent Hashing",
          "estimatedHours": 2,
          "description": "Learn how to distribute traffic across servers using load balancers. Master consistent hashing - the algorithm that powers distributed caches and databases.",
          "practiceQuestions": [
            {
              "name": "Design Consistent Hashing",
              "slug": "consistent-hashing",
              "difficulty": "Hard",
              "link": "https://leetcode.com/discuss/interview-question/system-design/125751/consistent-hashing"
            }
          ],
          "learningTip": [
            "**L4 vs L7:** L4 is a 'dumb' packet forwarder (IP/Port). L7 is 'smart' (HTTP Headers/Cookies). L7 is CPU intensive (SSL Termination).",
            "**Consistent Hashing:** Visualize a Ring. Nodes are points. Keys are points. Key maps to next node clockwise. Adding node = stealing keys from neighbor.",
            "**Virtual Nodes:** The trick to fix uneven distribution. 1 Physical Node = 100 Virtual points on ring.",
            "**Health Checks:** Passive (monitor 5xx rates) is better than Active (ping) for high-scale systems."
          ],
          "mustNotMiss": [
            "**Algorithms:** Round Robin (stateless), Least Connections (stateful), IP Hash (stickiness), Consistent Hashing (distributed).",
            "**Sticky Sessions:** Avoid if possible. Breaks auto-scaling. Use Redis for session state instead.",
            "**SSL Termination:** Decrypt at LB, send plain HTTP to backend. Saves backend CPU.",
            "**Single Point of Failure:** LB itself! Use Active-Passive (Keepalived/VRRP)."
          ],
          "interviewQuestions": [
            {
              "question": "L4 vs L7 Load Balancing: Deep Dive",
              "answer": "**L4 (Transport):** Routes by IP+Port. Packet-level. Fast. No inspection. \n**L7 (Application):** Routes by URL, Cookie, Header. SSL Termination. Slow (~10x slower than L4). \n*Use Case:* L7 for Microservices routing (`/billing` -> BillingSvc). L4 for raw TCP throughput."
            },
            {
              "question": "How does Consistent Hashing minimize churn?",
              "answer": "**Problem:** `hash(key) % N`. If N changes, nearly 100% keys move. \n**Solution:** Map keys & nodes to a 0-360° Ring. Key maps to next node. \n**Result:** Adding a node only takes keys from *one* neighbor. Only `K/N` keys move. Critical for Distributed Caches (DynamoDB, Cassandra, Memcached)."
            },
            {
              "question": "What is the 'Thundering Herd' problem at the LB level?",
              "answer": "When many processes wake up to handle one event (e.g., a socket becoming readable). \n*Modern Context:* 10,000 clients retrying simultaneously after a service outage, DDOS-ing the recovery. \n**Fix:** Exponential Backoff + Jitter."
            },
            {
              "question": "Explain 'Virtual Nodes' in Consistent Hashing.",
              "answer": "**Problem:** With few nodes (A, B, C), random distribution might give Node A 50% of ring (Hotspot). \n**Solution:** Hash Node A 100 times (`A_1, A_2... A_100`) and place on ring. \n**Benefit:** Statistically uniform distribution of keys even with few physical nodes."
            },
            {
              "question": "How to handle LB failure?",
              "answer": "**Floating IP (VIP) + Heartbeat:** \nTwo LBs (Active/Passive). \nActive owns VIP. Passive checks heartbeat. \nIf Active dies, Passive uses ARP spoofing/BGP to claim VIP."
            }
          ],
          "resources": [
            "https://www.nginx.com/resources/glossary/load-balancing/",
            "https://www.youtube.com/watch?v=re95eWf6rZ0"
          ]
        },
        {
          "id": "caching_cdn_backend",
          "name": "Caching: CDN + Backend Caches, Cache Invalidation",
          "estimatedHours": 2,
          "description": "Deep dive into caching strategies - the most effective way to improve performance. Learn CDN architecture, Redis patterns, and how to handle cache stampede.",
          "practiceQuestions": [
            {
              "name": "LRU Cache",
              "slug": "lru-cache",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/lru-cache/"
            },
            {
              "name": "LFU Cache",
              "slug": "lfu-cache",
              "difficulty": "Hard",
              "link": "https://leetcode.com/problems/lfu-cache/"
            }
          ],
          "learningTip": [
            "**Cache-Aside (Lazy):** App -> Cache. If miss, App -> DB -> Cache. Most common. Safe.",
            "**Read-Through:** App -> Cache. If miss, Cache -> DB -> Cache. App doesn't touch DB.",
            "**In-Memory vs Distributed:** Local Map (Fastest, not shared) vs Redis (Fast, Shared).",
            "**Eviction:** How to choose what to delete when full? LRU (Recency) is standard. LFU (Frequency) is smarter but heavier."
          ],
          "mustNotMiss": [
            "**Cache Penetration:** Keys that *don't exist* anywhere hitting DB. Fix: Bloom Filter / Cache NULLs.",
            "**Cache Breakdown:** Hot key expires -> 1000 reqs hit DB. Fix: Mutex / Logical Expiry.",
            "**Cache Avalanche:** Many keys expire at once -> DB overload. Fix: Randomize TTL.",
            "**Write-Through vs Back:** Through = Safe (Synch). Back = Fast (Async risk)."
          ],
          "interviewQuestions": [
            {
              "question": "Cache Penetration vs Breakdown vs Avalanche?",
              "answer": "**Penetration:** Requesting *non-existent* data (e.g. ID=-1). Hits DB every time. \n*Fix:* **Bloom Filter** or cache empty object with short TTL. \n\n**Breakdown:** HOT key expires. Concurrent reqs hit DB. \n*Fix:* **Mutex Lock** (only 1 proc fetches) or 'Logical Expiration' (soft expire). \n\n**Avalanche:** massive number of keys expire same time. \n*Fix:* **Jitter** (Randomize TTLs)."
            },
            {
              "question": "How to keep Cache in sync with DB?",
              "answer": "1. **TTL:** Eventual consistency (simplest). \n2. **Double Delete:** Delete Cache -> Update DB -> Delete Cache again (catch race conditions). \n3. **CDC (Change Data Capture):** Debezium reads DB logs -> Updates Cache asynchronously (Robust)."
            },
            {
              "question": "Design a Distributed Rate Limiter.",
              "answer": "**Token Bucket Algo in Redis:** \nUse `INCR` and `EXPIRE`. \nKey: `user_id:minute`. Value: counter. \nIf `INCR > limit`, reject. \n*Advanced:* Use **Redis Lua Script** to ensure atomicity of check-and-decrement."
            },
            {
              "question": "Redis vs Memcached?",
              "answer": "**Redis:** Data Structures (Lists, Sets, Maps), Persistence (RDB/AOF), Replication/Cluster, Single-Threaded. \n\n**Memcached:** Simple Key-Value, Multi-Threaded (better vertical scale), Volatile only. \n*Default choice:* Redis."
            },
            {
              "question": "What is 'Cache Stampede' and how to solve it?",
              "answer": "Same as Cache Breakdown. \n\n**Probabilistic Early Recomputation:** \n`if (now() + random_gap() > expiry) { recompute_in_background(); }` \nThis prevents all threads from noticing the expiry at the exact same millisecond."
            }
          ],
          "resources": [
            "https://redis.io/docs/management/persistence/",
            "https://research.facebook.com/publications/memcached-at-facebook/"
          ]
        },
        {
          "id": "case_study_leaderboard",
          "name": "Case Study: Contest Leaderboard",
          "estimatedHours": 2,
          "description": "Apply caching to design a real-time leaderboard. Handle millions of concurrent users with Redis Sorted Sets.",
          "practiceQuestions": [
            {
              "name": "Top K Frequent Elements",
              "slug": "top-k-frequent-elements",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/top-k-frequent-elements/"
            }
          ],
          "learningTip": [
            "**Data Structure:** Redis Sorted Set (ZSET) is the only viable answer for real-time ranking.",
            "**Complexity:** ZADD is O(log N). Sorting 1M users in SQL is O(N log N) - too slow.",
            "**Partitioning:** Global leaderboard for 1B users isn't possible on one machine. Shard by UserID? No, can't sort. Shard by Score Range! (1-1000, 1001-2000).",
            "**Ties:** Timestamp tie-breaker is standard interview pattern."
          ],
          "mustNotMiss": [
            "**ZSET Implementation:** Skip List (multi-layer linked list). Probabilistic balance.",
            "**Relative Rank:** `ZINCRBY` is atomic. No race conditions on score updates.",
            "**Batch Updates:** Don't update Redis on every kill. Buffer in app, flush every 5s.",
            "**Scatter-Gather:** If sharding by UserID, you must query Top 10 from ALL shards and merge."
          ],
          "interviewQuestions": [
            {
              "question": "What is the underlying data structure of Redis ZSET?",
              "answer": "**Skip List** + **Hash Map**. \n**Map:** Maps Member -> Score (O(1) lookup). \n**Skip List:** Maintains order. Layered linked list allowing O(log N) insertion/search. \n*Why not BST?* Skip lists are more memory efficient and simpler to implement concurrently."
            },
            {
              "question": "System Design: Real-time Game Leaderboard",
              "answer": "1. **Ingest:** Game server sends `updateScore(user, points)` to Kafka. \n2. **Process:** Worker consumes Kafka, buffers updates (5s window). \n3. **Storage:** Redis ZSET `ZINCRBY leaderboard points user`. \n4. **Read:** Client polls/WebSocket for `ZREVRANGE 0 10`. \n5. **Persistence:** Redis AOF + Weekly Snapshot to SQL."
            },
            {
              "question": "How to handle 100 Million daily active users?",
              "answer": "**Sharding:** Single Redis can handle ~100k ops/sec. For 100M: \n**Option A:** Partition by **Score Range** (Elite, Pro, Noob). Problem: Hotspot in 'Noob' tier. \n**Option B:** Partition by **User ID** (Total Sharding). To get Top 10, query ALL partitions (Scatter-Gather) and merge. Preferable."
            },
            {
              "question": "How to handle tie-breaking?",
              "answer": "If same score, user who got it *first* should be higher. \n**Decimal Implementation:** \n`StoredScore = TrueScore + (1 / timestamp)`. \nOr `Score = TrueScore.Timestamp`. (Requires floating point precision care)."
            },
            {
              "question": "Client-side: Polling vs WebSocket for updates?",
              "answer": "**Leaderboard:** Top 10 changes frequently. \n**Polling:** Good cacheability (CDN can cache `/top10` json). OK for 'Global Top 10'. \n**WebSocket:** Required for 'My Relative Rank' (e.g. You just passed User X!). Expensive connection maintenance."
            }
          ],
          "resources": [
            "https://redis.io/docs/data-types/sorted-sets/",
            "https://medium.com/swlh/system-design-real-time-leaderboard-architecture-8a4cb751509f"
          ]
        }
      ]
    },
    {
      "id": "news_feed_design",
      "name": "News Feed Design",
      "tier": 2,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "facebook_news_feed",
          "name": "Case Study: Facebook News Feed",
          "estimatedHours": 2,
          "description": "Design Facebook News Feed - understand Fan-out problem, Push vs Pull models, and handling celebrity users.",
          "practiceQuestions": [
            {
              "name": "Design Twitter",
              "slug": "design-twitter",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-the-twitter-timeline-and-search"
            }
          ],
          "learningTip": [
            "**Fan-out:** The core problem. 1 user posts -> 10M followers. Do you write 10M times (Push) or read 10M times (Pull)?",
            "**Hybrid:** The solution. Push for normal users. Pull for celebrities (Justin Bieber).",
            "**Feed Generation:** Don't generate on-the-fly. Pre-compute 'Home Timeline' and store in Redis List."
          ],
          "mustNotMiss": [
            "**Push (Write-Heavy):** User posts -> Write ID to all followers' timeline. **Pro:** Fast Read. **Con:** Slow Write (Fan-out).",
            "**Pull (Read-Heavy):** User loads feed -> Fetch followees' recent posts -> Merge. **Pro:** Fast Write. **Con:** Slow Read.",
            "**Celebrity Issue:** Push fails for 10M followers. Use Pull for them.",
            "**Global Hotspot:** Don't shard by 'Post ID' if everyone reads the same viral post. Cache it everywhere."
          ],
          "interviewQuestions": [
            {
              "question": "Deep Dive: Hybrid Fan-out Architecture.",
              "answer": "1. **Normal User Posts:** Push ID to all followers' Redis Lists. \n2. **Celebrity Posts:** Write to Celebrity's own 'Outbox' only. \n3. **User Reads Feed:** \n   - Fetch from their Redis List (Normal posts). \n   - Fetch from 'Outbox' of celebrities they follow. \n   - Merge & Sort by Time."
            },
            {
              "question": "How to generate 'Relevance' or 'Recommended' feed?",
              "answer": "**Machine Learning Pipeline:** \n1. **Candidate Generation:** Filter 1B posts to 1000 candidates (via collaborative filtering / tags). \n2. **Ranking:** Score each candidate (P(Click) * Value). \n3. **Re-Ranking:** Remove duplicates, NSFW, ensure diversity. \n4. **Serve:** Return Top 20."
            },
            {
              "question": "Data Storage for Feed?",
              "answer": "**Metadata (User -> Post IDs):** Cassandra/ScyllaDB (Wide column, time-ordered). \n**Content (Text/Image):** S3 + CDN. \n**Cache:** Redis Cluster (Sharded by UserID)."
            },
            {
              "question": "How to handle 'Unfollow' in Push Model?",
              "answer": "**Lazy Removal:** Don't scan 1000 items in Redis to remove 1 ID. \n- Just remove the 'Follow' relation in DB. \n- When User reads feed, app checks 'Am I still following author?' -> If no, discard item on the fly."
            },
            {
              "question": "Pull vs Push Latency comparison?",
              "answer": "**Push:** Write latency depends on follower count (Async Task Queue). Read latency is O(1) (Fetch Redis List). \n**Pull:** Write latency is O(1). Read latency is O(Followings) (Fan-in DB queries). **Push wins for user experience (Read-heavy).**"
            }
          ],
          "resources": [
            "https://info.crunchydata.com/blog/designing-a-news-feed-system-postgresql-redis",
            "https://neo4j.com/blog/designing-social-news-feed-graph-database/"
          ]
        },
        {
          "id": "news_feed_caching",
          "name": "Facebook News Feed - Caching Deep Dive",
          "estimatedHours": 2,
          "description": "Deep dive into feed caching - separating metadata from content, cache invalidation for social graphs.",
          "practiceQuestions": [
            {
              "name": "Design Instagram",
              "slug": "design-instagram",
              "difficulty": "Hard",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG"
            }
          ],
          "learningTip": [
            "**Separation of Concern:** Feed Service (List of IDs) vs Content Service (Text/Media).",
            "**Pagination:** Never use OFFSET/LIMIT. Use Cursor (last_id) to avoid shifting results.",
            "**Cache Warming:** If cache misses, don't just fetch from DB. Trigger a 'Rebuild Feed' job and return 'Loading' or 'Stale' data."
          ],
          "mustNotMiss": [
            "**Metadata Store:** (Redis/Cassandra) stores `[PostID, Timestamp]`. Light-weight.",
            "**Blob Store:** (S3/CDN) stores content. Heavy.",
            "**Cursor Pagination:** `WHERE id < last_seen_id ORDER BY id DESC LIMIT 10`. O(1).",
            "**Thundering Herd:** If Celebrity posts, millions read at once. Cache the CONTENT object at Edge (CDN) and local memory."
          ],
          "interviewQuestions": [
            {
              "question": "Why separate Metadata from Content?",
              "answer": "**Performance:** \n- Fetching list of 20 IDs + timestamps is tiny (2KB). \n- Fetching 20 full posts (Images/Text) is huge (5MB). \n**UX:** Allows lazy loading. Render skeletons immediately while content hydrates in parallel."
            },
            {
              "question": "How to implement Cursor-based Pagination?",
              "answer": "Client requests: `GetFeed(limit=10)`. Server returns 10 items + `next_cursor='id_10'`. \nClient requests: `GetFeed(limit=10, after='id_10')`. \nServer Query: `SELECT * FROM Feed WHERE id < 'id_10' ORDER BY id DESC LIMIT 10`. \n**Benefit:** Efficient stable pagination even if new posts arrive."
            },
            {
              "question": "Design Cache invalidation for Social Graph changes (Friend/Unfriend).",
              "answer": "**Graph DB (Neo4j/Tao):** \nWhen A unfriends B: \n1. Update Graph DB edge. \n2. Invalidate 'Followers List' cache for B. \n3. Fan-out removal of B's posts from A's Timeline Cache."
            },
            {
              "question": "How do you handle 'Viewed' status state?",
              "answer": "Don't write to DB every time user scrolls. \n**Batching:** Client sends `[id1, id2, id3]` viewed every 5s. \nServer aggregates in Redis BitSet or Bloom Filter. \nAsync flush to Analytics DB (ClickHouse) for ML training."
            }
          ],
          "resources": [
            "https://engineering.fb.com/2013/06/25/core-data/tao-the-power-of-the-graph/",
            "https://meta.com/save/facebook-news-feed-architecture/"
          ]
        },
        {
          "id": "messaging_apps",
          "name": "Case Study: Messaging Apps (WhatsApp, Slack)",
          "estimatedHours": 2,
          "description": "Design messaging systems - real-time delivery, message ordering, read receipts, and handling group chats.",
          "practiceQuestions": [
            {
              "name": "Design Chat System",
              "slug": "design-chat-system",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-chat-messenger"
            }
          ],
          "learningTip": [
            "**Protocol:** WebSocket for real-time (TCP, persistent). HTTP long-polling is fallback.",
            "**Storage:** Write-heavy. RDBMS fails at scale. Use Wide-Column (Cassandra/Scylla) or LSM-tree based DB.",
            "**Reliability:** Store-and-Forward. If user offline, store in 'Unread' bucket."
          ],
          "mustNotMiss": [
            "**WebSocket:** Stateful connection. Need 'Gateway Service' to track which user is on which server.",
            "**Sequence ID:** Timestamps are bad (clock skew). Use Discord Snowflake or Local Counter per Chat.",
            "**Group Chat:** Don't duplicate message 1000 times. Store 1 copy. Users allow pointer/cursor.",
            "**Encryption:** E2E (Signal Protocol). Server can't read messages."
          ],
          "interviewQuestions": [
            {
              "question": "Data Model for 1 Billion Messages/Day?",
              "answer": "**Cassandra / ScyllaDB:** \n`PartitionKey: ChatID`. `ClusteringKey: MessageID`. \nEnsures all messages for a chat are stored together on disk. Fast range scans (`WHERE chat_id=X AND msg_id > Y`)."
            },
            {
              "question": "WebSocket Scaling Logic?",
              "answer": "**Stateful Cluster:** \n1. User connects to `Gateway-1`. \n2. `Gateway-1` stores mapping `UserA -> Gateway-1` in Redis. \n3. When `UserB` sends msg to `UserA`, router checks Redis, finds `Gateway-1`, forwards msg to that server. \n4. `Gateway-1` pushes to `UserA` socket."
            },
            {
              "question": "How to optimize Group Chat (10k users)?",
              "answer": "Don't push to 10k sockets immediately (CPU spike). \n**Batching:** Store message to DB. \n**Pull Notification:** Send lightweight 'New Message' signal to online users. \n**Long Polling:** Users fetch batch of 50 new msgs."
            },
            {
              "question": "Implement 'Sent', 'Delivered', 'Read'.",
              "answer": "1. **Sent:** Client gets ACK from Server. \n2. **Delivered:** Recipient Client sends ACK to Server -> Server pushes to Sender. \n3. **Read:** Recipient opens chat. Client sends `ReadReceipt(LastID=50)`. Server updates `LastReadMap`. Pushes to Sender."
            },
            {
              "question": "Handling 'Typing...' indicators?",
              "answer": "Ephemeral. Don't store in DB. \nUse Redis Pub/Sub or WebSocket broadcast. \nClient throttling: Send 'Typing' event max once every 2s to save bandwidth."
            }
          ],
          "resources": [
            "https://discord.com/blog/how-discord-stores-billions-of-messages",
            "https://engineering.fb.com/2018/11/15/tech-talks/designing-whatsapp/"
          ]
        }
      ]
    },
    {
      "id": "database_fundamentals",
      "name": "Database & Distributed Systems",
      "tier": 2,
      "estimatedHours": 10,
      "topics": [
        {
          "id": "cap_pacelc_replication",
          "name": "CAP / PACELC Theorem + Master-Slave Replication",
          "estimatedHours": 2,
          "description": "Understand fundamental trade-offs in distributed systems through CAP and PACELC theorems. Learn replication strategies.",
          "practiceQuestions": [
            {
              "name": "Distributed Systems",
              "slug": "distributed-systems",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#cap-theorem"
            }
          ],
          "learningTip": [
            "**Partition Tolerance:** It's not optional. Network partitions WILL happen. You must choose AP or CP.",
            "**PACELC:** The practical extension of CAP. Even when system is running normally (Else), you trade Latency for Consistency.",
            "**Split Brain:** The nightmare scenario where two nodes both think they are Master. Solved by Quorum (Majority vote).",
            "Fencing Tokens: Ensure that a zombie master cannot write to storage."
          ],
          "mustNotMiss": [
            "**Quorum:** `R + W > N`. Ensures you read the latest write. Standard is `N=3, W=2, R=2`.",
            "**Eventual Consistency:** 'Gossip Protocol' spreads updates. Reads might be stale for milliseconds.",
            "**Availability:** Measured in 9s (99.99% = 52 mins downtime/year).",
            "**Sloppy Quorum:** Write to *any* 3 nodes (even if not owning the key) to stay Available (AP)."
          ],
          "interviewQuestions": [
            {
              "question": "Explain PACELC with examples.",
              "answer": "**CAP** is too simple. \n**PACELC** says: \nIf Partition (P), choose A or C. \nElse (E), choose **L**atency or **C**onsistency. \n\n*Example:* **DynamoDB** is PA/EL. (Prioritizes Availability during partition, and Low Latency during normal ops -> Eventual Consistency). \n**MySQL Cluster** is PC/EC. (Prioritizes Consistency always)."
            },
            {
              "question": "How do you prevent Split Brain?",
              "answer": "**Quorum & Fencing.** \n1. **Quorum:** To be leader, you need votes from `N/2 + 1` nodes. In a 5-node cluster, you need 3. If network splits 2 vs 3, the side with 2 cannot elect a leader. \n2. **Fencing Token:** Leader gets a monotonically increasing ID. Storage rejects writes from older IDs (Zombies)."
            },
            {
              "question": "What is 'Sloppy Quorum' (Hinted Handoff)?",
              "answer": "Used in **AP** systems (Cassandra/Dynamo). \nIf the 3 nodes responsible for Key K are down, write to *any* healthy node (with a note 'Please give this to Node X later'). \n*Benefit:* High Availability. \n*Cost:* Data is temporarily misplaced (Hinted Handoff)."
            },
            {
              "question": "Strong vs Eventual Consistency?",
              "answer": "**Strong (Linearizability):** Once a write is acked, ALL subsequent reads see it. (Ref: Bank Balance). \n**Eventual:** Writes will propagate. Reads *might* be stale for a window. (Ref: Facebook Likes)."
            },
            {
              "question": "How does Master-Slave Replication handle lag?",
              "answer": "Async replication = Lag is inevitable. \n**Implication:** User writes to Master, immediately reads from Slave -> Data missing (**Read-Your-Writes** problem). \n**Fix:** Sticky Session (read from Master for X seconds after write) or Versioning."
            }
          ],
          "resources": [
            "https://www.cs.umd.edu/~abadi/papers/abadi-pacelc.pdf",
            "https://martinfowler.com/articles/patterns-of-distributed-systems/quorum.html"
          ]
        },
        {
          "id": "sql_vs_nosql_sharding",
          "name": "SQL vs NoSQL + Sharding",
          "estimatedHours": 2,
          "description": "Deep comparison of SQL and NoSQL - when to use which, ACID vs BASE, and horizontal scaling with sharding.",
          "practiceQuestions": [
            {
              "name": "Design Database Schema",
              "slug": "design-database",
              "difficulty": "Medium",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview/mEN8lJXV1LA"
            }
          ],
          "learningTip": [
            "**ACID vs BASE:** SQL guarantees validity (ACID). NoSQL guarantees Uptime (Basically Available, Soft state, Eventual consistency).",
            "**Key-Value (Redis/Dynamo):** O(1) fetch. opaque blobs. No joins.",
            "**Document (Mongo):** Flexible JSON. Indexing on fields. Good for CMS/Catalogs.",
            "**Wide-Column (Cassandra):** 2D Key-Value map. Write-heavy time-series data."
          ],
          "mustNotMiss": [
            "**Polyglot Persistence:** Use the right tool. SQL for billing, Mongo for catalog, Redis for cache, Cassandra for logs.",
            "**Normalization:** SQL (Reduce redundancy). **Denormalization:** NoSQL (Duplicate data to avoid read-time joins).",
            "**Sharding:** Scaling horizontally. The 'Shard Key' is the most critical decision."
          ],
          "interviewQuestions": [
            {
              "question": "SQL vs NoSQL: How to decide?",
              "answer": "**Choose SQL:** Relations are core (Social Graph, Billing). ACID is non-negotiable (Finance). Structured data. \n**Choose NoSQL:** \n1. **Scale:** Need >10k writes/sec (Cassandra). \n2. **Flexibility:** Schema changes frequently (Catalog). \n3. **Volume:** Petabytes of logs/IoT data."
            },
            {
              "question": "Explain 'Polyglot Persistence'.",
              "answer": "Modern apps don't use just one DB. \n*E-commerce Example:* \n- **Postgres:** Orders/Payments (ACID). \n- **MongoDB:** Product Catalog (Flexible Schema). \n- **Redis:** Cart/Session (Speed). \n- **ElasticSearch:** Search (Fuzzy matching)."
            },
            {
              "question": "Document Store vs Wide-Column Store?",
              "answer": "**Document (MongoDB):** Data = JSON. Good for complex objects (User Profile). Flexible queries. CP (usually). \n**Wide-Column (Cassandra):** Data = Map<RowKey, Map<ColKey, Val>>. Optimized for **Writes** (Append-only). Query patterns must be known upfront. AP."
            },
            {
              "question": "What is the 'N+1 Problem' in ORMs?",
              "answer": "Fetching a list of Parents (N), then doing a query for each Parent (1) to get Children. \n*Result:* N+1 queries. \n*Fix:* **Batch Fetching** (`SELECT * FROM children WHERE parent_id IN (...)`)."
            },
            {
              "question": "Vertical vs Horizontal Scaling databases?",
              "answer": "**Vertical:** Bigger Instance (AWS RDS `db.m5.24xlarge`). Easy. No code change. Limit: Cost/Hardware. \n**Horizontal:** Sharding. Hard code changes. Relational Integrity breaks. Infinite scale."
            }
          ],
          "resources": [
            "https://www.dynamodbguide.com/what-is-dynamodb/",
            "https://cassandra.apache.org/_/index.html"
          ]
        },
        {
          "id": "database_orchestration",
          "name": "Database Orchestration & Shard Management",
          "estimatedHours": 2,
          "description": "Advanced database operations - resharding without downtime, directory vs hash-based sharding.",
          "practiceQuestions": [
            {
              "name": "Design Sharding",
              "slug": "design-sharding",
              "difficulty": "Hard",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview"
            }
          ],
          "learningTip": [
            "**Shard Key Selection:** High Cardinality (many values) + Uniform Distribution. Avoid `IsActive` (boolean) or Timestamp (sequential writes -> hotspot).",
            "**Directory-Based:** Flexible but lookup is bottleneck. Helper service says 'User X is on Shard 4'.",
            "**Hash-Based:** `Hash(ID) % N`. Uniform, but resizing is painful (Consistent Hashing helps)."
          ],
          "mustNotMiss": [
            "**Hot Shard:** When one shard gets too much data/traffic (e.g. Partition by 'Celebrity Name').",
            "**Scatter-Gather:** Query hitting all shards. High latency (wait for slowest shard). Avoid.",
            "**Sidecar Proxy:** Vitess/ProxySQL handles sharding logic transparently."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle a 'Celebrity Hotspot' in a sharded DB?",
              "answer": "If sharding by `User_ID`, Justin Bieber's shard melts. \n**Fix:** \n1. **Hybrid Schema:** Store celebrity data separately. \n2. **Read Replica:** Dedicate replicas just for reading celebrity posts. \n3. **Append Randomness:** Append `_1` to `_100` to Key, spread across shards (write). Aggregate on read."
            },
            {
              "question": "Design a globally distributed ID generator (Snowflake).",
              "answer": "**Twitter Snowflake:** generates unique 64-bit IDs sorted by time. \n**Structure:** \n- 1 bit: sign \n- 41 bits: Timestamp (millis) \n- 10 bits: Machine ID (Worker) \n- 12 bits: Sequence Num (Per millisecond). \n*Why?* DB primary keys often need to be roughly sortable by time."
            },
            {
              "question": "How to execute JOINs across shards?",
              "answer": "Database won't do it. \n**Approaches:** \n1. **App-Side Join:** Fetch IDs from Shard A. Query Shard B with `IN (ids)`. \n2. **Denormalization:** duplicate the `User.Name` into the `Orders` table so you don't need to join. \n3. **Binding:** Ensure related data (User + Their Orders) lives on same shard (Hierarchical Key)."
            },
            {
              "question": "Double-Write Migration Strategy?",
              "answer": "**Zero-Downtime Migration:** \n1. App writes to Old + New. \n2. Background script backfills missing data from Old to New. \n3. Verify consistency. \n4. Flip switch: App reads from New. \n5. Stop writing to Old."
            },
            {
              "question": "Directory vs Hash Sharding: Tradeoffs?",
              "answer": "**Directory:** (Map: ID 1-100 -> Shard A). \n*Pro:* Flexible, can move individual buckets. \n*Con:* Lookup DB is bottleneck/SPOF. \n**Hash:** (Hash(ID) % N). \n*Pro:* computed, no lookup. \n*Con:* Resharding requires moving massive data (use Consistent Hashing)."
            }
          ],
          "resources": [
            "https://vitess.io/docs/overview/concepts/",
            "https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake"
          ]
        },
        {
          "id": "nosql_internals",
          "name": "NoSQL Internals - LSM Tree and Multi-Master",
          "estimatedHours": 2,
          "description": "Understand NoSQL internals - LSM Trees for high write throughput, multi-master replication, conflict resolution.",
          "practiceQuestions": [
            {
              "name": "Design Key-Value Store",
              "slug": "key-value-store",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-key-value-store-for-a-search-engine"
            }
          ],
          "learningTip": [
            "**LSM Tree:** De-facto standard for Write-Heavy DBs (Cassandra, RocksDB). Appends to memory, flushes to disk. No random I/O.",
            "**Bloom Filter:** Probabilistic data structure. Tells you 'Definitely No' or 'Maybe Yes'. Saves disk lookups.",
            "**Compaction:** The 'Garbage Collection' of LSM trees. Merges files to reclaim space and remove deleted keys."
          ],
          "mustNotMiss": [
            "**Write Path:** WAL (Disk) -> MemTable (RAM) -> SSTable (Disk).",
            "**Read Path:** MemTable -> Block Cache -> Bloom Filter -> SSTable Index -> SSTable Data.",
            "**Tombstone:** You don't delete data in LSM. You write a 'Delete Marker'. Compaction removes it later.",
            "**Vector Clock:** Used in masterless systems to detect concurrent writes. `[NodeA:2, NodeB:1]` vs `[NodeA:1, NodeB:2]` = Conflict."
          ],
          "interviewQuestions": [
            {
              "question": "How does a Bloom Filter work?",
              "answer": "It's a bit-array. \n**Add(Key):** Hash key K times, set bits to 1. \n**Check(Key):** Hash key K times. \n- If any bit is 0 -> **Definitely Not Present** (Skip disk read). \n- If all bits are 1 -> **Maybe Present** (Read disk to confirm). \n*False positives possible, False negatives impossible.*"
            },
            {
              "question": "What happens if MemTable is full?",
              "answer": "1. It becomes **Immutable**. \n2. A new Mutable MemTable is created. \n3. The Immutable MemTable is flushed to disk as an **SSTable** (Sorted String Table). \n*During flush, machine can still accept writes.*"
            },
            {
              "question": "Conflict Resolution in Masterless (Gossip) Protocol?",
              "answer": "**Last Write Wins (LWW):** Compare timestamps. Discard older. Simple, but data loss risk if clocks skewed. \n**Vector Clocks:** Detect causality. If conflict (`A` didn't know about `B`), keep siblings and ask App to resolve on Read."
            },
            {
              "question": "Why is Read-Repair important in Cassandra?",
              "answer": "Cassandra is **Eventually Consistent**. \nOn Read (Quorum R=2): \nNode A says 'Val=5'. Node B says 'Val=4'. \nCoordinator sees timestamp of A > B. \n1. Returns '5' to client. \n2. **Background:** Sends '5' to Node B to fix staleness."
            },
            {
              "question": "B-Tree vs LSM Tree: Read/Write trade-off?",
              "answer": "**B-Tree (SQL):** Random Writes (slow), Fast Reads (Index structure perfectly balanced). \n**LSM (NoSQL):** Sequential Writes (super fast), Slower Reads (Check Memtable + multiple SSTables)."
            }
          ],
          "resources": [
            "https://rocksdb.org/docs/getting-started.html",
            "https://llimllib.github.io/bloomfilter-tutorial/"
          ]
        },
        {
          "id": "google_typeahead",
          "name": "Case Study: Google Typeahead (Search Autocomplete)",
          "estimatedHours": 2,
          "description": "Design search autocomplete - prefix matching with Tries, caching top-k queries, real-time updates.",
          "practiceQuestions": [
            {
              "name": "Search Suggestions System",
              "slug": "search-suggestions-system",
              "difficulty": "Medium",
              "link": "https://leetcode.com/problems/search-suggestions-system/"
            },
            {
              "name": "Design Autocomplete",
              "slug": "design-autocomplete",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-search-autocomplete"
            }
          ],
          "learningTip": [
            "**Data Structure:** Trie (Prefix Tree) is king. `Map<Char, Node>`. O(L) to find prefix.",
            "**Optimization:** Store 'Top 5 Searches' directly in the Trie Node. Don't traverse down.",
            "**Architecture:** Data collection (Logs -> Kafka -> Aggregator -> Trie Builder) is separate from Query Service.",
            "**State:** Trie is read-only in memory. Rebuild every hour/day."
          ],
          "mustNotMiss": [
            "**Trie:** Prefix-based lookups. Compressed Trie (Radix tree) saves space.",
            "**Cache:** Browser Cache (Client) -> CDN -> LB -> Redis -> Trie (In-Mem).",
            "**Sampling:** You can't aggregate ALL queries. Sample 1% of logs to determine 'Trending'.",
            "**Shadow Replication:** If server dies, rebuilding Trie takes time. Keep standby replicas."
          ],
          "interviewQuestions": [
            {
              "question": "How to optimize Typeahead for latency (Goal: <20ms)?",
              "answer": "1. **Browser Caching:** Cache results for 'app' for 1 hour. \n2. **CDN:** Serve static JSON for common prefixes ('a', 'ap', 'the'). \n3. **Pre-computed Trie:** Store `Top5` list in the node itself. Return immediately upon reaching the node. No DFS."
            },
            {
              "question": "How would you handle 'Trending' logic?",
              "answer": "**Streaming Pipeline:** \nLogs -> Kafka -> Flink/Spark Streaming. \nFlink counts frequency in 5-min sliding window. \nWrites heavily weighted scores to a separate 'Trending Redis'. \n**Query:** Merge Static Trie results + Trending Redis results."
            },
            {
              "question": "How to serialize a Trie for storage?",
              "answer": "Pickle/Protobuf to a file on S3. \n*Optimization:* Store as a flat array (succinct data structure) to map parent-child via index arithmetic, avoiding Pointer overhead (64-bit per pointer adds up)."
            },
            {
              "question": "How to handle spell check / fuzzy search?",
              "answer": "**Levenshtein Distance:** Too slow for real-time. \n**Approximation:** If Trie lookup fails, check keys with 1-char difference. \n**Better:** Use a pre-computed map of `Common Misspellings -> Correct Word`. (amazn -> amazon)."
            },
            {
              "question": "Back of envelope: Memory estimation?",
              "answer": "English language: ~500k words. \nAvg length: 6 chars. \nRaw text: 3MB. (Tiny). \n**BUT** Google scale: Search Phrases, not words. ~1 Billion phrases. \n1B * 20 bytes = 20GB. \nFits in RAM of 1 high-memory server (but use Sharding for CPU/Availability)."
            }
          ],
          "resources": [
            "https://medium.com/@prefixyteam/how-we-built-prefixy-a-scalable-typeahead-service-6a5e5311c9d8",
            "https://systemdesignprimer.com/design-typeahead"
          ]
        }
      ]
    },
    {
      "id": "message_queues_search",
      "name": "Message Queues & Search",
      "tier": 2,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "kafka_zookeeper",
          "name": "Message Queues - Apache Kafka & Zookeeper",
          "estimatedHours": 2,
          "description": "Master Kafka - the backbone of event-driven architectures. Understand topics, partitions, consumer groups, and exactly-once delivery.",
          "practiceQuestions": [
            {
              "name": "Design Message Queue",
              "slug": "design-message-queue",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-message-queue"
            }
          ],
          "learningTip": [
            "**Log-based Storage:** Kafka is not a queue (RabbitMQ). It's a distributed commit log. Messages persist on disk.",
            "**Throughput:** High throughput because of Sequential I/O (Append Only) and Zero-Copy (sendfile).",
            "**Ordering:** Guaranteed ONLY within a partition. Global ordering is impossible at scale."
          ],
          "mustNotMiss": [
            "**Topics & Partitions:** Topic = Table. Partition = Shard. Scaling unit.",
            "**Consumer Group:** The magic sauce. 1 Partition -> Only 1 Consumer in a group. Auto-balancing.",
            "**Offset Commits:** Async commit relies on 'At-least-once'. Sync commit is slow.",
            "**Lag:** The #1 metric to watch. (Production Rate - Consumption Rate)."
          ],
          "interviewQuestions": [
            {
              "question": "Kafka vs RabbitMQ?",
              "answer": "**Kafka:** Pull-based. Persists data (Log). High Throughput (Millions/sec). 'Dumb Broker, Smart Consumer'. Used for Event Streaming/Pipelines. \n**RabbitMQ:** Push-based. RAM-based (mostly). Low Latency. Complex Routing (Exchanges). 'Smart Broker'. Used for Task Queues."
            },
            {
              "question": "How to ensure Global Ordering in Kafka?",
              "answer": "You can't... unless you have **1 Partition**. \nBut 1 Partition = No concurrency. \n**Practical Answer:** You rarely need Global Ordering. You need **Key-Ordering** (e.g. All events for `User_123` are ordered). Use `UserID` as Partition Key."
            },
            {
              "question": "What is Consumer Rebalancing?",
              "answer": "When a new Consumer joins a Group (or one dies), Kafka pauses consumption and re-assigns partitions. \n**Stop-the-world event.** \n*Optimization:* Static Membership (avoid rebalance on transient restart)."
            },
            {
              "question": "Explain 'Zero Copy' optimization.",
              "answer": "Standard Send: Disk -> OS Page Cache -> App Buffer -> OS Socket Buffer -> NIC. (4 Copies). \n**Zero Copy (`sendfile`):** Disk -> OS Page Cache -> NIC. (2 Copies). \nKafka uses this to saturate 10Gbps networks with low CPU."
            },
            {
              "question": "Log Compaction (Key-Value use case)?",
              "answer": "Kafka keeps only the **latest value** for a Key. \nDeletes older versions. \nTurns Kafka into a distributed K-V store (used for restoring state on reboot)."
            }
          ],
          "resources": [
            "https://kafka.apache.org/documentation/#design",
            "https://www.confluent.io/blog/every-company-is-becoming-a-software-company/"
          ]
        },
        {
          "id": "elasticsearch",
          "name": "Case Study: ElasticSearch (Full Text Search)",
          "estimatedHours": 2,
          "description": "Design full-text search - inverted indexes, tokenization, fuzzy search, and relevance scoring.",
          "practiceQuestions": [
            {
              "name": "Design Search Engine",
              "slug": "design-search-engine",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-web-crawler"
            }
          ],
          "learningTip": [
            "**Inverted Index:** The heart of Search. Token -> List of DocIDs. Like the Index at back of a book.",
            "**Analysis Chain:** Char Filter (strip HTML) -> Tokenizer (split spaces) -> Token Filter (lowercase, stop words).",
            "**Scoring:** TF-IDF / BM25. Not just 'Found', but 'How Relevant?'."
          ],
          "mustNotMiss": [
            "**TF-IDF:** \n- TF: How often word appears in document. (Higher = Better). \n- IDF: How rare word is in corpus. (The, Is = Low. 'Platypus' = High).",
            "**Mapping:** Schema definition. Text vs Keyword. (Keyword = exact match, Text = full-text).",
            "**Sharding:** Similar to DBs. Primary Shards (Fixed) vs Replica Shards (Dynamic)."
          ],
          "interviewQuestions": [
            {
              "question": "How does an Inverted Index work?",
              "answer": "Instead of `Doc -> Words`, it maps `Word -> [Doc1, Doc5, Doc9]`. \n**Search 'apple':** Look up 'apple' in dictionary (O(1) or O(log N)). Return list of DocIDs. \n**Intersection:** Search 'apple' AND 'pie' -> Get list 1, list 2, find intersection."
            },
            {
              "question": "Explain TF-IDF and BM25.",
              "answer": "**TF (Term Frequency):** Count of term in doc. \n**IDF (Inverse Document Frequency):** Penalizes common words ('the', 'a'). \n**BM25:** Modern version of TF-IDF. \n- Saturation: TF curve flattens (100 times 'apple' isn't 100x better than 10 times). \n- Length Norm: Penalizes very long documents."
            },
            {
              "question": "Keyword vs Text data type?",
              "answer": "**Text:** Analyzed. 'Blue Box' -> `[blue, box]`. Searchable by 'blue'. \n**Keyword:** Exact. 'Blue Box' -> `Blue Box`. Only matches exact string. Used for Filtering/Aggregations (Tags, Status)."
            },
            {
              "question": "How to handle updates in ElasticSearch?",
              "answer": "**Documents are Immutable.** \nUpdate = Delete Old + Index New. \n(Lucene segments are write-once). \nFrequent updates cause 'Segment Merging' overhead. **ES is bad for frequently changing data.**"
            },
            {
              "question": "Near Real-Time (NRT) Search?",
              "answer": "ES is NRT (1 sec delay). \nWrites land in In-Memory buffer. \n**Refresh Interval (1s):** Buffer content written to a new Segment (OS Cache) and becomes searchable. \n*Flush:* Later synced to disk."
            }
          ],
          "resources": [
            "https://www.elastic.co/guide/en/elasticsearch/guide/current/how-search-works.html",
            "https://nlp.stanford.edu/IR-book/html/htmledition/scoring-term-weighting-and-the-vector-space-model-1.html"
          ]
        },
        {
          "id": "zookeeper_deep_dive",
          "name": "Zookeeper & Distributed Coordination",
          "estimatedHours": 2,
          "description": "Deep dive into Zookeeper - leader election, distributed locks, configuration management, and its role in distributed systems.",
          "practiceQuestions": [
            {
              "name": "Distributed Systems Coordination",
              "slug": "distributed-coordination",
              "difficulty": "Hard",
              "link": "https://zookeeper.apache.org/doc/current/recipes.html"
            }
          ],
          "learningTip": [
            "**Consistency Model:** Zookeeper provides Sequential Consistency. Updates from a client are applied in order.",
            "**ZAB Protocol:** Zookeeper Atomic Broadcast. The protocol used for Leader Election and data replication.",
            "**Heavy Reads, Light Writes:** optimized for 10:1 read:write ratio. All writes go to Leader (Bottleneck)."
          ],
          "mustNotMiss": [
            "**Ephemeral Nodes:** Delete automatically when client disconnects. Used for **Failure Detection**.",
            "**Sequential Nodes:** Append a monotonic number. Used for **Leader Election** (Is my ID the lowest?).",
            "**Watches:** Push notifications for changes. Avoids polling. Critical for configuration updates.",
            "**Quorum:** 2N+1 nodes. Tolerates N failures. Prevents **Split-Brain**."
          ],
          "interviewQuestions": [
            {
              "question": "How does Zookeeper handle Split-Brain?",
              "answer": "**Quorum (Majority Vote).** \n\nIf a cluster of 5 nodes splits into 2 and 3: \n\n- The partition with 2 nodes cannot form a quorum (2 < 3). It stops accepting writes. \n\n- The partition with 3 nodes continues. \n\n*Ensures only one history of truth.*"
            },
            {
              "question": "Why is Zookeeper performant for reads but slow for writes?",
              "answer": "**Writes:** Must go through Leader -> Replicated to Followers -> Ack by Quorum. Slow. \n\n**Reads:** Can be served by ANY follower locally. Fast. \n\n*Trade-off:* Reads might be slightly stale (Eventual Consistency), but `sync()` can force currency."
            },
            {
              "question": "Implement a Distributed Lock using Zookeeper.",
              "answer": "1. Create ephemeral sequential node `/lock/request-`.\n\n2. Get children. If my sequence is LOWEST, I have lock.\n\n3. If not, **Watch** the node immediately preceding me.\n\n4. When watched node is deleted, check again."
            },
            {
              "question": "What is the ZAB Protocol?",
              "answer": "**Zookeeper Atomic Broadcast.** \n\nSimilar to Raft/Paxos but specialized for primary-backup systems. \n\nTwo modes: **Recovery** (Leader Election) and **Broadcast** (Data Sync)."
            },
            {
              "question": "Use cases for Zookeeper vs Redis for coordination?",
              "answer": "**Zookeeper:** Strong Consistency (CP), Reliability, Complex Recipes (Locks/Election). Heavyweight. \n\n**Redis:** Fast, AP (mostly), Pub/Sub. Good for simple locks (Redlock) or rate limiting. Bad for mission-critical consensus."
            }
          ]
        }
      ]
    },
    {
      "id": "storage_location",
      "name": "Storage & Location Services",
      "tier": 2,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "s3_hdfs",
          "name": "Case Study: S3, HDFS (Large File Storage)",
          "estimatedHours": 2,
          "description": "Design large-scale blob storage - how S3 and HDFS store petabytes of data with replication and erasure coding.",
          "practiceQuestions": [
            {
              "name": "Design File Storage",
              "slug": "design-file-storage",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-file-storage-system"
            }
          ],
          "learningTip": [
            "**S3 (Object Storage):** HTTP API (PUT/GET). Flat namespace (Buckets). Eventual Consistency. Good for WORM (Write Once Read Many).",
            "**Block Storage (EBS):** Like a hard drive over network. Mountable. Fast/Low Latency. Expensive.",
            "**File Storage (EFS/NAS):** Tree structure. Shared access. Locking overhead."
          ],
          "mustNotMiss": [
            "**Erasure Coding (EC):** Break file into `n` data chunks + `k` parity chunks. Recover from `k` failures. Saves 50% storage vs Replication.",
            "**HDFS Federation:** Scale NameNode limits. Multiple NameNodes manage independent namespaces (Volumes).",
            "**Small File Problem:** HDFS hates millions of 1KB files (NameNode memory bloat). Use **HAR (Hadoop Archive)** or SequenceFiles.",
            "**Multipart Upload:** Break 5GB file into 100MB parts. Upload parallel. Retry individual failures."
          ],
          "interviewQuestions": [
            {
              "question": "Design Facebook's Photo Storage (Haystack/F4).",
              "answer": "**Problem:** Billions of small files (photos). Metadata bottleneck. \n\n**Haystack:** Pack small photos into one giant 100GB physical file. \n\n- **In-Memory Index:** Maps `PhotoID -> (FileID, Offset, Size)`. \n\n- **Single Disk Seek:** Read exactly where photo is."
            },
            {
              "question": "S3 Strong Consistency vs Eventual Consistency.",
              "answer": "Historically S3 was Eventual. Now **Strongly Consistent** (after 2020). \n\n- **Write:** When you get `200 OK` after PUT, the object is replicated and safe. \n\n- **List:** Listing bucket immediately reflects new keys."
            },
            {
              "question": "Compare Erasure Coding vs Replication.",
              "answer": "**Replication (3x):** \n- Cost: 300% storage. \n- Recovery: Fast (copy from neighbor). \n- Use: Hot Data. \n\n**Erasure Coding (RS 6,3):** \n- Cost: 150% storage. \n- Recovery: Slow (CPU compute to reconstruct). \n- Use: Cold/Warm Data."
            },
            {
              "question": "Design a 'Pastebin' (text storage service).",
              "answer": "1. **Write:** Client -> App Server -> Object Store (S3). Returns URL. \n2. **Key Generation:** KGS (Key Generation Service) produces 7-char unique strings. \n3. **DB:** Maps `ShortLink -> S3_Path`. \n4. **Optimization:** Cache popular pastes in Redis."
            },
            {
              "question": "How to optimize S3 upload speed/reliability?",
              "answer": "**Multipart Upload** + **Transfer Acceleration** (Use Edge Locations). \n\n- Split file into chunks. \n- Upload chunks in parallel. \n- Failed chunk? Retry just that chunk."
            }
          ]
        },
        {
          "id": "uber_location",
          "name": "Case Study: Uber (Nearest Neighbor Search)",
          "estimatedHours": 2,
          "description": "Design Uber - geospatial indexing with QuadTrees and Geohash, real-time location updates, driver matching.",
          "practiceQuestions": [
            {
              "name": "Design Uber",
              "slug": "design-uber",
              "difficulty": "Hard",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview/YQVkjp548NM"
            }
          ],
          "learningTip": [
            "**Geospatial Indexing:** Standard DBs (B-Trees) are 1D. Cannot index 2D (lat/long) efficiently. Need Spatial Index (R-Tree, QuadTree, Geohash).",
            "**Write-Heavy:** 10M drivers * update every 5s = 2M TPS. Requires massive write buffering (Kafka) or ephemeral storage (Redis).",
            "**Google S2:** The industry standard library for mapping 2D points to 1D integers (cell IDs)."
          ],
          "mustNotMiss": [
            "**QuadTree:** InMemory structure. Breaks world into 4 quadrants. Adaptive (Dense city = deep tree, Ocean = shallow). Hard to shard.",
            "**Geohash:** Base32 string. precision = length. `gcp` is inside `gc`. Easy to shard (just a string).",
            "**Google S2:** Uses Hilbert Curves. Keeps nearby points close on the 1D curve. Better than Geohash.",
            "**Sticky Connections:** Drivers maintain persistent WebSocket/TCP to Gateway for real-time updates."
          ],
          "interviewQuestions": [
            {
              "question": "QuadTree vs Geohash/S2 for Uber?",
              "answer": "**QuadTree:** \n- Pros: perfect precision, adaptive. \n- Cons: Hard to update (rebalancing), hard to persist/shard. \n\n**Geohash/S2:** \n- Pros: It's just a number/string. Easy to shard/index in DB. \n- Cons: Edge cases (two close points might have totally different hashes)."
            },
            {
              "question": "How to handle Driver Location Updates at scale?",
              "answer": "**Do NOT write to DB.** \n1. **Redis (Geo):** Update `DRIVER_LOC` (TTL 10s). Used for 'Find Driver'. \n2. **Kafka:** Push location stream for Trip History/Analytics. \n3. **Batch:** Flush to Cassandra every 30s for audit."
            },
            {
              "question": "How to find nearby drivers efficiently?",
              "answer": "Query the **Spatial Index**. \n\n**Geohash:** Find my hash `gc7`. Search for drivers with prefix `gc7`. AND check 8 neighbors (`gc6`, `gcK`...) to handle boundary issues."
            },
            {
              "question": "Design 'Live Location Sharing' (WhatsApp/Uber).",
              "answer": "**Architecture:** \n- **Client A:** Sends GPS to Gateway (WebSocket). \n- **Gateway:** Publishes to Redis Pub/Sub channel `loc_updates_userA`. \n- **Client B:** Subscribes to that channel. \n*Zero DB persistence needed for 'Live' view.*"
            },
            {
              "question": "How to handle 'Thundering Herd' when Uber goes down and comes back up?",
              "answer": "If 10M apps reconnect at once, they will DDoS the servers. \n**Solution:** Client-side **Jitter** (Randomized exponential backoff). Wait `random(0, 5s)` before retrying."
            }
          ]
        },
        {
          "id": "uber_continued",
          "name": "Uber - Deep Dive & Optimization",
          "estimatedHours": 2,
          "description": "Continue Uber design - handling driver location updates at scale, surge pricing, trip lifecycle, and global scalability.",
          "practiceQuestions": [
            {
              "name": "Design Ride Sharing",
              "slug": "design-ride-sharing",
              "difficulty": "Hard",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview/YQVkjp548NM"
            }
          ],
          "learningTip": [
            "Millions of drivers sending updates every 5 seconds = massive write load.",
            "Cell-based sharding: Shard by geographic region.",
            "Trip state machine: Requested → Matched → En-route → Completed."
          ],
          "mustNotMiss": [
            "Location Updates: Batch + Async. Don't persist every update.",
            "Cell-Based Sharding: Each city = separate shard.",
            "Trip Lifecycle: State machine with transitions.",
            "Surge Pricing: Demand/supply ratio per cell. Dynamic pricing.",
            "Global Scale: Data centers per region, geo-routing."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle high-frequency location updates from drivers?",
              "answer": "Use **UDP** (Mobile -> Load Balancer) to reduce latency/overhead. Missing a packet is fine. \n\nUse **Erlang/Go** for high-concurrency connection handling at the gateway layer."
            },
            {
              "question": "Explain surge pricing from system design perspective.",
              "answer": "**Dynamic Pricing Service.** \n\nAggregates demand/supply stream in real-time windows. \n\nUses 'S2 Geometry' library (Google) to define cells. \n\nBroadcasts multiplier to all users in that cell."
            },
            {
              "question": "How to shard Uber's data geographically?",
              "answer": "**City-Based Sharding.** \n\nA ride in NY never interacts with a driver in London. \n\n**Pros:** Fault isolation (NY crash doesn't affect London). \n\n**Cons:** Cross-shard complexity for airports/border cities."
            },
            {
              "question": "Design the trip lifecycle state machine.",
              "answer": "States: `REQUESTED -> MATCHING -> ACCEPTED -> ARRIVED -> IN_TRIP -> COMPLETED`. \n\nUse a **Distributed State Machine** (Orchestrator pattern) to ensure valid transitions and handle timeouts (Driver didn't accept)."
            },
            {
              "question": "How does Uber handle global scalability?",
              "answer": "**Region-Isolated Architecture.** \n\nEach region (NA, EU, APAC) is mostly independent. \n\nGlobal Data (User Profile, Payment Info) replicated across regions via Spanner/CockroachDB (Geo-Replication)."
            }
          ]
        }
      ]
    },
    {
      "id": "rate_limiting_infrastructure",
      "name": "Rate Limiting & Infrastructure",
      "tier": 2,
      "estimatedHours": 4,
      "topics": [
        {
          "id": "rate_limiter_id_generator",
          "name": "Rate Limiter + Unique ID Generator",
          "estimatedHours": 2,
          "description": "Design two critical infrastructure components - rate limiter to protect services, and unique ID generator for distributed systems.",
          "practiceQuestions": [
            {
              "name": "Design Rate Limiter",
              "slug": "design-rate-limiter",
              "difficulty": "Medium",
              "link": "https://github.com/donnemartin/system-design-primer#design-a-rate-limiter"
            }
          ],
          "learningTip": [
            "**Client-Side vs Server-Side:** Client-side limiting is polite. Server-side is mandatory for protection.",
            "**Granularity:** Global Limit (Protect DB) vs User Limit (Fairness).",
            "**Race Conditions:** Read-Check-Write is risky in distributed env. Need Atomicity (Lua)."
          ],
          "mustNotMiss": [
            "**Token Bucket:** Bucket has tokens. Request takes one. Refill at rate R. **Allows Bursts**.",
            "**Leaky Bucket:** Queue requests. Process at constant rate. **Smooths Traffic**.",
            "**Sliding Window Log:** Store timestamp of every request. Precise but **Expensive (Memory)**.",
            "**Sliding Window Counter:** Approximation. Hybrid of Fixed Window + Rolling. **Best of both worlds**."
          ],
          "interviewQuestions": [
            {
              "question": "Token Bucket vs Leaky Bucket usage?",
              "answer": "**Token Bucket:** Use when you *want* to allow short bursts (e.g., user loading a web page assets). \n**Leaky Bucket:** Use when backend is sensitive/slow (e.g., writing to Disc/DB) and needs a steady input stream."
            },
            {
              "question": "How to implement Distributed Rate Limiter?",
              "answer": "**Redis + Lua Script.** \n\nWhy Lua? Because fetching counter, checking limit, and incrementing are 3 separate ops. In a race, 2 users might both see '9 requests'. \n\nLua runs atomically on Redis server."
            },
            {
              "question": "What is 'Rate Limiting' vs 'Throttling' vs 'Load Shedding'?",
              "answer": "**Rate Limiting:** IP/User based. 'You use too much'. (429 Too Many Requests). \n**Throttling:** Global. 'System is busy'. Slow down everyone. \n**Load Shedding:** 'System is dying'. Drop non-critical requests (e.g., analytics) to save core features."
            },
            {
              "question": "Design a Rate Limiter for 1 Billion Users.",
              "answer": "Cannot store counters for 1B users in RAM. \n**Architecture:** \n- **Local Memory:** Cache hot users at API Gateway. \n- **Redis Cluster:** Sharded by UserID for global count. \n- **Database:** Don't use it. Too slow."
            },
            {
              "question": "How do you handle 'Hard' vs 'Soft' rate limits?",
              "answer": "**Hard:** Strict reject (HTTP 429). \n**Soft:** Allow but log/alert, or add latency (tarpitting). \n*Use Soft limits during initial rollout to tune thresholds.*"
            }
          ]
        },
        {
          "id": "rate_limiting_algorithms",
          "name": "Rate Limiting Algorithms - Deep Dive",
          "estimatedHours": 2,
          "description": "Deep dive into rate limiting algorithms - Token Bucket, Leaky Bucket, sliding window, and implementing distributed rate limiters.",
          "practiceQuestions": [
            {
              "name": "Design API Rate Limiter",
              "slug": "api-rate-limiter",
              "difficulty": "Medium",
              "link": "https://leetcode.com/discuss/interview-question/system-design/124558/rate-limiter"
            }
          ],
          "learningTip": [
            "Token Bucket allows bursts. Leaky Bucket smooths traffic.",
            "Sliding Window Log is accurate but memory-intensive.",
            "Sliding Window Counter is a balance of accuracy and efficiency."
          ],
          "mustNotMiss": [
            "Token Bucket: refill_rate, bucket_size. Allows bursts up to bucket_size.",
            "Leaky Bucket: Fixed outflow rate. Smooths traffic.",
            "Sliding Window Log: Store all request timestamps. Accurate.",
            "Sliding Window Counter: Weighted count of current + previous window.",
            "Redis INCR + EXPIRE for simple distributed rate limiting."
          ],
          "interviewQuestions": [
            "Compare Token Bucket vs Leaky Bucket vs Fixed Window.",
            "How to implement distributed rate limiter using Redis?",
            "How to handle rate limiting at API Gateway level?",
            "What are the trade-offs of different algorithms?",
            "How to rate limit by user, IP, and API key together?"
          ]
        }
      ]
    },
    {
      "id": "video_streaming",
      "name": "Video Streaming",
      "tier": 2,
      "estimatedHours": 4,
      "topics": [
        {
          "id": "ott_platform",
          "name": "Case Study: OTT Platform (Netflix)",
          "estimatedHours": 2,
          "description": "Design Netflix - video upload pipeline, transcoding, adaptive bitrate streaming, and content delivery.",
          "practiceQuestions": [
            {
              "name": "Design Netflix",
              "slug": "design-netflix",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-youtube"
            }
          ],
          "learningTip": [
            "Video goes through multiple transcodes: 4K, 1080p, 720p, 480p.",
            "HLS/DASH protocols for adaptive streaming.",
            "CDN is critical - most traffic is video."
          ],
          "mustNotMiss": [
            "Transcoding: Convert to multiple resolutions and codecs.",
            "Chunking: Split video into small segments (2-10 seconds).",
            "Manifest File: Lists all available qualities and chunk URLs.",
            "ABR: Client measures bandwidth, requests appropriate quality.",
            "CDN: Videos cached at edge locations worldwide."
          ],
          "interviewQuestions": [
            {
              "question": "How does Adaptive Bitrate Streaming (ABR) work?",
              "answer": "**Client-Driven.** Use HLS/DASH. \n\n1. Video split into 4 second chunks at multiple qualities (360p, 720p, 4K). \n\n2. Player downloads Manifest (`.m3u8`). \n\n3. Player logic: If download speed > 5Mbps, fetch 1080p chunks. If buffer drops, switch to 480p."
            },
            {
              "question": "Design the upload & processing pipeline.",
              "answer": "1. **Upload:** Pre-signed S3 URL. \n2. **Trigger:** S3 Event -> Lambda/Kafka. \n3. **Transcode:** Split into chunks. Run **Parallel Workers** (EC2 Spot Instances). \n4. **Merge:** Create Manifest. \n5. **CDN:** Push to Edge."
            },
            {
              "question": "How to handle popular vs unpopular videos (Long Tail)?",
              "answer": "**Caching Tier:** \n- **Hot (Viral):** Cache at ISP/Edge (OCAs). \n- **Warm:** S3 Standard. \n- **Cold (Old):** S3 Glacier / Deep Archive. Fetch on-demand (latency penalty)."
            },
            {
              "question": "Explain HLS vs DASH.",
              "answer": "**HLS (HTTP Live Streaming):** Apple. `.m3u8` manifest. Widely supported. \n**DASH (Dynamic Adaptive Streaming over HTTP):** International standard. `.mpd` manifest. Codec agnostic."
            },
            {
              "question": "How to implement video thumbnails/previews?",
              "answer": "**Sprite Sheets.** \n\nGenerate one large image containing all thumbnails (e.g., 10x10 grid). \n\nClient downloads ONE image. CSS uses `background-position` to show the correct frame. \n*Reduces HTTP requests.*"
            }
          ]
        },
        {
          "id": "video_streaming_continued",
          "name": "Video Streaming - DRM & Cross-Device",
          "estimatedHours": 2,
          "description": "Continue Netflix design - DRM for content protection, resume playback across devices, recommendations.",
          "practiceQuestions": [
            {
              "name": "Design YouTube",
              "slug": "design-youtube",
              "difficulty": "Hard",
              "link": "https://github.com/donnemartin/system-design-primer#design-youtube"
            }
          ],
          "learningTip": [
            "DRM encrypts video segments. Keys from license server.",
            "Playback position needs real-time sync across devices.",
            "Recommendations use collaborative filtering."
          ],
          "mustNotMiss": [
            "DRM: Widevine (Google), FairPlay (Apple), PlayReady (Microsoft).",
            "Encryption: AES encryption of video segments.",
            "License Server: Authenticates user, provides decryption keys.",
            "Resume Position: Store timestamp, sync across devices.",
            "Personalization: Recently watched, continue watching, recommendations."
          ],
          "interviewQuestions": [
            {
              "question": "How do you implement DRM for video content?",
              "answer": "1. **Encrypt:** Video chunks encrypted with AES-128. \n2. **License:** Player authenticates user -> Requests Key from License Server (Widevine/FairPlay). \n3. **Decrypt:** Browser CDM (Content Decryption Module) decrypts frame-by-frame in memory."
            },
            {
              "question": "How to resume video from exact timestamp across devices?",
              "answer": "**Heartbeat Mechanism.** \n\nClient sends heartbeat every 5s: `{ videoId: 123, timestamp: 45:20 }`. \n\n- Store in **Redis** (Last Active). \n- Flush to **Cassandra/DynamoDB** (Persistent History) periodically."
            },
            {
              "question": "How does video encryption work (Symmetric vs Asymmetric)?",
              "answer": "Content is encrypted using **Symmetric Key (AES)** because it's fast. \n\nThe Symmetric Key is encrypted using **Asymmetric Key (RSA)** for secure transmission to the client."
            },
            {
              "question": "How to implement 'Continue Watching' feature?",
              "answer": "Query the **History Service** (Cassandra). \n\nSelect video_id where `progress > 0` and `progress < 95%`. \n\nSort by `last_watched_timestamp` DESC."
            },
            {
              "question": "How do recommendation systems work at scale?",
              "answer": "**Two-Tower Architecture.** \n\n1. **Candidate Generation:** Fast retrieval of 1000 candidates (Collaborative Filtering / Matrix Factorization). \n2. **Ranking:** Heavy ML model scores top 1000 to pick top 10 (Deep Neural Networks)."
            }
          ]
        }
      ]
    },
    {
      "id": "microservices",
      "name": "Microservices Architecture",
      "tier": 3,
      "estimatedHours": 12,
      "topics": [
        {
          "id": "microservices_1",
          "name": "Microservices - Part 1: Fundamentals",
          "estimatedHours": 2,
          "description": "Introduction to microservices - benefits, drawbacks, API Gateway pattern, and when to choose over monolith.",
          "practiceQuestions": [
            {
              "name": "Design Microservices",
              "slug": "design-microservices",
              "difficulty": "Hard",
              "link": "https://microservices.io/patterns/microservices.html"
            }
          ],
          "learningTip": [
            "Microservices = organizational scalability, not just technical.",
            "API Gateway is the front door - authentication, rate limiting, routing.",
            "Start monolith, extract services when needed."
          ],
          "mustNotMiss": [
            "Benefits: Independent deployment, tech diversity, team autonomy.",
            "Drawbacks: Distributed complexity, network latency, debugging.",
            "API Gateway: Single entry point, handles cross-cutting concerns.",
            "Service Decomposition: By business domain (DDD bounded contexts).",
            "Conway's Law: Architecture mirrors team structure."
          ],
          "interviewQuestions": [
            {
              "question": "Benefits and drawbacks of Microservices vs Monolith?",
              "answer": "**Benefits:** Independent scaling, tech freedom, failure isolation. \n**Drawbacks:** Network latency, eventual consistency difficult, operational complexity (K8s needed)."
            },
            {
              "question": "Explain the API Gateway pattern.",
              "answer": "**Single Entry Point.** \n\nHandles: \n1. **Routing** (Layer 7). \n2. **AuthN/AuthZ** (Offload from services). \n3. **Rate Limiting**. \n4. **Protocol Translation** (HTTP -> gRPC)."
            },
            {
              "question": "When should you choose microservices?",
              "answer": "**Based on Org Structure.** \n\nUse when you have multiple teams contributing to different business domains that need to release independently. \n*Don't use for a startup with 3 engineers (Monolith First).* "
            },
            {
              "question": "How do you decompose a monolith into services?",
              "answer": "**By Business Capability (Vertical Slices)** or **Subdomains (DDD)**. \n\nExample: Separate 'Billing', 'User', 'Search'. \n\n*Avoid decomposing by technical layer (e.g., 'DB Service').*"
            },
            {
              "question": "What is Domain-Driven Design in microservices context?",
              "answer": "Aligning code with business reality. \n**Bounded Context:** Explicit boundary within which a domain model applies. Ideally 1 Bounded Context = 1 Microservice."
            }
          ]
        },
        {
          "id": "microservices_2",
          "name": "Microservices - Part 2: Service Communication",
          "estimatedHours": 2,
          "description": "Learn service-to-service communication patterns - sync (REST, gRPC) vs async (message queues), service discovery, and circuit breakers.",
          "practiceQuestions": [
            {
              "name": "Service Mesh Design",
              "slug": "service-mesh",
              "difficulty": "Hard",
              "link": "https://microservices.io/patterns/microservices.html"
            }
          ],
          "learningTip": [
            "Sync (REST/gRPC): Simple, but tight coupling.",
            "Async (Events): Loose coupling, but eventual consistency.",
            "Circuit Breaker prevents cascade failures."
          ],
          "mustNotMiss": [
            "Service Discovery: Services register, clients lookup. (Consul, Eureka)",
            "Circuit Breaker: Open after N failures, prevent cascade. (Hystrix)",
            "Retry with Backoff: Exponential backoff + jitter.",
            "Timeout: Always set timeouts. Prevent thread exhaustion.",
            "Bulkhead: Isolate failures. Thread pools per service."
          ],
          "interviewQuestions": [
            {
              "question": "How do you handle service discovery in microservices?",
              "answer": "**Dynamic Registry.** \n\nServices register IP/Port on startup with **Service Registry** (Consul/Eureka/K8s DNS). \n\nClients query Registry to find target Service IP."
            },
            {
              "question": "What is the Circuit Breaker pattern?",
              "answer": "Prevents cascading failure. \n\nIf Service B fails 50% of requests, **Open** the breaker. \n\nFail fast (return default/error) for 10s. \n\nThen **Half-Open** (test one request). If success, **Close**. \n*Tools: Resilience4j, Hystrix.*"
            },
            {
              "question": "Sync vs Async communication trade-offs?",
              "answer": "**Sync (REST/gRPC):** Simple. Real-time. **High coupling** (Chain of failure). \n**Async (Kafka/RabbitMQ):** Complex. Eventual consistency. **Decoupled** (Producer doesn't care if Consumer is down)."
            },
            {
              "question": "What is exponential backoff with jitter?",
              "answer": "Retry strategy. \n`WaitTime = min(Cap, Base * 2^Attempt) + Random(0, 100ms)`. \n\n**Jitter** prevents 'Thundering Herd' (synchronized retries hitting server at once)."
            },
            {
              "question": "How do you prevent cascading failures?",
              "answer": "1. **Timeouts:** Never wait forever. \n2. **Circuit Breakers:** Fail fast. \n3. **Bulkheads:** Isolate resources (separate thread pools for different downstream services)."
            }
          ]
        },
        {
          "id": "microservices_3",
          "name": "Microservices - Part 3: Service Mesh",
          "estimatedHours": 2,
          "description": "Learn service mesh architecture - sidecar pattern, Istio, and centralized configuration management.",
          "practiceQuestions": [
            {
              "name": "Istio Service Mesh",
              "slug": "istio-service-mesh",
              "difficulty": "Hard",
              "link": "https://istio.io/latest/docs/concepts/what-is-istio/"
            }
          ],
          "learningTip": [
            "Service Mesh moves network logic to infrastructure.",
            "Sidecar proxy handles all network traffic.",
            "Mutual TLS for service-to-service encryption."
          ],
          "mustNotMiss": [
            "Sidecar Pattern: Proxy container alongside app container.",
            "Istio: Data plane (Envoy proxies) + Control plane.",
            "mTLS: Mutual TLS between all services automatically.",
            "Traffic Management: Canary, A/B testing at mesh level.",
            "Config Server: Centralized config with live reload."
          ],
          "interviewQuestions": [
            {
              "question": "Explain the Sidecar pattern in Service Mesh.",
              "answer": "Deploying a proxy container (Envoy) alongside EACH application container. \n\nApp talks to localhost proxy. Proxy handles mTLS, retries, stats, tracing. \n*Decouples network logic from business logic.*"
            },
            {
              "question": "How to implement centralized configuration management?",
              "answer": "Use **Spring Cloud Config** or **Consul**. \n\n- Store config in Git. \n- Services fetch config on startup. \n- Use **Bus/Webhooks** to trigger runtime refresh (Hot Reload) without restart."
            },
            {
              "question": "What is Istio and how does it work?",
              "answer": "A Service Mesh. \n\n**Data Plane:** Envoy Proxies (Sidecars). Intercept traffic. \n**Control Plane:** Istiod. Manages config, certs, and routing rules pushed to proxies."
            },
            {
              "question": "Benefits of Service Mesh over library-based approach?",
              "answer": "**Polyglot support.** \n\nLibraries (Hystrix) are language-specific (Java). \n\nMesh (Sidecar) works with ANY language (Go, Node, Python) because it operates at L7 Network layer."
            },
            {
              "question": "How does mTLS work in service mesh?",
              "answer": "Isio automatically upgrades HTTP to HTTPS between proxies. \n\n1. Proxy A connects to Proxy B. \n2. They exchange certs (signed by internal CA). \n3. Traffic encrypted. \n*Zero code change for App.*"
            }
          ]
        },
        {
          "id": "microservices_transactions",
          "name": "Microservices - Distributed Transactions",
          "estimatedHours": 2,
          "description": "Handle distributed transactions - Saga pattern, 2PC problems, eventual consistency, and compensation logic.",
          "practiceQuestions": [
            {
              "name": "Saga Pattern",
              "slug": "saga-pattern",
              "difficulty": "Hard",
              "link": "https://microservices.io/patterns/data/saga.html"
            }
          ],
          "learningTip": [
            "2PC is blocking and doesn't scale. Avoid in microservices.",
            "Saga: Sequence of local transactions with compensations.",
            "Choreography: Events trigger next step. Orchestration: Central coordinator."
          ],
          "mustNotMiss": [
            "2PC: Prepare + Commit. Coordinator blocks. Doesn't scale.",
            "Saga Pattern: T1 → T2 → T3. Failure → C3 → C2 → C1 (compensate).",
            "Choreography: Decentralized. Services react to events.",
            "Orchestration: Central saga orchestrator coordinates steps.",
            "Idempotency: Same operation multiple times = same result."
          ],
          "interviewQuestions": [
            {
              "question": "Explain Saga Pattern (Choreography vs Orchestration).",
              "answer": "**Choreography:** Decentralized. Service A emits event, B listens. Hard to track status. \n**Orchestration:** Central Coordinator (State Machine) calls A, then B. Easy to track, but single point of failure."
            },
            {
              "question": "Why is Two-Phase Commit often avoided?",
              "answer": "**Blocking Protocol.** \n\nIf Coordinator fails after 'Prepare' phase, all participants hold locks indefinitely. \n\n*Kills throughput in distributed systems.*"
            },
            {
              "question": "How do you handle compensation in Saga?",
              "answer": "If Step 3 (Payment) fails: \n\nTrigger `undo_payment()` (if charged), then `release_inventory()` (Step 2), then `cancel_order()` (Step 1). \n*Every forward action must have a compensating backward action.*"
            },
            {
              "question": "What is the Outbox pattern?",
              "answer": "**Problem:** Saving to DB and publishing to Kafka is not atomic. \n**Solution:** Save event to `Outbox` table in SAME transaction as data. \n**Relay:** A background poller reads `Outbox` and pushes to Kafka."
            },
            {
              "question": "How to ensure idempotency in distributed systems?",
              "answer": "**Idempotency Keys.** \n\nClient generates unique UUID (`request_id`). \n\nServer checks Redis/DB: 'Have I processed `request_id` already?'. \nIf yes, return cached response."
            }
          ]
        },
        {
          "id": "ecommerce_platform",
          "name": "Case Study: E-commerce Platform (Microservices)",
          "estimatedHours": 2,
          "description": "Design an e-commerce platform - inventory management, shopping cart, order processing, and preventing overselling.",
          "practiceQuestions": [
            {
              "name": "Design Amazon",
              "slug": "design-amazon",
              "difficulty": "Hard",
              "link": "https://www.educative.io/courses/grokking-the-system-design-interview/B86Nm1W4PZp"
            }
          ],
          "learningTip": [
            "Inventory is the critical resource - prevent overselling.",
            "Cart can be client-side (simple) or server-side (persistence).",
            "Order is a saga spanning inventory, payment, shipping."
          ],
          "mustNotMiss": [
            "Services: User, Product, Inventory, Cart, Order, Payment, Shipping.",
            "Inventory Lock: Reserve on add-to-cart, release on timeout.",
            "Cart: Session-based (redis) or User-based (persist).",
            "Order Saga: Reserve → Charge → Ship. Compensate on failure.",
            "Eventual Consistency: Order confirmed ≠ immediately shipped."
          ],
          "interviewQuestions": [
            {
              "question": "Design inventory management that prevents overselling.",
              "answer": "**Optimistic Locking.** \n\n`UPDATE inventory SET count = count - 1 WHERE id = 123 AND count > 0`. \n\nIf rows updated = 0, transaction failed (Out of stock)."
            },
            {
              "question": "How to handle shopping cart state (client vs server)?",
              "answer": "**Guest:** Store in Browser Logic (LocalStorage). \n**LoggedIn:** Store in Redis (fast access) + Async write to DB (persistence). \n*Merge LocalStorage cart when user logs in.*"
            },
            {
              "question": "Design the order processing saga.",
              "answer": "1. **Order Service:** Create Order (Pending). \n2. **Inventory Service:** Reserve Stock. \n3. **Payment Service:** Charge Card. \n4. **Order Service:** Confirm Order. \n*Failure at any step triggers Compensation.*"
            },
            {
              "question": "How to handle payment failures?",
              "answer": "Use **Exponential Backoff** for network glitches. \n\nIf hard fail (Insuffient Funds), trigger Saga Compensation to release inventory and cancel order."
            },
            {
              "question": "How to handle flash sales with limited inventory?",
              "answer": "**Layered Filtering:** \n1. **CDN/WAF:** Block bots. \n2. **Redis:** Decrement counter in memory (Lua script). \n3. **Queue:** Push success events to Kafka for async DB processing. \n*Don't hit DB directly.*"
            }
          ]
        },
        {
          "id": "microservices_review",
          "name": "Microservices - Review & Best Practices",
          "estimatedHours": 2,
          "description": "Comprehensive review of microservices patterns, migrating from monolith, and production best practices.",
          "practiceQuestions": [
            {
              "name": "Monolith to Microservices",
              "slug": "monolith-to-microservices",
              "difficulty": "Hard",
              "link": "https://martinfowler.com/articles/break-monolith-into-microservices.html"
            }
          ],
          "learningTip": [
            "Strangler Fig: Gradually replace monolith pieces.",
            "Database per service is ideal but hard. Start shared, extract.",
            "Observability is non-negotiable: logs, metrics, traces."
          ],
          "mustNotMiss": [
            "Strangler Fig: New features in new service, gradually migrate.",
            "Branch by Abstraction: Create abstraction, implement new, switch.",
            "Database per Service: Isolate data. Use events for sync.",
            "API Versioning: URL (/v1/), header, or query param.",
            "12-Factor App: Config in env, stateless, disposable."
          ],
          "interviewQuestions": [
            {
              "question": "How to migrate monolith to microservices incrementally?",
              "answer": "**Strangler Fig Pattern.** \n\n1. Identify one cohesive features (e.g., Auth). \n2. Build new Auth Service. \n3. Route auth traffic to new service. \n4. Retire old code. \n5. Repeat."
            },
            {
              "question": "Discuss Bulkhead pattern for fault tolerance.",
              "answer": "Ship analogy: If one compartment floods, others stay dry. \n\n**Tech:** Use separate Thread Pools / Connection Pools for different downstream services. \nIf 'Recommendations' is slow, it won't starve 'Search' threads."
            },
            {
              "question": "What is the Strangler Fig pattern?",
              "answer": "A migration pattern where a new system helps gradually replace an old system. \n\nThe new system wraps the old one, intercepting calls and handling them or passing them through, until the old system is strangled (replaced)."
            },
            {
              "question": "Best practices for API versioning?",
              "answer": "**URL Versioning:** `/v1/users`. Explicit and easy to debug. \n**Header Versioning:** `Accept: application/vnd.myapi.v1+json`. Cleaner URLs but harder to test via browser."
            },
            {
              "question": "What are the 12-Factor App principles?",
              "answer": "A methodology for building SaaS apps. \n\nKey points: \n- **Config:** Store in Env vars. \n- **Backing Services:** Treat DB/Cache as attached resources. \n- **Process:** Stateless execution. \n- **Disposability:** Fast startup/shutdown."
            }
          ]
        }
      ]
    },
    {
      "id": "infrastructure_tools",
      "name": "Infrastructure Deep Dives",
      "tier": 3,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "redis_deep_dive",
          "name": "System Design - Redis Deep Dive",
          "estimatedHours": 2,
          "description": "Master Redis internals - data structures, persistence, replication, clustering, and common use cases.",
          "practiceQuestions": [
            {
              "name": "Design Redis",
              "slug": "design-redis",
              "difficulty": "Hard",
              "link": "https://redis.io/topics/internals"
            }
          ],
          "learningTip": [
            "Redis is single-threaded but incredibly fast due to memory + efficient data structures.",
            "Pub/Sub is fire-and-forget. Use Streams for persistence.",
            "Cluster mode for scaling beyond single node."
          ],
          "mustNotMiss": [
            "Data Types: String, List, Set, Sorted Set, Hash, Stream.",
            "Sorted Set: Leaderboards, rate limiting, priority queues.",
            "Persistence: RDB (snapshots) vs AOF (append-only log).",
            "Replication: Master-Slave. Sentinel for auto-failover.",
            "Cluster: Sharding across nodes. 16384 hash slots."
          ],
          "interviewQuestions": [
            {
              "question": "Explain Redis data types and use cases.",
              "answer": "**String:** Cache, Counter. \n**Hash:** User Profile object. \n**List:** Job Queue. \n**Set:** Unique visitors. \n**Sorted Set:** Leaderboard. \n**HyperLogLog:** Count unique items (approx) with tiny memory."
            },
            {
              "question": "How does Redis persistence (RDB vs AOF) work?",
              "answer": "**RDB (Snapshot):** Forks process to save DB to disk every X mins. Compact but potential data loss. \n**AOF (Append Only File):** Logs every write. Slower restart but durable. \n*Use both for best reliability.*"
            },
            {
              "question": "How does Redis Cluster handle sharding?",
              "answer": "Uses **Hash Slots** (0 to 16383). \n\n`Slot = CRC16(Key) % 16384`. \n\nEvery node holds a subset of slots. Client redirects to correct node"
            },
            {
              "question": "When to use Redis Streams vs Pub/Sub?",
              "answer": "**Pub/Sub:** Fire and forget. No history. If consumer down, msg lost. \n**Streams:** Log-based (like Kafka lite). Persisted. Consumer Groups allow resume reading."
            },
            {
              "question": "How does Redis Sentinel provide high availability?",
              "answer": "Monitoring process. \n\nIf Master fails, Sentinels vote (Quorum). \n\nPromote Slave to Master. \n\nUpdate Clients with new Master IP."
            }
          ]
        },
        {
          "id": "elasticsearch_deep_dive",
          "name": "System Design - ElasticSearch Deep Dive",
          "estimatedHours": 2,
          "description": "Master Elasticsearch - indexing strategies, query optimization, scaling, and operational best practices.",
          "practiceQuestions": [
            {
              "name": "Design Search System",
              "slug": "design-search-system",
              "difficulty": "Hard",
              "link": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html"
            }
          ],
          "learningTip": [
            "Avoid mapping explosion - limit dynamic fields.",
            "Refresh interval affects indexing speed vs search freshness.",
            "Bulk operations for high-throughput indexing."
          ],
          "mustNotMiss": [
            "Mapping: Define field types upfront. Dynamic = risky.",
            "Analyzers: Standard, Keyword, Whitespace, Custom.",
            "Refresh: Controls when indexed docs become searchable.",
            "Shards: Primary (indexing) vs Replica (search scaling).",
            "Bulk API: Batch operations for efficiency."
          ],
          "interviewQuestions": [
            {
              "question": "How to optimize ES for heavy write workloads?",
              "answer": "1. **Increase Refresh Interval:** Default 1s -> 30s. Reduces segment merging. \n2. **Bulk Indexing:** Batch documents. \n3. **Disable Replicas:** Initially, then enable after load."
            },
            {
              "question": "Explain Analyzers and Mapping in ES.",
              "answer": "**Analyzer:** Tokenizer + Filter (Lowercase, Stopwords). \n**Mapping:** Schema definition (`integer`, `keyword`, `text`). \n*Keyword = Exact match. Text = Full-text search.*"
            },
            {
              "question": "How to handle mapping explosion?",
              "answer": "**Flattening:** Use `nested` object type carefully or `flattened` type. \n**Dynamic Mapping:** Disable it (`dynamic: false`) to prevent accidental field creation."
            },
            {
              "question": "Shard allocation strategy?",
              "answer": "**Avoid Oversharding.** \n\nIdeal Shard Size: **10GB - 50GB**. \n\nFormula: `Shards = Target_Size / 30GB`. \n*Too many small shards = High Heap usage.*"
            },
            {
              "question": "How to reindex without downtime?",
              "answer": "**Aliases.** \n\n1. App points to Alias `logs_current`. \n2. Create new Index `logs_v2`. \n3. Reindex data v1 -> v2. \n4. Switch Alias `logs_current` -> `logs_v2` atomically."
            }
          ]
        },
        {
          "id": "kafka_deep_dive",
          "name": "System Design - Kafka Deep Dive",
          "estimatedHours": 2,
          "description": "Master Kafka internals - partition replication, consumer protocol, exactly-once semantics, and operational tuning.",
          "practiceQuestions": [
            {
              "name": "Design Event Streaming",
              "slug": "design-event-streaming",
              "difficulty": "Hard",
              "link": "https://kafka.apache.org/documentation/"
            }
          ],
          "learningTip": [
            "More partitions = more parallelism but also overhead.",
            "Consumer lag monitoring is critical for health.",
            "Compression at producer reduces network and storage."
          ],
          "mustNotMiss": [
            "ISR (In-Sync Replicas): Replicas caught up with leader.",
            "Acks: 0 (fire-forget), 1 (leader ack), all (ISR ack).",
            "Idempotent Producer: Dedup using sequence numbers.",
            "Exactly-Once: Idempotent producer + Transactional consumer.",
            "Log Compaction: Keep latest value per key. For KV store."
          ],
          "interviewQuestions": [
            {
              "question": "How to handle poison pill messages?",
              "answer": "A message that crashes the consumer. \n\n**Solution:** \n1. Dead Letter Queue (DLQ). After N retries, move to DLQ. \n2. Alert human to inspect DLQ."
            },
            {
              "question": "Explain Consumer Groups and offsets.",
              "answer": "**Consumer Group:** Logical subscriber. Each partition is consumed by ONLY one consumer in the group (Parallelism). \n**Offset:** Bookmark. Tracks position in the log."
            },
            {
              "question": "How does exactly-once work in Kafka?",
              "answer": "**Idempotent Producer:** Ensures no dupe writes to log. \n**Transactional Consumer:** `read_process_write` atomic transaction across topics. \n*Use Kafka Streams for this.*"
            },
            {
              "question": "What is log compaction and when to use it?",
              "answer": "Retains only the **Last Known Value** for each Key. \n\nUse for: State Stores (e.g., 'User Balance'). Deletes old balance updates."
            },
            {
              "question": "How to handle consumer lag?",
              "answer": "**Scale Up:** Add more partitions and more consumers. \n**Optimize Processing:** Make consumer logic faster (Async processing). \n*Monitor `MaxLag` metric.*"
            }
          ]
        }
      ]
    },
    {
      "id": "recommended_topics",
      "name": "Critical Additional Topics",
      "tier": 3,
      "estimatedHours": 6,
      "topics": [
        {
          "id": "api_paradigms",
          "name": "API Paradigms (REST vs GraphQL vs gRPC)",
          "estimatedHours": 2,
          "description": "Compare API paradigms - when to use REST, GraphQL, or gRPC. Understand trade-offs for different use cases.",
          "practiceQuestions": [
            {
              "name": "Design GraphQL API",
              "slug": "design-graphql",
              "difficulty": "Medium",
              "link": "https://graphql.org/learn/"
            }
          ],
          "learningTip": [
            "REST: Simple, stateless, cacheable. Great for public APIs.",
            "GraphQL: Client specifies exact data. Great for varied clients.",
            "gRPC: Binary, fast, streaming. Great for internal services."
          ],
          "mustNotMiss": [
            "REST: Resources, HTTP methods, stateless. Simple and universal.",
            "GraphQL: Query language, schema, single endpoint. Solves over/under-fetching.",
            "gRPC: Protocol Buffers, HTTP/2, bidirectional streaming.",
            "When REST: Simple CRUD, caching important, public API.",
            "When gRPC: Internal microservices, performance critical."
          ],
          "interviewQuestions": [
            {
              "question": "When would you choose gRPC over REST for internal services?",
              "answer": "**Performance & Type Safety.** \n\ngRPC uses Protobuf (binary, smaller) and HTTP/2 (multiplexing). It generates typed client/server code. \n\n*Ideal for high-throughput microservices.*"
            },
            {
              "question": "Explain Overfetching and Underfetching solved by GraphQL.",
              "answer": "**Overfetching:** REST returns full User object when you only need `name`. \n**Underfetching:** REST requires 3 calls (`/user`, `/posts`, `/comments`) to build a view. \n\nGraphQL solves both with a single query specifying exact fields."
            },
            {
              "question": "How does gRPC achieve better performance than REST?",
              "answer": "1. **Binary Serialization (Protobuf):** Smaller payload than JSON. \n2. **HTTP/2 Transport:** Multiplexing (multiple streams over one TCP conn) & Header Compression (HPACK)."
            },
            {
              "question": "Challenges with GraphQL (N+1, caching)?",
              "answer": "**N+1 Problem:** Query for 10 users + their latest post might trigger 10+1 DB queries. Fix: **DataLoader** (Batching). \n**Caching:** Harder than REST (POST requests). Need application-level caching (Persisted Queries)."
            },
            {
              "question": "How to version REST vs GraphQL APIs?",
              "answer": "**REST:** URL (`/v1/`) or Header. Explicit breaking changes. \n**GraphQL:** **Evolution**. Mark fields `@deprecated`. Add new fields. Client decides when to switch. Avoids versioning entire API."
            }
          ]
        },
        {
          "id": "security_engineering",
          "name": "Security Engineering",
          "estimatedHours": 2,
          "description": "Security fundamentals for system design - OAuth 2.0, API security, encryption, and common attack prevention.",
          "practiceQuestions": [
            {
              "name": "Design Authentication System",
              "slug": "design-auth",
              "difficulty": "Hard",
              "link": "https://oauth.net/2/"
            }
          ],
          "learningTip": [
            "OAuth is for authorization, not authentication. OpenID Connect adds auth.",
            "JWT: Self-contained tokens. No DB lookup needed.",
            "Rate limiting is first line of defense against DDoS."
          ],
          "mustNotMiss": [
            "OAuth 2.0 Flows: Authorization Code (web), Client Credentials (M2M).",
            "JWT: Header.Payload.Signature. Stateless tokens.",
            "HTTPS: TLS encryption. Always. No exceptions.",
            "API Security: Rate limiting, input validation, authentication.",
            "Common Attacks: SQL injection, XSS, CSRF. Know prevention."
          ],
          "interviewQuestions": [
            {
              "question": "Explain OAuth 2.0 Authorization Code flow.",
              "answer": "1. User clicks 'Login with Google'. \n2. Redirect to Google Auth Server. \n3. User approves. Google redirects back with `code`. \n4. Backend swaps `code` for `access_token`."
            },
            {
              "question": "How to secure public API against DDoS and MITM?",
              "answer": "**DDoS:** Rate Limiting (Token Bucket), WAF (Cloudflare), IP Blacklisting. \n**MITM:** HTTPS (TLS 1.3) with HSTS (Strict Transport Security) to force encrypted connection."
            },
            {
              "question": "JWT vs Session-based authentication?",
              "answer": "**Session:** Server stores state (Memory/Redis). Cookie sent by client. Revocable. \n**JWT:** Stateless. Data in token. Scalable but hard to revoke (needs Blacklist/Short Expiry)."
            },
            {
              "question": "How does HTTPS/TLS protect data?",
              "answer": "1. **Handshake:** Server sends Cert. Client verifies with CA. \n2. **Key Exchange:** ECDHE to agree on Session Key. \n3. **Encryption:** AES-GCM for data transfer."
            },
            {
              "question": "How to implement API key rotation?",
              "answer": "Support **Two Keys** (Active, Pending). \n\n1. Generate Key B. \n2. Update Client to use Key B. \n3. Monitor Key A usage (wait for 0). \n4. Revoke Key A."
            }
          ]
        },
        {
          "id": "observability",
          "name": "Observability (Logging, Metrics, Tracing)",
          "estimatedHours": 2,
          "description": "Design observability stack - centralized logging, metrics collection, distributed tracing, and alerting.",
          "practiceQuestions": [
            {
              "name": "Design Monitoring System",
              "slug": "design-monitoring",
              "difficulty": "Hard",
              "link": "https://sre.google/sre-book/monitoring-distributed-systems/"
            }
          ],
          "learningTip": [
            "Three pillars: Logs (events), Metrics (numbers), Traces (requests).",
            "Golden Signals: Latency, Traffic, Errors, Saturation.",
            "Structured logging enables querying. JSON, not plain text."
          ],
          "mustNotMiss": [
            "ELK Stack: Elasticsearch + Logstash + Kibana for centralized logs.",
            "Prometheus + Grafana: Metrics collection and visualization.",
            "Jaeger/Zipkin: Distributed tracing across services.",
            "Golden Signals: Latency, Traffic, Errors, Saturation. Must monitor.",
            "Alerting: Alert on symptoms (latency), not causes (CPU)."
          ],
          "interviewQuestions": [
            {
              "question": "Design centralized logging system using ELK Stack.",
              "answer": "1. **Filebeat:** Agent on App Server ships logs. \n2. **Kafka:** Buffers logs (Handling spikes). \n3. **Logstash:** Filters/Parses (Grok). \n4. **Elasticsearch:** Indexing. \n5. **Kibana:** Visualization."
            },
            {
              "question": "What are the Golden Signals of monitoring?",
              "answer": "Started by Google SRE: \n1. **Latency:** Time to serve. \n2. **Traffic:** RPS. \n3. **Errors:** 5xx rate. \n4. **Saturation:** Resource fullness (CPU, Queue Depth)."
            },
            {
              "question": "How does distributed tracing work?",
              "answer": "Pass a **TraceID** (Global) and **SpanID** (Local) in HTTP Headers (`X-B3-TraceId`) across all microservices. \nCollector (Jaeger) stitches Spans together to visualize the waterfall."
            },
            {
              "question": "How to implement request correlation across services?",
              "answer": "Middleware at entry point generates `Correlation-ID`. \n\nEvery Log line must include this ID. \n\nPass it downstream headers. \n*Enables searching all logs for one user request.*"
            },
            {
              "question": "Best practices for alerting (avoiding alert fatigue)?",
              "answer": "**Alert on Symptoms, not Causes.** \n\nAlert: 'High Error Rate' or 'High Latency'. \nDon't Alert: 'CPU > 80%' (if latency is fine, CPU is fine). \n*Page only for actionable, urgent issues.*"
            }
          ]
        }
      ]
    }
  ],
  "recommendedHoursPerWeek": 2
}
